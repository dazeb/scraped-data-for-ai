[
  {
    "title": "Reactivity Transform | Vue.js",
    "url": "https://vuejs.org/guide/extras/reactivity-transform",
    "html": "Skip to content\nGet 60% off a year of Vue Mastery courses\nGET DISCOUNT\nVue.js\nSearch\nCtrl\nK\nMain Navigation\nDocs\nAPI\nPlayground\nEcosystem\nAbout\nSponsor\nPartners\ngithub\ntwitter\ndiscord\nAPI Preference\nOptions\nComposition\n?\n\nAPI style now defaults to Composition API.\n\nSome pages contain different content based on the API style chosen. Use this switch to toggle between APIs styles.\n\nLearn moreGot it\n\nSidebar Navigation\nGetting Started\n\nIntroduction\n\nQuick Start\n\nEssentials\n\nCreating an Application\n\nTemplate Syntax\n\nReactivity Fundamentals\n\nComputed Properties\n\nClass and Style Bindings\n\nConditional Rendering\n\nList Rendering\n\nEvent Handling\n\nForm Input Bindings\n\nLifecycle Hooks\n\nWatchers\n\nTemplate Refs\n\nComponents Basics\n\nComponents In-Depth\n\nRegistration\n\nProps\n\nEvents\n\nComponent v-model\n\nFallthrough Attributes\n\nSlots\n\nProvide / inject\n\nAsync Components\n\nReusability\n\nComposables\n\nCustom Directives\n\nPlugins\n\nBuilt-in Components\n\nTransition\n\nTransitionGroup\n\nKeepAlive\n\nTeleport\n\nSuspense\n\nScaling Up\n\nSingle-File Components\n\nTooling\n\nRouting\n\nState Management\n\nTesting\n\nServer-Side Rendering (SSR)\n\nBest Practices\n\nProduction Deployment\n\nPerformance\n\nAccessibility\n\nSecurity\n\nTypeScript\n\nOverview\n\nTS with Composition API\n\nTS with Options API\n\nExtra Topics\n\nWays of Using Vue\n\nComposition API FAQ\n\nReactivity in Depth\n\nRendering Mechanism\n\nRender Functions & JSX\n\nVue and Web Components\n\nAnimation Techniques\n\nON THIS PAGE\nTable of Contents for current page\nRefs vs. Reactive Variables\nDestructuring with $()\nConvert Existing Refs to Reactive Variables with $()\nReactive Props Destructure\nRetaining Reactivity Across Function Boundaries\nTypeScript Integration\nExplicit Opt-in\nSPONSORS\nBecome a Sponsor\nFast implementation, a customizable login experience, and flexible user journeys. Try Auth0 for free\nADS VIA CARBON\nReactivity Transform\n​\n\nRemoved Experimental Feature\n\nReactivity Transform was an experimental feature, and has been removed in the latest 3.4 release. Please read about the reasoning here.\n\nIf you still intend to use it, it is now available via the Vue Macros plugin.\n\nComposition-API-specific\n\nReactivity Transform is a Composition-API-specific feature and requires a build step.\n\nRefs vs. Reactive Variables\n​\n\nEver since the introduction of the Composition API, one of the primary unresolved questions is the use of refs vs. reactive objects. It's easy to lose reactivity when destructuring reactive objects, while it can be cumbersome to use .value everywhere when using refs. Also, .value is easy to miss if not using a type system.\n\nVue Reactivity Transform is a compile-time transform that allows us to write code like this:\n\nvue\n<script setup>\nlet count = $ref(0)\n\nconsole.log(count)\n\nfunction increment() {\n  count++\n}\n</script>\n\n<template>\n  <button @click=\"increment\">{{ count }}</button>\n</template>\n\nThe $ref() method here is a compile-time macro: it is not an actual method that will be called at runtime. Instead, the Vue compiler uses it as a hint to treat the resulting count variable as a reactive variable.\n\nReactive variables can be accessed and re-assigned just like normal variables, but these operations are compiled into refs with .value. For example, the <script> part of the above component is compiled into:\n\njs\nimport { ref } from 'vue'\n\nlet count = ref(0)\n\nconsole.log(count.value)\n\nfunction increment() {\n  count.value++\n}\n\nEvery reactivity API that returns refs will have a $-prefixed macro equivalent. These APIs include:\n\nref -> $ref\ncomputed -> $computed\nshallowRef -> $shallowRef\ncustomRef -> $customRef\ntoRef -> $toRef\n\nThese macros are globally available and do not need to be imported when Reactivity Transform is enabled, but you can optionally import them from vue/macros if you want to be more explicit:\n\njs\nimport { $ref } from 'vue/macros'\n\nlet count = $ref(0)\nDestructuring with $()\n​\n\nIt is common for a composition function to return an object of refs, and use destructuring to retrieve these refs. For this purpose, reactivity transform provides the $() macro:\n\njs\nimport { useMouse } from '@vueuse/core'\n\nconst { x, y } = $(useMouse())\n\nconsole.log(x, y)\n\nCompiled output:\n\njs\nimport { toRef } from 'vue'\nimport { useMouse } from '@vueuse/core'\n\nconst __temp = useMouse(),\n  x = toRef(__temp, 'x'),\n  y = toRef(__temp, 'y')\n\nconsole.log(x.value, y.value)\n\nNote that if x is already a ref, toRef(__temp, 'x') will simply return it as-is and no additional ref will be created. If a destructured value is not a ref (e.g. a function), it will still work - the value will be wrapped in a ref so the rest of the code works as expected.\n\n$() destructure works on both reactive objects and plain objects containing refs.\n\nConvert Existing Refs to Reactive Variables with $()\n​\n\nIn some cases we may have wrapped functions that also return refs. However, the Vue compiler won't be able to know ahead of time that a function is going to return a ref. In such cases, the $() macro can also be used to convert any existing refs into reactive variables:\n\njs\nfunction myCreateRef() {\n  return ref(0)\n}\n\nlet count = $(myCreateRef())\nReactive Props Destructure\n​\n\nThere are two pain points with the current defineProps() usage in <script setup>:\n\nSimilar to .value, you need to always access props as props.x in order to retain reactivity. This means you cannot destructure defineProps because the resulting destructured variables are not reactive and will not update.\n\nWhen using the type-only props declaration, there is no easy way to declare default values for the props. We introduced the withDefaults() API for this exact purpose, but it's still clunky to use.\n\nWe can address these issues by applying a compile-time transform when defineProps is used with destructuring, similar to what we saw earlier with $():\n\nhtml\n<script setup lang=\"ts\">\n  interface Props {\n    msg: string\n    count?: number\n    foo?: string\n  }\n\n  const {\n    msg,\n    // default value just works\n    count = 1,\n    // local aliasing also just works\n    // here we are aliasing `props.foo` to `bar`\n    foo: bar\n  } = defineProps<Props>()\n\n  watchEffect(() => {\n    // will log whenever the props change\n    console.log(msg, count, bar)\n  })\n</script>\n\nThe above will be compiled into the following runtime declaration equivalent:\n\njs\nexport default {\n  props: {\n    msg: { type: String, required: true },\n    count: { type: Number, default: 1 },\n    foo: String\n  },\n  setup(props) {\n    watchEffect(() => {\n      console.log(props.msg, props.count, props.foo)\n    })\n  }\n}\nRetaining Reactivity Across Function Boundaries\n​\n\nWhile reactive variables relieve us from having to use .value everywhere, it creates an issue of \"reactivity loss\" when we pass reactive variables across function boundaries. This can happen in two cases:\n\nPassing into function as argument\n​\n\nGiven a function that expects a ref as an argument, e.g.:\n\nts\nfunction trackChange(x: Ref<number>) {\n  watch(x, (x) => {\n    console.log('x changed!')\n  })\n}\n\nlet count = $ref(0)\ntrackChange(count) // doesn't work!\n\nThe above case will not work as expected because it compiles to:\n\nts\nlet count = ref(0)\ntrackChange(count.value)\n\nHere count.value is passed as a number, whereas trackChange expects an actual ref. This can be fixed by wrapping count with $$() before passing it:\n\ndiff\nlet count = $ref(0)\n- trackChange(count)\n+ trackChange($$(count))\n\nThe above compiles to:\n\njs\nimport { ref } from 'vue'\n\nlet count = ref(0)\ntrackChange(count)\n\nAs we can see, $$() is a macro that serves as an escape hint: reactive variables inside $$() will not get .value appended.\n\nReturning inside function scope\n​\n\nReactivity can also be lost if reactive variables are used directly in a returned expression:\n\nts\nfunction useMouse() {\n  let x = $ref(0)\n  let y = $ref(0)\n\n  // listen to mousemove...\n\n  // doesn't work!\n  return {\n    x,\n    y\n  }\n}\n\nThe above return statement compiles to:\n\nts\nreturn {\n  x: x.value,\n  y: y.value\n}\n\nIn order to retain reactivity, we should be returning the actual refs, not the current value at return time.\n\nAgain, we can use $$() to fix this. In this case, $$() can be used directly on the returned object - any reference to reactive variables inside the $$() call will retain the reference to their underlying refs:\n\nts\nfunction useMouse() {\n  let x = $ref(0)\n  let y = $ref(0)\n\n  // listen to mousemove...\n\n  // fixed\n  return $$({\n    x,\n    y\n  })\n}\nUsing $$() on destructured props\n​\n\n$$() works on destructured props since they are reactive variables as well. The compiler will convert it with toRef for efficiency:\n\nts\nconst { count } = defineProps<{ count: number }>()\n\npassAsRef($$(count))\n\ncompiles to:\n\njs\nsetup(props) {\n  const __props_count = toRef(props, 'count')\n  passAsRef(__props_count)\n}\nTypeScript Integration \n​\n\nVue provides typings for these macros (available globally) and all types will work as expected. There are no incompatibilities with standard TypeScript semantics, so the syntax will work with all existing tooling.\n\nThis also means the macros can work in any files where valid JS / TS are allowed - not just inside Vue SFCs.\n\nSince the macros are available globally, their types need to be explicitly referenced (e.g. in a env.d.ts file):\n\nts\n/// <reference types=\"vue/macros-global\" />\n\nWhen explicitly importing the macros from vue/macros, the type will work without declaring the globals.\n\nExplicit Opt-in\n​\n\nNo longer supported in core\n\nThe following only applies up to Vue version 3.3 and below. Support has been removed in Vue core 3.4 and above, and @vitejs/plugin-vue 5.0 and above. If you intend to continue using the transform, please migrate to Vue Macros instead.\n\nVite\n​\nRequires @vitejs/plugin-vue@>=2.0.0\nApplies to SFCs and js(x)/ts(x) files. A fast usage check is performed on files before applying the transform so there should be no performance cost for files not using the macros.\nNote reactivityTransform is now a plugin root-level option instead of nested as script.refSugar, since it affects not just SFCs.\njs\n// vite.config.js\nexport default {\n  plugins: [\n    vue({\n      reactivityTransform: true\n    })\n  ]\n}\nvue-cli\n​\nCurrently only affects SFCs\nRequires vue-loader@>=17.0.0\njs\n// vue.config.js\nmodule.exports = {\n  chainWebpack: (config) => {\n    config.module\n      .rule('vue')\n      .use('vue-loader')\n      .tap((options) => {\n        return {\n          ...options,\n          reactivityTransform: true\n        }\n      })\n  }\n}\nPlain webpack + vue-loader\n​\nCurrently only affects SFCs\nRequires vue-loader@>=17.0.0\njs\n// webpack.config.js\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.vue$/,\n        loader: 'vue-loader',\n        options: {\n          reactivityTransform: true\n        }\n      }\n    ]\n  }\n}\n\nEdit this page on GitHub\n\nNext \nIntroduction\nReactivity Transform has loaded"
  },
  {
    "title": "Animation Techniques | Vue.js",
    "url": "https://vuejs.org/guide/extras/animation",
    "html": "Skip to content\nGet 60% off a year of Vue Mastery courses\nGET DISCOUNT\nVue.js\nSearch\nCtrl\nK\nMain Navigation\nDocs\nAPI\nPlayground\nEcosystem\nAbout\nSponsor\nPartners\ngithub\ntwitter\ndiscord\nAPI Preference\nOptions\nComposition\n?\n\nAPI style now defaults to Composition API.\n\nSome pages contain different content based on the API style chosen. Use this switch to toggle between APIs styles.\n\nLearn moreGot it\n\nSidebar Navigation\nGetting Started\n\nIntroduction\n\nQuick Start\n\nEssentials\n\nCreating an Application\n\nTemplate Syntax\n\nReactivity Fundamentals\n\nComputed Properties\n\nClass and Style Bindings\n\nConditional Rendering\n\nList Rendering\n\nEvent Handling\n\nForm Input Bindings\n\nLifecycle Hooks\n\nWatchers\n\nTemplate Refs\n\nComponents Basics\n\nComponents In-Depth\n\nRegistration\n\nProps\n\nEvents\n\nComponent v-model\n\nFallthrough Attributes\n\nSlots\n\nProvide / inject\n\nAsync Components\n\nReusability\n\nComposables\n\nCustom Directives\n\nPlugins\n\nBuilt-in Components\n\nTransition\n\nTransitionGroup\n\nKeepAlive\n\nTeleport\n\nSuspense\n\nScaling Up\n\nSingle-File Components\n\nTooling\n\nRouting\n\nState Management\n\nTesting\n\nServer-Side Rendering (SSR)\n\nBest Practices\n\nProduction Deployment\n\nPerformance\n\nAccessibility\n\nSecurity\n\nTypeScript\n\nOverview\n\nTS with Composition API\n\nTS with Options API\n\nExtra Topics\n\nWays of Using Vue\n\nComposition API FAQ\n\nReactivity in Depth\n\nRendering Mechanism\n\nRender Functions & JSX\n\nVue and Web Components\n\nAnimation Techniques\n\nON THIS PAGE\nTable of Contents for current page\nClass-based Animations\nState-driven Animations\nAnimating with Watchers\nSPONSORS\nBecome a Sponsor\nLoved by developers. Trusted by enterprises. Start your free 30 day trial.\nADS VIA CARBON\nAnimation Techniques\n​\n\nVue provides the <Transition> and <TransitionGroup> components for handling enter / leave and list transitions. However, there are many other ways of using animations on the web, even in a Vue application. Here we will discuss a few additional techniques.\n\nClass-based Animations\n​\n\nFor elements that are not entering / leaving the DOM, we can trigger animations by dynamically adding a CSS class:\n\njs\nconst disabled = ref(false)\n\nfunction warnDisabled() {\n  disabled.value = true\n  setTimeout(() => {\n    disabled.value = false\n  }, 1500)\n}\ntemplate\n<div :class=\"{ shake: disabled }\">\n  <button @click=\"warnDisabled\">Click me</button>\n  <span v-if=\"disabled\">This feature is disabled!</span>\n</div>\ncss\n.shake {\n  animation: shake 0.82s cubic-bezier(0.36, 0.07, 0.19, 0.97) both;\n  transform: translate3d(0, 0, 0);\n}\n\n@keyframes shake {\n  10%,\n  90% {\n    transform: translate3d(-1px, 0, 0);\n  }\n\n  20%,\n  80% {\n    transform: translate3d(2px, 0, 0);\n  }\n\n  30%,\n  50%,\n  70% {\n    transform: translate3d(-4px, 0, 0);\n  }\n\n  40%,\n  60% {\n    transform: translate3d(4px, 0, 0);\n  }\n}\nClick me\nState-driven Animations\n​\n\nSome transition effects can be applied by interpolating values, for instance by binding a style to an element while an interaction occurs. Take this example for instance:\n\njs\nconst x = ref(0)\n\nfunction onMousemove(e) {\n  x.value = e.clientX\n}\ntemplate\n<div\n  @mousemove=\"onMousemove\"\n  :style=\"{ backgroundColor: `hsl(${x}, 80%, 50%)` }\"\n  class=\"movearea\"\n>\n  <p>Move your mouse across this div...</p>\n  <p>x: {{ x }}</p>\n</div>\ncss\n.movearea {\n  transition: 0.3s background-color ease;\n}\n\nMove your mouse across this div...\n\nx: 0\n\nIn addition to color, you can also use style bindings to animate transform, width, or height. You can even animate SVG paths using spring physics - after all, they are all attribute data bindings:\n\nDrag Me\nSource code\nAnimating with Watchers\n​\n\nWith some creativity, we can use watchers to animate anything based on some numerical state. For example, we can animate the number itself:\n\njs\nimport { ref, reactive, watch } from 'vue'\nimport gsap from 'gsap'\n\nconst number = ref(0)\nconst tweened = reactive({\n  number: 0\n})\n\nwatch(number, (n) => {\n  gsap.to(tweened, { duration: 0.5, number: Number(n) || 0 })\n})\ntemplate\nType a number: <input v-model.number=\"number\" />\n<p>{{ tweened.number.toFixed(0) }}</p>\nType a number: \n\n0\n\nTry it in the Playground\n\nEdit this page on GitHub\n\n Previous\nVue and Web Components\nAnimation Techniques has loaded"
  },
  {
    "title": "Vue and Web Components | Vue.js",
    "url": "https://vuejs.org/guide/extras/web-components",
    "html": "Skip to content\nGet 60% off a year of Vue Mastery courses\nGET DISCOUNT\nVue.js\nSearch\nCtrl\nK\nMain Navigation\nDocs\nAPI\nPlayground\nEcosystem\nAbout\nSponsor\nPartners\ngithub\ntwitter\ndiscord\nAPI Preference\nOptions\nComposition\n?\n\nAPI style now defaults to Composition API.\n\nSome pages contain different content based on the API style chosen. Use this switch to toggle between APIs styles.\n\nLearn moreGot it\n\nSidebar Navigation\nGetting Started\n\nIntroduction\n\nQuick Start\n\nEssentials\n\nCreating an Application\n\nTemplate Syntax\n\nReactivity Fundamentals\n\nComputed Properties\n\nClass and Style Bindings\n\nConditional Rendering\n\nList Rendering\n\nEvent Handling\n\nForm Input Bindings\n\nLifecycle Hooks\n\nWatchers\n\nTemplate Refs\n\nComponents Basics\n\nComponents In-Depth\n\nRegistration\n\nProps\n\nEvents\n\nComponent v-model\n\nFallthrough Attributes\n\nSlots\n\nProvide / inject\n\nAsync Components\n\nReusability\n\nComposables\n\nCustom Directives\n\nPlugins\n\nBuilt-in Components\n\nTransition\n\nTransitionGroup\n\nKeepAlive\n\nTeleport\n\nSuspense\n\nScaling Up\n\nSingle-File Components\n\nTooling\n\nRouting\n\nState Management\n\nTesting\n\nServer-Side Rendering (SSR)\n\nBest Practices\n\nProduction Deployment\n\nPerformance\n\nAccessibility\n\nSecurity\n\nTypeScript\n\nOverview\n\nTS with Composition API\n\nTS with Options API\n\nExtra Topics\n\nWays of Using Vue\n\nComposition API FAQ\n\nReactivity in Depth\n\nRendering Mechanism\n\nRender Functions & JSX\n\nVue and Web Components\n\nAnimation Techniques\n\nON THIS PAGE\nTable of Contents for current page\nUsing Custom Elements in Vue\nBuilding Custom Elements with Vue\nWeb Components vs. Vue Components\nSPONSORS\nBecome a Sponsor\nTop-tier Infra protection. Robust Baremetal. Anti-DDoS Included. Secure your Infra\nADS VIA CARBON\nVue and Web Components\n​\n\nWeb Components is an umbrella term for a set of web native APIs that allows developers to create reusable custom elements.\n\nWe consider Vue and Web Components to be primarily complementary technologies. Vue has excellent support for both consuming and creating custom elements. Whether you are integrating custom elements into an existing Vue application, or using Vue to build and distribute custom elements, you are in good company.\n\nUsing Custom Elements in Vue\n​\n\nVue scores a perfect 100% in the Custom Elements Everywhere tests. Consuming custom elements inside a Vue application largely works the same as using native HTML elements, with a few things to keep in mind:\n\nSkipping Component Resolution\n​\n\nBy default, Vue will attempt to resolve a non-native HTML tag as a registered Vue component before falling back to rendering it as a custom element. This will cause Vue to emit a \"failed to resolve component\" warning during development. To let Vue know that certain elements should be treated as custom elements and skip component resolution, we can specify the compilerOptions.isCustomElement option.\n\nIf you are using Vue with a build setup, the option should be passed via build configs since it is a compile-time option.\n\nExample In-Browser Config\n​\njs\n// Only works if using in-browser compilation.\n// If using build tools, see config examples below.\napp.config.compilerOptions.isCustomElement = (tag) => tag.includes('-')\nExample Vite Config\n​\njs\n// vite.config.js\nimport vue from '@vitejs/plugin-vue'\n\nexport default {\n  plugins: [\n    vue({\n      template: {\n        compilerOptions: {\n          // treat all tags with a dash as custom elements\n          isCustomElement: (tag) => tag.includes('-')\n        }\n      }\n    })\n  ]\n}\nExample Vue CLI Config\n​\njs\n// vue.config.js\nmodule.exports = {\n  chainWebpack: config => {\n    config.module\n      .rule('vue')\n      .use('vue-loader')\n      .tap(options => ({\n        ...options,\n        compilerOptions: {\n          // treat any tag that starts with ion- as custom elements\n          isCustomElement: tag => tag.startsWith('ion-')\n        }\n      }))\n  }\n}\nPassing DOM Properties\n​\n\nSince DOM attributes can only be strings, we need to pass complex data to custom elements as DOM properties. When setting props on a custom element, Vue 3 automatically checks DOM-property presence using the in operator and will prefer setting the value as a DOM property if the key is present. This means that, in most cases, you won't need to think about this if the custom element follows the recommended best practices.\n\nHowever, there could be rare cases where the data must be passed as a DOM property, but the custom element does not properly define/reflect the property (causing the in check to fail). In this case, you can force a v-bind binding to be set as a DOM property using the .prop modifier:\n\ntemplate\n<my-element :user.prop=\"{ name: 'jack' }\"></my-element>\n\n<!-- shorthand equivalent -->\n<my-element .user=\"{ name: 'jack' }\"></my-element>\nBuilding Custom Elements with Vue\n​\n\nThe primary benefit of custom elements is that they can be used with any framework, or even without a framework. This makes them ideal for distributing components where the end consumer may not be using the same frontend stack, or when you want to insulate the end application from the implementation details of the components it uses.\n\ndefineCustomElement\n​\n\nVue supports creating custom elements using exactly the same Vue component APIs via the defineCustomElement method. The method accepts the same argument as defineComponent, but instead returns a custom element constructor that extends HTMLElement:\n\ntemplate\n<my-vue-element></my-vue-element>\njs\nimport { defineCustomElement } from 'vue'\n\nconst MyVueElement = defineCustomElement({\n  // normal Vue component options here\n  props: {},\n  emits: {},\n  template: `...`,\n\n  // defineCustomElement only: CSS to be injected into shadow root\n  styles: [`/* inlined css */`]\n})\n\n// Register the custom element.\n// After registration, all `<my-vue-element>` tags\n// on the page will be upgraded.\ncustomElements.define('my-vue-element', MyVueElement)\n\n// You can also programmatically instantiate the element:\n// (can only be done after registration)\ndocument.body.appendChild(\n  new MyVueElement({\n    // initial props (optional)\n  })\n)\nLifecycle\n​\n\nA Vue custom element will mount an internal Vue component instance inside its shadow root when the element's connectedCallback is called for the first time.\n\nWhen the element's disconnectedCallback is invoked, Vue will check whether the element is detached from the document after a microtask tick.\n\nIf the element is still in the document, it's a move and the component instance will be preserved;\n\nIf the element is detached from the document, it's a removal and the component instance will be unmounted.\n\nProps\n​\n\nAll props declared using the props option will be defined on the custom element as properties. Vue will automatically handle the reflection between attributes / properties where appropriate.\n\nAttributes are always reflected to corresponding properties.\n\nProperties with primitive values (string, boolean or number) are reflected as attributes.\n\nVue also automatically casts props declared with Boolean or Number types into the desired type when they are set as attributes (which are always strings). For example, given the following props declaration:\n\njs\nprops: {\n  selected: Boolean,\n  index: Number\n}\n\nAnd the custom element usage:\n\ntemplate\n<my-element selected index=\"1\"></my-element>\n\nIn the component, selected will be cast to true (boolean) and index will be cast to 1 (number).\n\nEvents\n​\n\nEvents emitted via this.$emit or setup emit are dispatched as native CustomEvents on the custom element. Additional event arguments (payload) will be exposed as an array on the CustomEvent object as its detail property.\n\nSlots\n​\n\nInside the component, slots can be rendered using the <slot/> element as usual. However, when consuming the resulting element, it only accepts native slots syntax:\n\nScoped slots are not supported.\n\nWhen passing named slots, use the slot attribute instead of the v-slot directive:\n\ntemplate\n<my-element>\n  <div slot=\"named\">hello</div>\n</my-element>\nProvide / Inject\n​\n\nThe Provide / Inject API and its Composition API equivalent also work between Vue-defined custom elements. However, note that this works only between custom elements. i.e. a Vue-defined custom element won't be able to inject properties provided by a non-custom-element Vue component.\n\nSFC as Custom Element\n​\n\ndefineCustomElement also works with Vue Single-File Components (SFCs). However, with the default tooling setup, the <style> inside the SFCs will still be extracted and merged into a single CSS file during production build. When using an SFC as a custom element, it is often desirable to inject the <style> tags into the custom element's shadow root instead.\n\nThe official SFC toolings support importing SFCs in \"custom element mode\" (requires @vitejs/plugin-vue@^1.4.0 or vue-loader@^16.5.0). An SFC loaded in custom element mode inlines its <style> tags as strings of CSS and exposes them under the component's styles option. This will be picked up by defineCustomElement and injected into the element's shadow root when instantiated.\n\nTo opt-in to this mode, simply end your component file name with .ce.vue:\n\njs\nimport { defineCustomElement } from 'vue'\nimport Example from './Example.ce.vue'\n\nconsole.log(Example.styles) // [\"/* inlined css */\"]\n\n// convert into custom element constructor\nconst ExampleElement = defineCustomElement(Example)\n\n// register\ncustomElements.define('my-example', ExampleElement)\n\nIf you wish to customize what files should be imported in custom element mode (for example, treating all SFCs as custom elements), you can pass the customElement option to the respective build plugins:\n\n@vitejs/plugin-vue\nvue-loader\nTips for a Vue Custom Elements Library\n​\n\nWhen building custom elements with Vue, the elements will rely on Vue's runtime. There is a ~16kb baseline size cost depending on how many features are being used. This means it is not ideal to use Vue if you are shipping a single custom element - you may want to use vanilla JavaScript, petite-vue, or frameworks that specialize in small runtime size. However, the base size is more than justifiable if you are shipping a collection of custom elements with complex logic, as Vue will allow each component to be authored with much less code. The more elements you are shipping together, the better the trade-off.\n\nIf the custom elements will be used in an application that is also using Vue, you can choose to externalize Vue from the built bundle so that the elements will be using the same copy of Vue from the host application.\n\nIt is recommended to export the individual element constructors to give your users the flexibility to import them on-demand and register them with desired tag names. You can also export a convenience function to automatically register all elements. Here's an example entry point of a Vue custom element library:\n\njs\nimport { defineCustomElement } from 'vue'\nimport Foo from './MyFoo.ce.vue'\nimport Bar from './MyBar.ce.vue'\n\nconst MyFoo = defineCustomElement(Foo)\nconst MyBar = defineCustomElement(Bar)\n\n// export individual elements\nexport { MyFoo, MyBar }\n\nexport function register() {\n  customElements.define('my-foo', MyFoo)\n  customElements.define('my-bar', MyBar)\n}\n\nIf you have many components, you can also leverage build tool features such as Vite's glob import or webpack's require.context to load all components from a directory.\n\nWeb Components and TypeScript\n​\n\nIf you are developing an application or a library, you may want to type check your Vue components, including those that are defined as custom elements.\n\nCustom elements are registered globally using native APIs, so by default they won't have type inference when used in Vue templates. To provide type support for Vue components registered as custom elements, we can register global component typings using the the GlobalComponents interface in Vue templates and/or in JSX:\n\ntypescript\nimport { defineCustomElement } from 'vue'\n\n// vue SFC\nimport CounterSFC from './src/components/counter.ce.vue'\n\n// turn component into web components\nexport const Counter = defineCustomElement(CounterSFC)\n\n// register global typings\ndeclare module 'vue' {\n  export interface GlobalComponents {\n    'Counter': typeof Counter,\n  }\n}\nWeb Components vs. Vue Components\n​\n\nSome developers believe that framework-proprietary component models should be avoided, and that exclusively using Custom Elements makes an application \"future-proof\". Here we will try to explain why we believe that this is an overly simplistic take on the problem.\n\nThere is indeed a certain level of feature overlap between Custom Elements and Vue Components: they both allow us to define reusable components with data passing, event emitting, and lifecycle management. However, Web Components APIs are relatively low-level and bare-bones. To build an actual application, we need quite a few additional capabilities which the platform does not cover:\n\nA declarative and efficient templating system;\n\nA reactive state management system that facilitates cross-component logic extraction and reuse;\n\nA performant way to render the components on the server and hydrate them on the client (SSR), which is important for SEO and Web Vitals metrics such as LCP. Native custom elements SSR typically involves simulating the DOM in Node.js and then serializing the mutated DOM, while Vue SSR compiles into string concatenation whenever possible, which is much more efficient.\n\nVue's component model is designed with these needs in mind as a coherent system.\n\nWith a competent engineering team, you could probably build the equivalent on top of native Custom Elements - but this also means you are taking on the long-term maintenance burden of an in-house framework, while losing out on the ecosystem and community benefits of a mature framework like Vue.\n\nThere are also frameworks built using Custom Elements as the basis of their component model, but they all inevitably have to introduce their proprietary solutions to the problems listed above. Using these frameworks entails buying into their technical decisions on how to solve these problems - which, despite what may be advertised, doesn't automatically insulate you from potential future churns.\n\nThere are also some areas where we find custom elements to be limiting:\n\nEager slot evaluation hinders component composition. Vue's scoped slots are a powerful mechanism for component composition, which can't be supported by custom elements due to native slots' eager nature. Eager slots also mean the receiving component cannot control when or whether to render a piece of slot content.\n\nShipping custom elements with shadow DOM scoped CSS today requires embedding the CSS inside JavaScript so that they can be injected into shadow roots at runtime. They also result in duplicated styles in markup in SSR scenarios. There are platform features being worked on in this area - but as of now they are not yet universally supported, and there are still production performance / SSR concerns to be addressed. In the meanwhile, Vue SFCs provide CSS scoping mechanisms that support extracting the styles into plain CSS files.\n\nVue will always stay up to date with the latest standards in the web platform, and we will happily leverage whatever the platform provides if it makes our job easier. However, our goal is to provide solutions that work well and work today. That means we have to incorporate new platform features with a critical mindset - and that involves filling the gaps where the standards fall short while that is still the case.\n\nEdit this page on GitHub\n\n Previous\nRender Functions & JSX\nNext \nAnimation Techniques\nVue and Web Components has loaded"
  },
  {
    "title": "Render Functions & JSX | Vue.js",
    "url": "https://vuejs.org/guide/extras/render-function",
    "html": "Skip to content\nGet 60% off a year of Vue Mastery courses\nGET DISCOUNT\nVue.js\nSearch\nCtrl\nK\nMain Navigation\nDocs\nAPI\nPlayground\nEcosystem\nAbout\nSponsor\nPartners\ngithub\ntwitter\ndiscord\nAPI Preference\nOptions\nComposition\n?\n\nAPI style now defaults to Composition API.\n\nSome pages contain different content based on the API style chosen. Use this switch to toggle between APIs styles.\n\nLearn moreGot it\n\nSidebar Navigation\nGetting Started\n\nIntroduction\n\nQuick Start\n\nEssentials\n\nCreating an Application\n\nTemplate Syntax\n\nReactivity Fundamentals\n\nComputed Properties\n\nClass and Style Bindings\n\nConditional Rendering\n\nList Rendering\n\nEvent Handling\n\nForm Input Bindings\n\nLifecycle Hooks\n\nWatchers\n\nTemplate Refs\n\nComponents Basics\n\nComponents In-Depth\n\nRegistration\n\nProps\n\nEvents\n\nComponent v-model\n\nFallthrough Attributes\n\nSlots\n\nProvide / inject\n\nAsync Components\n\nReusability\n\nComposables\n\nCustom Directives\n\nPlugins\n\nBuilt-in Components\n\nTransition\n\nTransitionGroup\n\nKeepAlive\n\nTeleport\n\nSuspense\n\nScaling Up\n\nSingle-File Components\n\nTooling\n\nRouting\n\nState Management\n\nTesting\n\nServer-Side Rendering (SSR)\n\nBest Practices\n\nProduction Deployment\n\nPerformance\n\nAccessibility\n\nSecurity\n\nTypeScript\n\nOverview\n\nTS with Composition API\n\nTS with Options API\n\nExtra Topics\n\nWays of Using Vue\n\nComposition API FAQ\n\nReactivity in Depth\n\nRendering Mechanism\n\nRender Functions & JSX\n\nVue and Web Components\n\nAnimation Techniques\n\nON THIS PAGE\nTable of Contents for current page\nBasic Usage\nCreating Vnodes\nDeclaring Render Functions\nVnodes Must Be Unique\nJSX / TSX\nJSX Type Inference\nRender Function Recipes\nv-if\nv-for\nv-on\nComponents\nRendering Slots\nPassing Slots\nScoped Slots\nBuilt-in Components\nv-model\nCustom Directives\nTemplate Refs\nFunctional Components\nTyping Functional Components\nSPONSORS\nBecome a Sponsor\nYour Baremetal Lifeline: Online Guides if you get stuck. Let's Dive In, Shall We?\nADS VIA CARBON\nRender Functions & JSX\n​\n\nVue recommends using templates to build applications in the vast majority of cases. However, there are situations where we need the full programmatic power of JavaScript. That's where we can use the render function.\n\nIf you are new to the concept of virtual DOM and render functions, make sure to read the Rendering Mechanism chapter first.\n\nBasic Usage\n​\nCreating Vnodes\n​\n\nVue provides an h() function for creating vnodes:\n\njs\nimport { h } from 'vue'\n\nconst vnode = h(\n  'div', // type\n  { id: 'foo', class: 'bar' }, // props\n  [\n    /* children */\n  ]\n)\n\nh() is short for hyperscript - which means \"JavaScript that produces HTML (hypertext markup language)\". This name is inherited from conventions shared by many virtual DOM implementations. A more descriptive name could be createVnode(), but a shorter name helps when you have to call this function many times in a render function.\n\nThe h() function is designed to be very flexible:\n\njs\n// all arguments except the type are optional\nh('div')\nh('div', { id: 'foo' })\n\n// both attributes and properties can be used in props\n// Vue automatically picks the right way to assign it\nh('div', { class: 'bar', innerHTML: 'hello' })\n\n// props modifiers such as `.prop` and `.attr` can be added\n// with `.` and `^` prefixes respectively\nh('div', { '.name': 'some-name', '^width': '100' })\n\n// class and style have the same object / array\n// value support that they have in templates\nh('div', { class: [foo, { bar }], style: { color: 'red' } })\n\n// event listeners should be passed as onXxx\nh('div', { onClick: () => {} })\n\n// children can be a string\nh('div', { id: 'foo' }, 'hello')\n\n// props can be omitted when there are no props\nh('div', 'hello')\nh('div', [h('span', 'hello')])\n\n// children array can contain mixed vnodes and strings\nh('div', ['hello', h('span', 'hello')])\n\nThe resulting vnode has the following shape:\n\njs\nconst vnode = h('div', { id: 'foo' }, [])\n\nvnode.type // 'div'\nvnode.props // { id: 'foo' }\nvnode.children // []\nvnode.key // null\n\nNote\n\nThe full VNode interface contains many other internal properties, but it is strongly recommended to avoid relying on any properties other than the ones listed here. This avoids unintended breakage in case the internal properties are changed.\n\nDeclaring Render Functions\n​\n\nWhen using templates with Composition API, the return value of the setup() hook is used to expose data to the template. When using render functions, however, we can directly return the render function instead:\n\njs\nimport { ref, h } from 'vue'\n\nexport default {\n  props: {\n    /* ... */\n  },\n  setup(props) {\n    const count = ref(1)\n\n    // return the render function\n    return () => h('div', props.msg + count.value)\n  }\n}\n\nThe render function is declared inside setup() so it naturally has access to the props and any reactive state declared in the same scope.\n\nIn addition to returning a single vnode, you can also return strings or arrays:\n\njs\nexport default {\n  setup() {\n    return () => 'hello world!'\n  }\n}\njs\nimport { h } from 'vue'\n\nexport default {\n  setup() {\n    // use an array to return multiple root nodes\n    return () => [\n      h('div'),\n      h('div'),\n      h('div')\n    ]\n  }\n}\n\nTIP\n\nMake sure to return a function instead of directly returning values! The setup() function is called only once per component, while the returned render function will be called multiple times.\n\nIf a render function component doesn't need any instance state, they can also be declared directly as a function for brevity:\n\njs\nfunction Hello() {\n  return 'hello world!'\n}\n\nThat's right, this is a valid Vue component! See Functional Components for more details on this syntax.\n\nVnodes Must Be Unique\n​\n\nAll vnodes in the component tree must be unique. That means the following render function is invalid:\n\njs\nfunction render() {\n  const p = h('p', 'hi')\n  return h('div', [\n    // Yikes - duplicate vnodes!\n    p,\n    p\n  ])\n}\n\nIf you really want to duplicate the same element/component many times, you can do so with a factory function. For example, the following render function is a perfectly valid way of rendering 20 identical paragraphs:\n\njs\nfunction render() {\n  return h(\n    'div',\n    Array.from({ length: 20 }).map(() => {\n      return h('p', 'hi')\n    })\n  )\n}\nJSX / TSX\n​\n\nJSX is an XML-like extension to JavaScript that allows us to write code like this:\n\njsx\nconst vnode = <div>hello</div>\n\nInside JSX expressions, use curly braces to embed dynamic values:\n\njsx\nconst vnode = <div id={dynamicId}>hello, {userName}</div>\n\ncreate-vue and Vue CLI both have options for scaffolding projects with pre-configured JSX support. If you are configuring JSX manually, please refer to the documentation of @vue/babel-plugin-jsx for details.\n\nAlthough first introduced by React, JSX actually has no defined runtime semantics and can be compiled into various different outputs. If you have worked with JSX before, do note that Vue JSX transform is different from React's JSX transform, so you can't use React's JSX transform in Vue applications. Some notable differences from React JSX include:\n\nYou can use HTML attributes such as class and for as props - no need to use className or htmlFor.\nPassing children to components (i.e. slots) works differently.\n\nVue's type definition also provides type inference for TSX usage. When using TSX, make sure to specify \"jsx\": \"preserve\" in tsconfig.json so that TypeScript leaves the JSX syntax intact for Vue JSX transform to process.\n\nJSX Type Inference\n​\n\nSimilar to the transform, Vue's JSX also needs different type definitions.\n\nStarting in Vue 3.4, Vue no longer implicitly registers the global JSX namespace. To instruct TypeScript to use Vue's JSX type definitions, make sure to include the following in your tsconfig.json:\n\njson\n{\n  \"compilerOptions\": {\n    \"jsx\": \"preserve\",\n    \"jsxImportSource\": \"vue\"\n    // ...\n  }\n}\n\nYou can also opt-in per file by adding a /* @jsxImportSource vue */ comment at the top of the file.\n\nIf there is code that depends on the presence of the global JSX namespace, you can retain the exact pre-3.4 global behavior by explicitly importing or referencing vue/jsx in your project, which registers the global JSX namespace.\n\nRender Function Recipes\n​\n\nBelow we will provide some common recipes for implementing template features as their equivalent render functions / JSX.\n\nv-if\n​\n\nTemplate:\n\ntemplate\n<div>\n  <div v-if=\"ok\">yes</div>\n  <span v-else>no</span>\n</div>\n\nEquivalent render function / JSX:\n\njs\nh('div', [ok.value ? h('div', 'yes') : h('span', 'no')])\njsx\n<div>{ok.value ? <div>yes</div> : <span>no</span>}</div>\nv-for\n​\n\nTemplate:\n\ntemplate\n<ul>\n  <li v-for=\"{ id, text } in items\" :key=\"id\">\n    {{ text }}\n  </li>\n</ul>\n\nEquivalent render function / JSX:\n\njs\nh(\n  'ul',\n  // assuming `items` is a ref with array value\n  items.value.map(({ id, text }) => {\n    return h('li', { key: id }, text)\n  })\n)\njsx\n<ul>\n  {items.value.map(({ id, text }) => {\n    return <li key={id}>{text}</li>\n  })}\n</ul>\nv-on\n​\n\nProps with names that start with on followed by an uppercase letter are treated as event listeners. For example, onClick is the equivalent of @click in templates.\n\njs\nh(\n  'button',\n  {\n    onClick(event) {\n      /* ... */\n    }\n  },\n  'Click Me'\n)\njsx\n<button\n  onClick={(event) => {\n    /* ... */\n  }}\n>\n  Click Me\n</button>\nEvent Modifiers\n​\n\nFor the .passive, .capture, and .once event modifiers, they can be concatenated after the event name using camelCase.\n\nFor example:\n\njs\nh('input', {\n  onClickCapture() {\n    /* listener in capture mode */\n  },\n  onKeyupOnce() {\n    /* triggers only once */\n  },\n  onMouseoverOnceCapture() {\n    /* once + capture */\n  }\n})\njsx\n<input\n  onClickCapture={() => {}}\n  onKeyupOnce={() => {}}\n  onMouseoverOnceCapture={() => {}}\n/>\n\nFor other event and key modifiers, the withModifiers helper can be used:\n\njs\nimport { withModifiers } from 'vue'\n\nh('div', {\n  onClick: withModifiers(() => {}, ['self'])\n})\njsx\n<div onClick={withModifiers(() => {}, ['self'])} />\nComponents\n​\n\nTo create a vnode for a component, the first argument passed to h() should be the component definition. This means when using render functions, it is unnecessary to register components - you can just use the imported components directly:\n\njs\nimport Foo from './Foo.vue'\nimport Bar from './Bar.jsx'\n\nfunction render() {\n  return h('div', [h(Foo), h(Bar)])\n}\njsx\nfunction render() {\n  return (\n    <div>\n      <Foo />\n      <Bar />\n    </div>\n  )\n}\n\nAs we can see, h can work with components imported from any file format as long as it's a valid Vue component.\n\nDynamic components are straightforward with render functions:\n\njs\nimport Foo from './Foo.vue'\nimport Bar from './Bar.jsx'\n\nfunction render() {\n  return ok.value ? h(Foo) : h(Bar)\n}\njsx\nfunction render() {\n  return ok.value ? <Foo /> : <Bar />\n}\n\nIf a component is registered by name and cannot be imported directly (for example, globally registered by a library), it can be programmatically resolved by using the resolveComponent() helper.\n\nRendering Slots\n​\n\nIn render functions, slots can be accessed from the setup() context. Each slot on the slots object is a function that returns an array of vnodes:\n\njs\nexport default {\n  props: ['message'],\n  setup(props, { slots }) {\n    return () => [\n      // default slot:\n      // <div><slot /></div>\n      h('div', slots.default()),\n\n      // named slot:\n      // <div><slot name=\"footer\" :text=\"message\" /></div>\n      h(\n        'div',\n        slots.footer({\n          text: props.message\n        })\n      )\n    ]\n  }\n}\n\nJSX equivalent:\n\njsx\n// default\n<div>{slots.default()}</div>\n\n// named\n<div>{slots.footer({ text: props.message })}</div>\nPassing Slots\n​\n\nPassing children to components works a bit differently from passing children to elements. Instead of an array, we need to pass either a slot function, or an object of slot functions. Slot functions can return anything a normal render function can return - which will always be normalized to arrays of vnodes when accessed in the child component.\n\njs\n// single default slot\nh(MyComponent, () => 'hello')\n\n// named slots\n// notice the `null` is required to avoid\n// the slots object being treated as props\nh(MyComponent, null, {\n  default: () => 'default slot',\n  foo: () => h('div', 'foo'),\n  bar: () => [h('span', 'one'), h('span', 'two')]\n})\n\nJSX equivalent:\n\njsx\n// default\n<MyComponent>{() => 'hello'}</MyComponent>\n\n// named\n<MyComponent>{{\n  default: () => 'default slot',\n  foo: () => <div>foo</div>,\n  bar: () => [<span>one</span>, <span>two</span>]\n}}</MyComponent>\n\nPassing slots as functions allows them to be invoked lazily by the child component. This leads to the slot's dependencies being tracked by the child instead of the parent, which results in more accurate and efficient updates.\n\nScoped Slots\n​\n\nTo render a scoped slot in the parent component, a slot is passed to the child. Notice how the slot now has a parameter text. The slot will be called in the child component and the data from the child component will be passed up to the parent component.\n\njs\n// parent component\nexport default {\n  setup() {\n    return () => h(MyComp, null, {\n      default: ({ text }) => h('p', text)\n    })\n  }\n}\n\nRemember to pass null so the slots will not be treated as props.\n\njs\n// child component\nexport default {\n  setup(props, { slots }) {\n    const text = ref('hi')\n    return () => h('div', null, slots.default({ text: text.value }))\n  }\n}\n\nJSX equivalent:\n\njsx\n<MyComponent>{{\n  default: ({ text }) => <p>{ text }</p>  \n}}</MyComponent>\nBuilt-in Components\n​\n\nBuilt-in components such as <KeepAlive>, <Transition>, <TransitionGroup>, <Teleport> and <Suspense> must be imported for use in render functions:\n\njs\nimport { h, KeepAlive, Teleport, Transition, TransitionGroup } from 'vue'\n\nexport default {\n  setup () {\n    return () => h(Transition, { mode: 'out-in' }, /* ... */)\n  }\n}\nv-model\n​\n\nThe v-model directive is expanded to modelValue and onUpdate:modelValue props during template compilation—we will have to provide these props ourselves:\n\njs\nexport default {\n  props: ['modelValue'],\n  emits: ['update:modelValue'],\n  setup(props, { emit }) {\n    return () =>\n      h(SomeComponent, {\n        modelValue: props.modelValue,\n        'onUpdate:modelValue': (value) => emit('update:modelValue', value)\n      })\n  }\n}\nCustom Directives\n​\n\nCustom directives can be applied to a vnode using withDirectives:\n\njs\nimport { h, withDirectives } from 'vue'\n\n// a custom directive\nconst pin = {\n  mounted() { /* ... */ },\n  updated() { /* ... */ }\n}\n\n// <div v-pin:top.animate=\"200\"></div>\nconst vnode = withDirectives(h('div'), [\n  [pin, 200, 'top', { animate: true }]\n])\n\nIf the directive is registered by name and cannot be imported directly, it can be resolved using the resolveDirective helper.\n\nTemplate Refs\n​\n\nWith the Composition API, template refs are created by passing the ref() itself as a prop to the vnode:\n\njs\nimport { h, ref } from 'vue'\n\nexport default {\n  setup() {\n    const divEl = ref()\n\n    // <div ref=\"divEl\">\n    return () => h('div', { ref: divEl })\n  }\n}\nFunctional Components\n​\n\nFunctional components are an alternative form of component that don't have any state of their own. They act like pure functions: props in, vnodes out. They are rendered without creating a component instance (i.e. no this), and without the usual component lifecycle hooks.\n\nTo create a functional component we use a plain function, rather than an options object. The function is effectively the render function for the component.\n\nThe signature of a functional component is the same as the setup() hook:\n\njs\nfunction MyComponent(props, { slots, emit, attrs }) {\n  // ...\n}\n\nMost of the usual configuration options for components are not available for functional components. However, it is possible to define props and emits by adding them as properties:\n\njs\nMyComponent.props = ['value']\nMyComponent.emits = ['click']\n\nIf the props option is not specified, then the props object passed to the function will contain all attributes, the same as attrs. The prop names will not be normalized to camelCase unless the props option is specified.\n\nFor functional components with explicit props, attribute fallthrough works much the same as with normal components. However, for functional components that don't explicitly specify their props, only the class, style, and onXxx event listeners will be inherited from the attrs by default. In either case, inheritAttrs can be set to false to disable attribute inheritance:\n\njs\nMyComponent.inheritAttrs = false\n\nFunctional components can be registered and consumed just like normal components. If you pass a function as the first argument to h(), it will be treated as a functional component.\n\nTyping Functional Components\n​\n\nFunctional Components can be typed based on whether they are named or anonymous. Vue - Official extension also supports type checking properly typed functional components when consuming them in SFC templates.\n\nNamed Functional Component\n\ntsx\nimport type { SetupContext } from 'vue'\ntype FComponentProps = {\n  message: string\n}\n\ntype Events = {\n  sendMessage(message: string): void\n}\n\nfunction FComponent(\n  props: FComponentProps,\n  context: SetupContext<Events>\n) {\n  return (\n    <button onClick={() => context.emit('sendMessage', props.message)}>\n        {props.message} {' '}\n    </button>\n  )\n}\n\nFComponent.props = {\n  message: {\n    type: String,\n    required: true\n  }\n}\n\nFComponent.emits = {\n  sendMessage: (value: unknown) => typeof value === 'string'\n}\n\nAnonymous Functional Component\n\ntsx\nimport type { FunctionalComponent } from 'vue'\n\ntype FComponentProps = {\n  message: string\n}\n\ntype Events = {\n  sendMessage(message: string): void\n}\n\nconst FComponent: FunctionalComponent<FComponentProps, Events> = (\n  props,\n  context\n) => {\n  return (\n    <button onClick={() => context.emit('sendMessage', props.message)}>\n        {props.message} {' '}\n    </button>\n  )\n}\n\nFComponent.props = {\n  message: {\n    type: String,\n    required: true\n  }\n}\n\nFComponent.emits = {\n  sendMessage: (value) => typeof value === 'string'\n}\n\nEdit this page on GitHub\n\n Previous\nRendering Mechanism\nNext \nVue and Web Components\nRender Functions & JSX has loaded"
  },
  {
    "title": "Rendering Mechanism | Vue.js",
    "url": "https://vuejs.org/guide/extras/rendering-mechanism",
    "html": "Skip to content\nGet 60% off a year of Vue Mastery courses\nGET DISCOUNT\nVue.js\nSearch\nCtrl\nK\nMain Navigation\nDocs\nAPI\nPlayground\nEcosystem\nAbout\nSponsor\nPartners\ngithub\ntwitter\ndiscord\nAPI Preference\nOptions\nComposition\n?\n\nAPI style now defaults to Composition API.\n\nSome pages contain different content based on the API style chosen. Use this switch to toggle between APIs styles.\n\nLearn moreGot it\n\nSidebar Navigation\nGetting Started\n\nIntroduction\n\nQuick Start\n\nEssentials\n\nCreating an Application\n\nTemplate Syntax\n\nReactivity Fundamentals\n\nComputed Properties\n\nClass and Style Bindings\n\nConditional Rendering\n\nList Rendering\n\nEvent Handling\n\nForm Input Bindings\n\nLifecycle Hooks\n\nWatchers\n\nTemplate Refs\n\nComponents Basics\n\nComponents In-Depth\n\nRegistration\n\nProps\n\nEvents\n\nComponent v-model\n\nFallthrough Attributes\n\nSlots\n\nProvide / inject\n\nAsync Components\n\nReusability\n\nComposables\n\nCustom Directives\n\nPlugins\n\nBuilt-in Components\n\nTransition\n\nTransitionGroup\n\nKeepAlive\n\nTeleport\n\nSuspense\n\nScaling Up\n\nSingle-File Components\n\nTooling\n\nRouting\n\nState Management\n\nTesting\n\nServer-Side Rendering (SSR)\n\nBest Practices\n\nProduction Deployment\n\nPerformance\n\nAccessibility\n\nSecurity\n\nTypeScript\n\nOverview\n\nTS with Composition API\n\nTS with Options API\n\nExtra Topics\n\nWays of Using Vue\n\nComposition API FAQ\n\nReactivity in Depth\n\nRendering Mechanism\n\nRender Functions & JSX\n\nVue and Web Components\n\nAnimation Techniques\n\nON THIS PAGE\nTable of Contents for current page\nVirtual DOM\nRender Pipeline\nTemplates vs. Render Functions\nCompiler-Informed Virtual DOM\nStatic Hoisting\nPatch Flags\nTree Flattening\nImpact on SSR Hydration\nSPONSORS\nBecome a Sponsor\nSquarespace has all the tools you need to keep visitors coming back.\nADS VIA CARBON\nRendering Mechanism\n​\n\nHow does Vue take a template and turn it into actual DOM nodes? How does Vue update those DOM nodes efficiently? We will attempt to shed some light on these questions here by diving into Vue's internal rendering mechanism.\n\nVirtual DOM\n​\n\nYou have probably heard about the term \"virtual DOM\", which Vue's rendering system is based upon.\n\nThe virtual DOM (VDOM) is a programming concept where an ideal, or “virtual”, representation of a UI is kept in memory and synced with the “real” DOM. The concept was pioneered by React, and has been adopted in many other frameworks with different implementations, including Vue.\n\nVirtual DOM is more of a pattern than a specific technology, so there is no one canonical implementation. We can illustrate the idea using a simple example:\n\njs\nconst vnode = {\n  type: 'div',\n  props: {\n    id: 'hello'\n  },\n  children: [\n    /* more vnodes */\n  ]\n}\n\nHere, vnode is a plain JavaScript object (a \"virtual node\") representing a <div> element. It contains all the information that we need to create the actual element. It also contains more children vnodes, which makes it the root of a virtual DOM tree.\n\nA runtime renderer can walk a virtual DOM tree and construct a real DOM tree from it. This process is called mount.\n\nIf we have two copies of virtual DOM trees, the renderer can also walk and compare the two trees, figuring out the differences, and apply those changes to the actual DOM. This process is called patch, also known as \"diffing\" or \"reconciliation\".\n\nThe main benefit of virtual DOM is that it gives the developer the ability to programmatically create, inspect and compose desired UI structures in a declarative way, while leaving the direct DOM manipulation to the renderer.\n\nRender Pipeline\n​\n\nAt the high level, this is what happens when a Vue component is mounted:\n\nCompile: Vue templates are compiled into render functions: functions that return virtual DOM trees. This step can be done either ahead-of-time via a build step, or on-the-fly by using the runtime compiler.\n\nMount: The runtime renderer invokes the render functions, walks the returned virtual DOM tree, and creates actual DOM nodes based on it. This step is performed as a reactive effect, so it keeps track of all reactive dependencies that were used.\n\nPatch: When a dependency used during mount changes, the effect re-runs. This time, a new, updated Virtual DOM tree is created. The runtime renderer walks the new tree, compares it with the old one, and applies necessary updates to the actual DOM.\n\nTemplates vs. Render Functions\n​\n\nVue templates are compiled into virtual DOM render functions. Vue also provides APIs that allow us to skip the template compilation step and directly author render functions. Render functions are more flexible than templates when dealing with highly dynamic logic, because you can work with vnodes using the full power of JavaScript.\n\nSo why does Vue recommend templates by default? There are a number of reasons:\n\nTemplates are closer to actual HTML. This makes it easier to reuse existing HTML snippets, apply accessibility best practices, style with CSS, and for designers to understand and modify.\n\nTemplates are easier to statically analyze due to their more deterministic syntax. This allows Vue's template compiler to apply many compile-time optimizations to improve the performance of the virtual DOM (which we will discuss below).\n\nIn practice, templates are sufficient for most use cases in applications. Render functions are typically only used in reusable components that need to deal with highly dynamic rendering logic. Render function usage is discussed in more detail in Render Functions & JSX.\n\nCompiler-Informed Virtual DOM\n​\n\nThe virtual DOM implementation in React and most other virtual-DOM implementations are purely runtime: the reconciliation algorithm cannot make any assumptions about the incoming virtual DOM tree, so it has to fully traverse the tree and diff the props of every vnode in order to ensure correctness. In addition, even if a part of the tree never changes, new vnodes are always created for them on each re-render, resulting in unnecessary memory pressure. This is one of the most criticized aspect of virtual DOM: the somewhat brute-force reconciliation process sacrifices efficiency in return for declarativeness and correctness.\n\nBut it doesn't have to be that way. In Vue, the framework controls both the compiler and the runtime. This allows us to implement many compile-time optimizations that only a tightly-coupled renderer can take advantage of. The compiler can statically analyze the template and leave hints in the generated code so that the runtime can take shortcuts whenever possible. At the same time, we still preserve the capability for the user to drop down to the render function layer for more direct control in edge cases. We call this hybrid approach Compiler-Informed Virtual DOM.\n\nBelow, we will discuss a few major optimizations done by the Vue template compiler to improve the virtual DOM's runtime performance.\n\nStatic Hoisting\n​\n\nQuite often there will be parts in a template that do not contain any dynamic bindings:\n\ntemplate\n<div>\n  <div>foo</div> <!-- hoisted -->\n  <div>bar</div> <!-- hoisted -->\n  <div>{{ dynamic }}</div>\n</div>\n\nInspect in Template Explorer\n\nThe foo and bar divs are static - re-creating vnodes and diffing them on each re-render is unnecessary. The Vue compiler automatically hoists their vnode creation calls out of the render function, and reuses the same vnodes on every render. The renderer is also able to completely skip diffing them when it notices the old vnode and the new vnode are the same one.\n\nIn addition, when there are enough consecutive static elements, they will be condensed into a single \"static vnode\" that contains the plain HTML string for all these nodes (Example). These static vnodes are mounted by directly setting innerHTML. They also cache their corresponding DOM nodes on initial mount - if the same piece of content is reused elsewhere in the app, new DOM nodes are created using native cloneNode(), which is extremely efficient.\n\nPatch Flags\n​\n\nFor a single element with dynamic bindings, we can also infer a lot of information from it at compile time:\n\ntemplate\n<!-- class binding only -->\n<div :class=\"{ active }\"></div>\n\n<!-- id and value bindings only -->\n<input :id=\"id\" :value=\"value\">\n\n<!-- text children only -->\n<div>{{ dynamic }}</div>\n\nInspect in Template Explorer\n\nWhen generating the render function code for these elements, Vue encodes the type of update each of them needs directly in the vnode creation call:\n\njs\ncreateElementVNode(\"div\", {\n  class: _normalizeClass({ active: _ctx.active })\n}, null, 2 /* CLASS */)\n\nThe last argument, 2, is a patch flag. An element can have multiple patch flags, which will be merged into a single number. The runtime renderer can then check against the flags using bitwise operations to determine whether it needs to do certain work:\n\njs\nif (vnode.patchFlag & PatchFlags.CLASS /* 2 */) {\n  // update the element's class\n}\n\nBitwise checks are extremely fast. With the patch flags, Vue is able to do the least amount of work necessary when updating elements with dynamic bindings.\n\nVue also encodes the type of children a vnode has. For example, a template that has multiple root nodes is represented as a fragment. In most cases, we know for sure that the order of these root nodes will never change, so this information can also be provided to the runtime as a patch flag:\n\njs\nexport function render() {\n  return (_openBlock(), _createElementBlock(_Fragment, null, [\n    /* children */\n  ], 64 /* STABLE_FRAGMENT */))\n}\n\nThe runtime can thus completely skip child-order reconciliation for the root fragment.\n\nTree Flattening\n​\n\nTaking another look at the generated code from the previous example, you'll notice the root of the returned virtual DOM tree is created using a special createElementBlock() call:\n\njs\nexport function render() {\n  return (_openBlock(), _createElementBlock(_Fragment, null, [\n    /* children */\n  ], 64 /* STABLE_FRAGMENT */))\n}\n\nConceptually, a \"block\" is a part of the template that has stable inner structure. In this case, the entire template has a single block because it does not contain any structural directives like v-if and v-for.\n\nEach block tracks any descendant nodes (not just direct children) that have patch flags. For example:\n\ntemplate\n<div> <!-- root block -->\n  <div>...</div>         <!-- not tracked -->\n  <div :id=\"id\"></div>   <!-- tracked -->\n  <div>                  <!-- not tracked -->\n    <div>{{ bar }}</div> <!-- tracked -->\n  </div>\n</div>\n\nThe result is a flattened array that contains only the dynamic descendant nodes:\n\ndiv (block root)\n- div with :id binding\n- div with {{ bar }} binding\n\nWhen this component needs to re-render, it only needs to traverse the flattened tree instead of the full tree. This is called Tree Flattening, and it greatly reduces the number of nodes that need to be traversed during virtual DOM reconciliation. Any static parts of the template are effectively skipped.\n\nv-if and v-for directives will create new block nodes:\n\ntemplate\n<div> <!-- root block -->\n  <div>\n    <div v-if> <!-- if block -->\n      ...\n    <div>\n  </div>\n</div>\n\nA child block is tracked inside the parent block's array of dynamic descendants. This retains a stable structure for the parent block.\n\nImpact on SSR Hydration\n​\n\nBoth patch flags and tree flattening also greatly improve Vue's SSR Hydration performance:\n\nSingle element hydration can take fast paths based on the corresponding vnode's patch flag.\n\nOnly block nodes and their dynamic descendants need to be traversed during hydration, effectively achieving partial hydration at the template level.\n\nEdit this page on GitHub\n\n Previous\nReactivity in Depth\nNext \nRender Functions & JSX\nRendering Mechanism has loaded"
  },
  {
    "title": "Reactivity in Depth | Vue.js",
    "url": "https://vuejs.org/guide/extras/reactivity-in-depth",
    "html": "Skip to content\nGet 60% off a year of Vue Mastery courses\nGET DISCOUNT\nVue.js\nSearch\nCtrl\nK\nMain Navigation\nDocs\nAPI\nPlayground\nEcosystem\nAbout\nSponsor\nPartners\ngithub\ntwitter\ndiscord\nAPI Preference\nOptions\nComposition\n?\n\nAPI style now defaults to Composition API.\n\nSome pages contain different content based on the API style chosen. Use this switch to toggle between APIs styles.\n\nLearn moreGot it\n\nSidebar Navigation\nGetting Started\n\nIntroduction\n\nQuick Start\n\nEssentials\n\nCreating an Application\n\nTemplate Syntax\n\nReactivity Fundamentals\n\nComputed Properties\n\nClass and Style Bindings\n\nConditional Rendering\n\nList Rendering\n\nEvent Handling\n\nForm Input Bindings\n\nLifecycle Hooks\n\nWatchers\n\nTemplate Refs\n\nComponents Basics\n\nComponents In-Depth\n\nRegistration\n\nProps\n\nEvents\n\nComponent v-model\n\nFallthrough Attributes\n\nSlots\n\nProvide / inject\n\nAsync Components\n\nReusability\n\nComposables\n\nCustom Directives\n\nPlugins\n\nBuilt-in Components\n\nTransition\n\nTransitionGroup\n\nKeepAlive\n\nTeleport\n\nSuspense\n\nScaling Up\n\nSingle-File Components\n\nTooling\n\nRouting\n\nState Management\n\nTesting\n\nServer-Side Rendering (SSR)\n\nBest Practices\n\nProduction Deployment\n\nPerformance\n\nAccessibility\n\nSecurity\n\nTypeScript\n\nOverview\n\nTS with Composition API\n\nTS with Options API\n\nExtra Topics\n\nWays of Using Vue\n\nComposition API FAQ\n\nReactivity in Depth\n\nRendering Mechanism\n\nRender Functions & JSX\n\nVue and Web Components\n\nAnimation Techniques\n\nON THIS PAGE\nTable of Contents for current page\nWhat is Reactivity?\nHow Reactivity Works in Vue\nRuntime vs. Compile-time Reactivity\nReactivity Debugging\nComponent Debugging Hooks\nComputed Debugging\nWatcher Debugging\nIntegration with External State Systems\nImmutable Data\nState Machines\nRxJS\nConnection to Signals\nAPI Design Trade-Offs\nSPONSORS\nBecome a Sponsor\nPostgres upgrade best practices. Enhance performance, efficiency, and security. Claim your eBook.\nADS VIA CARBON\nReactivity in Depth\n​\n\nOne of Vue’s most distinctive features is the unobtrusive reactivity system. Component state consists of reactive JavaScript objects. When you modify them, the view updates. It makes state management simple and intuitive, but it’s also important to understand how it works to avoid some common gotchas. In this section, we are going to dig into some of the lower-level details of Vue’s reactivity system.\n\nWhat is Reactivity?\n​\n\nThis term comes up in programming quite a bit these days, but what do people mean when they say it? Reactivity is a programming paradigm that allows us to adjust to changes in a declarative manner. The canonical example that people usually show, because it’s a great one, is an Excel spreadsheet:\n\n\tA\tB\tC\n0\t\n1\n\t\n\t\n\n1\t\n2\n\t\n\t\n\n2\t\n3\n\t\n\t\n\nHere cell A2 is defined via a formula of = A0 + A1 (you can click on A2 to view or edit the formula), so the spreadsheet gives us 3. No surprises there. But if you update A0 or A1, you'll notice that A2 automagically updates too.\n\nJavaScript doesn’t usually work like this. If we were to write something comparable in JavaScript:\n\njs\nlet A0 = 1\nlet A1 = 2\nlet A2 = A0 + A1\n\nconsole.log(A2) // 3\n\nA0 = 2\nconsole.log(A2) // Still 3\n\nWhen we mutate A0, A2 does not change automatically.\n\nSo how would we do this in JavaScript? First, in order to re-run the code that updates A2, let's wrap it in a function:\n\njs\nlet A2\n\nfunction update() {\n  A2 = A0 + A1\n}\n\nThen, we need to define a few terms:\n\nThe update() function produces a side effect, or effect for short, because it modifies the state of the program.\n\nA0 and A1 are considered dependencies of the effect, as their values are used to perform the effect. The effect is said to be a subscriber to its dependencies.\n\nWhat we need is a magic function that can invoke update() (the effect) whenever A0 or A1 (the dependencies) change:\n\njs\nwhenDepsChange(update)\n\nThis whenDepsChange() function has the following tasks:\n\nTrack when a variable is read. E.g. when evaluating the expression A0 + A1, both A0 and A1 are read.\n\nIf a variable is read when there is a currently running effect, make that effect a subscriber to that variable. E.g. because A0 and A1 are read when update() is being executed, update() becomes a subscriber to both A0 and A1 after the first call.\n\nDetect when a variable is mutated. E.g. when A0 is assigned a new value, notify all its subscriber effects to re-run.\n\nHow Reactivity Works in Vue\n​\n\nWe can't really track the reading and writing of local variables like in the example. There's just no mechanism for doing that in vanilla JavaScript. What we can do though, is intercept the reading and writing of object properties.\n\nThere are two ways of intercepting property access in JavaScript: getter / setters and Proxies. Vue 2 used getter / setters exclusively due to browser support limitations. In Vue 3, Proxies are used for reactive objects and getter / setters are used for refs. Here's some pseudo-code that illustrates how they work:\n\njs\nfunction reactive(obj) {\n  return new Proxy(obj, {\n    get(target, key) {\n      track(target, key)\n      return target[key]\n    },\n    set(target, key, value) {\n      target[key] = value\n      trigger(target, key)\n    }\n  })\n}\n\nfunction ref(value) {\n  const refObject = {\n    get value() {\n      track(refObject, 'value')\n      return value\n    },\n    set value(newValue) {\n      value = newValue\n      trigger(refObject, 'value')\n    }\n  }\n  return refObject\n}\n\nTIP\n\nCode snippets here and below are meant to explain the core concepts in the simplest form possible, so many details are omitted, and edge cases ignored.\n\nThis explains a few limitations of reactive objects that we have discussed in the fundamentals section:\n\nWhen you assign or destructure a reactive object's property to a local variable, accessing or assigning to that variable is non-reactive because it no longer triggers the get / set proxy traps on the source object. Note this \"disconnect\" only affects the variable binding - if the variable points to a non-primitive value such as an object, mutating the object would still be reactive.\n\nThe returned proxy from reactive(), although behaving just like the original, has a different identity if we compare it to the original using the === operator.\n\nInside track(), we check whether there is a currently running effect. If there is one, we lookup the subscriber effects (stored in a Set) for the property being tracked, and add the effect to the Set:\n\njs\n// This will be set right before an effect is about\n// to be run. We'll deal with this later.\nlet activeEffect\n\nfunction track(target, key) {\n  if (activeEffect) {\n    const effects = getSubscribersForProperty(target, key)\n    effects.add(activeEffect)\n  }\n}\n\nEffect subscriptions are stored in a global WeakMap<target, Map<key, Set<effect>>> data structure. If no subscribing effects Set was found for a property (tracked for the first time), it will be created. This is what the getSubscribersForProperty() function does, in short. For simplicity, we will skip its details.\n\nInside trigger(), we again lookup the subscriber effects for the property. But this time we invoke them instead:\n\njs\nfunction trigger(target, key) {\n  const effects = getSubscribersForProperty(target, key)\n  effects.forEach((effect) => effect())\n}\n\nNow let's circle back to the whenDepsChange() function:\n\njs\nfunction whenDepsChange(update) {\n  const effect = () => {\n    activeEffect = effect\n    update()\n    activeEffect = null\n  }\n  effect()\n}\n\nIt wraps the raw update function in an effect that sets itself as the current active effect before running the actual update. This enables track() calls during the update to locate the current active effect.\n\nAt this point, we have created an effect that automatically tracks its dependencies, and re-runs whenever a dependency changes. We call this a Reactive Effect.\n\nVue provides an API that allows you to create reactive effects: watchEffect(). In fact, you may have noticed that it works pretty similarly to the magical whenDepsChange() in the example. We can now rework the original example using actual Vue APIs:\n\njs\nimport { ref, watchEffect } from 'vue'\n\nconst A0 = ref(0)\nconst A1 = ref(1)\nconst A2 = ref()\n\nwatchEffect(() => {\n  // tracks A0 and A1\n  A2.value = A0.value + A1.value\n})\n\n// triggers the effect\nA0.value = 2\n\nUsing a reactive effect to mutate a ref isn't the most interesting use case - in fact, using a computed property makes it more declarative:\n\njs\nimport { ref, computed } from 'vue'\n\nconst A0 = ref(0)\nconst A1 = ref(1)\nconst A2 = computed(() => A0.value + A1.value)\n\nA0.value = 2\n\nInternally, computed manages its invalidation and re-computation using a reactive effect.\n\nSo what's an example of a common and useful reactive effect? Well, updating the DOM! We can implement simple \"reactive rendering\" like this:\n\njs\nimport { ref, watchEffect } from 'vue'\n\nconst count = ref(0)\n\nwatchEffect(() => {\n  document.body.innerHTML = `Count is: ${count.value}`\n})\n\n// updates the DOM\ncount.value++\n\nIn fact, this is pretty close to how a Vue component keeps the state and the DOM in sync - each component instance creates a reactive effect to render and update the DOM. Of course, Vue components use much more efficient ways to update the DOM than innerHTML. This is discussed in Rendering Mechanism.\n\nRuntime vs. Compile-time Reactivity\n​\n\nVue's reactivity system is primarily runtime-based: the tracking and triggering are all performed while the code is running directly in the browser. The pros of runtime reactivity are that it can work without a build step, and there are fewer edge cases. On the other hand, this makes it constrained by the syntax limitations of JavaScript, leading to the need of value containers like Vue refs.\n\nSome frameworks, such as Svelte, choose to overcome such limitations by implementing reactivity during compilation. It analyzes and transforms the code in order to simulate reactivity. The compilation step allows the framework to alter the semantics of JavaScript itself - for example, implicitly injecting code that performs dependency analysis and effect triggering around access to locally defined variables. The downside is that such transforms require a build step, and altering JavaScript semantics is essentially creating a language that looks like JavaScript but compiles into something else.\n\nThe Vue team did explore this direction via an experimental feature called Reactivity Transform, but in the end we have decided that it would not be a good fit for the project due to the reasoning here.\n\nReactivity Debugging\n​\n\nIt's great that Vue's reactivity system automatically tracks dependencies, but in some cases we may want to figure out exactly what is being tracked, or what is causing a component to re-render.\n\nComponent Debugging Hooks\n​\n\nWe can debug what dependencies are used during a component's render and which dependency is triggering an update using the onRenderTracked and onRenderTriggered lifecycle hooks. Both hooks will receive a debugger event which contains information on the dependency in question. It is recommended to place a debugger statement in the callbacks to interactively inspect the dependency:\n\nvue\n<script setup>\nimport { onRenderTracked, onRenderTriggered } from 'vue'\n\nonRenderTracked((event) => {\n  debugger\n})\n\nonRenderTriggered((event) => {\n  debugger\n})\n</script>\n\nTIP\n\nComponent debug hooks only work in development mode.\n\nThe debug event objects have the following type:\n\nts\ntype DebuggerEvent = {\n  effect: ReactiveEffect\n  target: object\n  type:\n    | TrackOpTypes /* 'get' | 'has' | 'iterate' */\n    | TriggerOpTypes /* 'set' | 'add' | 'delete' | 'clear' */\n  key: any\n  newValue?: any\n  oldValue?: any\n  oldTarget?: Map<any, any> | Set<any>\n}\nComputed Debugging\n​\n\nWe can debug computed properties by passing computed() a second options object with onTrack and onTrigger callbacks:\n\nonTrack will be called when a reactive property or ref is tracked as a dependency.\nonTrigger will be called when the watcher callback is triggered by the mutation of a dependency.\n\nBoth callbacks will receive debugger events in the same format as component debug hooks:\n\njs\nconst plusOne = computed(() => count.value + 1, {\n  onTrack(e) {\n    // triggered when count.value is tracked as a dependency\n    debugger\n  },\n  onTrigger(e) {\n    // triggered when count.value is mutated\n    debugger\n  }\n})\n\n// access plusOne, should trigger onTrack\nconsole.log(plusOne.value)\n\n// mutate count.value, should trigger onTrigger\ncount.value++\n\nTIP\n\nonTrack and onTrigger computed options only work in development mode.\n\nWatcher Debugging\n​\n\nSimilar to computed(), watchers also support the onTrack and onTrigger options:\n\njs\nwatch(source, callback, {\n  onTrack(e) {\n    debugger\n  },\n  onTrigger(e) {\n    debugger\n  }\n})\n\nwatchEffect(callback, {\n  onTrack(e) {\n    debugger\n  },\n  onTrigger(e) {\n    debugger\n  }\n})\n\nTIP\n\nonTrack and onTrigger watcher options only work in development mode.\n\nIntegration with External State Systems\n​\n\nVue's reactivity system works by deeply converting plain JavaScript objects into reactive proxies. The deep conversion can be unnecessary or sometimes unwanted when integrating with external state management systems (e.g. if an external solution also uses Proxies).\n\nThe general idea of integrating Vue's reactivity system with an external state management solution is to hold the external state in a shallowRef. A shallow ref is only reactive when its .value property is accessed - the inner value is left intact. When the external state changes, replace the ref value to trigger updates.\n\nImmutable Data\n​\n\nIf you are implementing an undo / redo feature, you likely want to take a snapshot of the application's state on every user edit. However, Vue's mutable reactivity system isn't best suited for this if the state tree is large, because serializing the entire state object on every update can be expensive in terms of both CPU and memory costs.\n\nImmutable data structures solve this by never mutating the state objects - instead, it creates new objects that share the same, unchanged parts with old ones. There are different ways of using immutable data in JavaScript, but we recommend using Immer with Vue because it allows you to use immutable data while keeping the more ergonomic, mutable syntax.\n\nWe can integrate Immer with Vue via a simple composable:\n\njs\nimport { produce } from 'immer'\nimport { shallowRef } from 'vue'\n\nexport function useImmer(baseState) {\n  const state = shallowRef(baseState)\n  const update = (updater) => {\n    state.value = produce(state.value, updater)\n  }\n\n  return [state, update]\n}\n\nTry it in the Playground\n\nState Machines\n​\n\nState Machine is a model for describing all the possible states an application can be in, and all the possible ways it can transition from one state to another. While it may be overkill for simple components, it can help make complex state flows more robust and manageable.\n\nOne of the most popular state machine implementations in JavaScript is XState. Here's a composable that integrates with it:\n\njs\nimport { createMachine, interpret } from 'xstate'\nimport { shallowRef } from 'vue'\n\nexport function useMachine(options) {\n  const machine = createMachine(options)\n  const state = shallowRef(machine.initialState)\n  const service = interpret(machine)\n    .onTransition((newState) => (state.value = newState))\n    .start()\n  const send = (event) => service.send(event)\n\n  return [state, send]\n}\n\nTry it in the Playground\n\nRxJS\n​\n\nRxJS is a library for working with asynchronous event streams. The VueUse library provides the @vueuse/rxjs add-on for connecting RxJS streams with Vue's reactivity system.\n\nConnection to Signals\n​\n\nQuite a few other frameworks have introduced reactivity primitives similar to refs from Vue's Composition API, under the term \"signals\":\n\nSolid Signals\nAngular Signals\nPreact Signals\nQwik Signals\n\nFundamentally, signals are the same kind of reactivity primitive as Vue refs. It's a value container that provides dependency tracking on access, and side-effect triggering on mutation. This reactivity-primitive-based paradigm isn't a particularly new concept in the frontend world: it dates back to implementations like Knockout observables and Meteor Tracker from more than a decade ago. Vue Options API and the React state management library MobX are also based on the same principles, but hide the primitives behind object properties.\n\nAlthough not a necessary trait for something to qualify as signals, today the concept is often discussed alongside the rendering model where updates are performed through fine-grained subscriptions. Due to the use of Virtual DOM, Vue currently relies on compilers to achieve similar optimizations. However, we are also exploring a new Solid-inspired compilation strategy, called Vapor Mode, that does not rely on Virtual DOM and takes more advantage of Vue's built-in reactivity system.\n\nAPI Design Trade-Offs\n​\n\nThe design of Preact and Qwik's signals are very similar to Vue's shallowRef: all three provide a mutable interface via the .value property. We will focus the discussion on Solid and Angular signals.\n\nSolid Signals\n​\n\nSolid's createSignal() API design emphasizes read / write segregation. Signals are exposed as a read-only getter and a separate setter:\n\njs\nconst [count, setCount] = createSignal(0)\n\ncount() // access the value\nsetCount(1) // update the value\n\nNotice how the count signal can be passed down without the setter. This ensures that the state can never be mutated unless the setter is also explicitly exposed. Whether this safety guarantee justifies the more verbose syntax could be subject to the requirement of the project and personal taste - but in case you prefer this API style, you can easily replicate it in Vue:\n\njs\nimport { shallowRef, triggerRef } from 'vue'\n\nexport function createSignal(value, options) {\n  const r = shallowRef(value)\n  const get = () => r.value\n  const set = (v) => {\n    r.value = typeof v === 'function' ? v(r.value) : v\n    if (options?.equals === false) triggerRef(r)\n  }\n  return [get, set]\n}\n\nTry it in the Playground\n\nAngular Signals\n​\n\nAngular is undergoing some fundamental changes by foregoing dirty-checking and introducing its own implementation of a reactivity primitive. The Angular Signal API looks like this:\n\njs\nconst count = signal(0)\n\ncount() // access the value\ncount.set(1) // set new value\ncount.update((v) => v + 1) // update based on previous value\n\nAgain, we can easily replicate the API in Vue:\n\njs\nimport { shallowRef } from 'vue'\n\nexport function signal(initialValue) {\n  const r = shallowRef(initialValue)\n  const s = () => r.value\n  s.set = (value) => {\n    r.value = value\n  }\n  s.update = (updater) => {\n    r.value = updater(r.value)\n  }\n  return s\n}\n\nTry it in the Playground\n\nCompared to Vue refs, Solid and Angular's getter-based API style provide some interesting trade-offs when used in Vue components:\n\n() is slightly less verbose than .value, but updating the value is more verbose.\nThere is no ref-unwrapping: accessing values always require (). This makes value access consistent everywhere. This also means you can pass raw signals down as component props.\n\nWhether these API styles suit you is to some extent subjective. Our goal here is to demonstrate the underlying similarity and trade-offs between these different API designs. We also want to show that Vue is flexible: you are not really locked into the existing APIs. Should it be necessary, you can create your own reactivity primitive API to suit more specific needs.\n\nEdit this page on GitHub\n\n Previous\nComposition API FAQ\nNext \nRendering Mechanism\nReactivity in Depth has loaded"
  },
  {
    "title": "Composition API FAQ | Vue.js",
    "url": "https://vuejs.org/guide/extras/composition-api-faq",
    "html": "Skip to content\nGet 60% off a year of Vue Mastery courses\nGET DISCOUNT\nVue.js\nSearch\nCtrl\nK\nMain Navigation\nDocs\nAPI\nPlayground\nEcosystem\nAbout\nSponsor\nPartners\ngithub\ntwitter\ndiscord\nAPI Preference\nOptions\nComposition\n?\n\nAPI style now defaults to Composition API.\n\nSome pages contain different content based on the API style chosen. Use this switch to toggle between APIs styles.\n\nLearn moreGot it\n\nSidebar Navigation\nGetting Started\n\nIntroduction\n\nQuick Start\n\nEssentials\n\nCreating an Application\n\nTemplate Syntax\n\nReactivity Fundamentals\n\nComputed Properties\n\nClass and Style Bindings\n\nConditional Rendering\n\nList Rendering\n\nEvent Handling\n\nForm Input Bindings\n\nLifecycle Hooks\n\nWatchers\n\nTemplate Refs\n\nComponents Basics\n\nComponents In-Depth\n\nRegistration\n\nProps\n\nEvents\n\nComponent v-model\n\nFallthrough Attributes\n\nSlots\n\nProvide / inject\n\nAsync Components\n\nReusability\n\nComposables\n\nCustom Directives\n\nPlugins\n\nBuilt-in Components\n\nTransition\n\nTransitionGroup\n\nKeepAlive\n\nTeleport\n\nSuspense\n\nScaling Up\n\nSingle-File Components\n\nTooling\n\nRouting\n\nState Management\n\nTesting\n\nServer-Side Rendering (SSR)\n\nBest Practices\n\nProduction Deployment\n\nPerformance\n\nAccessibility\n\nSecurity\n\nTypeScript\n\nOverview\n\nTS with Composition API\n\nTS with Options API\n\nExtra Topics\n\nWays of Using Vue\n\nComposition API FAQ\n\nReactivity in Depth\n\nRendering Mechanism\n\nRender Functions & JSX\n\nVue and Web Components\n\nAnimation Techniques\n\nON THIS PAGE\nTable of Contents for current page\nWhat is Composition API?\nWhy Composition API?\nBetter Logic Reuse\nMore Flexible Code Organization\nBetter Type Inference\nSmaller Production Bundle and Less Overhead\nRelationship with Options API\nTrade-offs\nDoes Composition API cover all use cases?\nCan I use both APIs in the same component?\nWill Options API be deprecated?\nRelationship with Class API\nComparison with React Hooks\nSPONSORS\nBecome a Sponsor\nGet an instant overview of all your code & cloud security issues with Aikido Security. Start free.\nADS VIA CARBON\nComposition API FAQ\n​\n\nTIP\n\nThis FAQ assumes prior experience with Vue - in particular, experience with Vue 2 while primarily using Options API.\n\nWhat is Composition API?\n​\nWatch a free video lesson on Vue School\n\nComposition API is a set of APIs that allows us to author Vue components using imported functions instead of declaring options. It is an umbrella term that covers the following APIs:\n\nReactivity API, e.g. ref() and reactive(), that allows us to directly create reactive state, computed state, and watchers.\n\nLifecycle Hooks, e.g. onMounted() and onUnmounted(), that allow us to programmatically hook into the component lifecycle.\n\nDependency Injection, i.e. provide() and inject(), that allow us to leverage Vue's dependency injection system while using Reactivity APIs.\n\nComposition API is a built-in feature of Vue 3 and Vue 2.7. For older Vue 2 versions, use the officially maintained @vue/composition-api plugin. In Vue 3, it is also primarily used together with the <script setup> syntax in Single-File Components. Here's a basic example of a component using Composition API:\n\nvue\n<script setup>\nimport { ref, onMounted } from 'vue'\n\n// reactive state\nconst count = ref(0)\n\n// functions that mutate state and trigger updates\nfunction increment() {\n  count.value++\n}\n\n// lifecycle hooks\nonMounted(() => {\n  console.log(`The initial count is ${count.value}.`)\n})\n</script>\n\n<template>\n  <button @click=\"increment\">Count is: {{ count }}</button>\n</template>\n\nDespite an API style based on function composition, Composition API is NOT functional programming. Composition API is based on Vue's mutable, fine-grained reactivity paradigm, whereas functional programming emphasizes immutability.\n\nIf you are interested in learning how to use Vue with Composition API, you can set the site-wide API preference to Composition API using the toggle at the top of the left sidebar, and then go through the guide from the beginning.\n\nWhy Composition API?\n​\nBetter Logic Reuse\n​\n\nThe primary advantage of Composition API is that it enables clean, efficient logic reuse in the form of Composable functions. It solves all the drawbacks of mixins, the primary logic reuse mechanism for Options API.\n\nComposition API's logic reuse capability has given rise to impressive community projects such as VueUse, an ever-growing collection of composable utilities. It also serves as a clean mechanism for easily integrating stateful third-party services or libraries into Vue's reactivity system, for example immutable data, state machines, and RxJS.\n\nMore Flexible Code Organization\n​\n\nMany users love that we write organized code by default with Options API: everything has its place based on the option it falls under. However, Options API poses serious limitations when a single component's logic grows beyond a certain complexity threshold. This limitation is particularly prominent in components that need to deal with multiple logical concerns, which we have witnessed first hand in many production Vue 2 apps.\n\nTake the folder explorer component from Vue CLI's GUI as an example: this component is responsible for the following logical concerns:\n\nTracking current folder state and displaying its content\nHandling folder navigation (opening, closing, refreshing...)\nHandling new folder creation\nToggling show favorite folders only\nToggling show hidden folders\nHandling current working directory changes\n\nThe original version of the component was written in Options API. If we give each line of code a color based on the logical concern it is dealing with, this is how it looks:\n\nNotice how code dealing with the same logical concern is forced to be split under different options, located in different parts of the file. In a component that is several hundred lines long, understanding and navigating a single logical concern requires constantly scrolling up and down the file, making it much more difficult than it should be. In addition, if we ever intend to extract a logical concern into a reusable utility, it takes quite a bit of work to find and extract the right pieces of code from different parts of the file.\n\nHere's the same component, before and after the refactor into Composition API:\n\nNotice how the code related to the same logical concern can now be grouped together: we no longer need to jump between different options blocks while working on a specific logical concern. Moreover, we can now move a group of code into an external file with minimal effort, since we no longer need to shuffle the code around in order to extract them. This reduced friction for refactoring is key to the long-term maintainability in large codebases.\n\nBetter Type Inference\n​\n\nIn recent years, more and more frontend developers are adopting TypeScript as it helps us write more robust code, make changes with more confidence, and provides a great development experience with IDE support. However, the Options API, originally conceived in 2013, was designed without type inference in mind. We had to implement some absurdly complex type gymnastics to make type inference work with the Options API. Even with all this effort, type inference for Options API can still break down for mixins and dependency injection.\n\nThis had led many developers who wanted to use Vue with TS to lean towards Class API powered by vue-class-component. However, a class-based API heavily relies on ES decorators, a language feature that was only a stage 2 proposal when Vue 3 was being developed in 2019. We felt it was too risky to base an official API on an unstable proposal. Since then, the decorators proposal has gone through yet another complete overhaul, and finally reached stage 3 in 2022. In addition, class-based API suffers from logic reuse and organization limitations similar to Options API.\n\nIn comparison, Composition API utilizes mostly plain variables and functions, which are naturally type friendly. Code written in Composition API can enjoy full type inference with little need for manual type hints. Most of the time, Composition API code will look largely identical in TypeScript and plain JavaScript. This also makes it possible for plain JavaScript users to benefit from partial type inference.\n\nSmaller Production Bundle and Less Overhead\n​\n\nCode written in Composition API and <script setup> is also more efficient and minification-friendly than Options API equivalent. This is because the template in a <script setup> component is compiled as a function inlined in the same scope of the <script setup> code. Unlike property access from this, the compiled template code can directly access variables declared inside <script setup>, without an instance proxy in between. This also leads to better minification because all the variable names can be safely shortened.\n\nRelationship with Options API\n​\nTrade-offs\n​\n\nSome users moving from Options API found their Composition API code less organized, and concluded that Composition API is \"worse\" in terms of code organization. We recommend users with such opinions to look at that problem from a different perspective.\n\nIt is true that Composition API no longer provides the \"guard rails\" that guide you to put your code into respective buckets. In return, you get to author component code like how you would write normal JavaScript. This means you can and should apply any code organization best practices to your Composition API code as you would when writing normal JavaScript. If you can write well-organized JavaScript, you should also be able to write well-organized Composition API code.\n\nOptions API does allow you to \"think less\" when writing component code, which is why many users love it. However, in reducing the mental overhead, it also locks you into the prescribed code organization pattern with no escape hatch, which can make it difficult to refactor or improve code quality in larger scale projects. In this regard, Composition API provides better long term scalability.\n\nDoes Composition API cover all use cases?\n​\n\nYes in terms of stateful logic. When using Composition API, there are only a few options that may still be needed: props, emits, name, and inheritAttrs.\n\nTIP\n\nSince 3.3 you can directly use defineOptions in <script setup> to set the component name or inheritAttrs property\n\nIf you intend to exclusively use Composition API (along with the options listed above), you can shave a few kbs off your production bundle via a compile-time flag that drops Options API related code from Vue. Note this also affects Vue components in your dependencies.\n\nCan I use both APIs in the same component?\n​\n\nYes. You can use Composition API via the setup() option in an Options API component.\n\nHowever, we only recommend doing so if you have an existing Options API codebase that needs to integrate with new features / external libraries written with Composition API.\n\nWill Options API be deprecated?\n​\n\nNo, we do not have any plan to do so. Options API is an integral part of Vue and the reason many developers love it. We also realize that many of the benefits of Composition API only manifest in larger-scale projects, and Options API remains a solid choice for many low-to-medium-complexity scenarios.\n\nRelationship with Class API\n​\n\nWe no longer recommend using Class API with Vue 3, given that Composition API provides great TypeScript integration with additional logic reuse and code organization benefits.\n\nComparison with React Hooks\n​\n\nComposition API provides the same level of logic composition capabilities as React Hooks, but with some important differences.\n\nReact Hooks are invoked repeatedly every time a component updates. This creates a number of caveats that can confuse even seasoned React developers. It also leads to performance optimization issues that can severely affect development experience. Here are some examples:\n\nHooks are call-order sensitive and cannot be conditional.\n\nVariables declared in a React component can be captured by a hook closure and become \"stale\" if the developer fails to pass in the correct dependencies array. This leads to React developers relying on ESLint rules to ensure correct dependencies are passed. However, the rule is often not smart enough and over-compensates for correctness, which leads to unnecessary invalidation and headaches when edge cases are encountered.\n\nExpensive computations require the use of useMemo, which again requires manually passing in the correct dependencies array.\n\nEvent handlers passed to child components cause unnecessary child updates by default, and require explicit useCallback as an optimization. This is almost always needed, and again requires a correct dependencies array. Neglecting this leads to over-rendering apps by default and can cause performance issues without realizing it.\n\nThe stale closure problem, combined with Concurrent features, makes it difficult to reason about when a piece of hooks code is run, and makes working with mutable state that should persist across renders (via useRef) cumbersome.\n\nNote: some of the above issues that are related to memoization can be resolved by the upcoming React Compiler.\n\nIn comparison, Vue Composition API:\n\nInvokes setup() or <script setup> code only once. This makes the code align better with the intuitions of idiomatic JavaScript usage as there are no stale closures to worry about. Composition API calls are also not sensitive to call order and can be conditional.\n\nVue's runtime reactivity system automatically collects reactive dependencies used in computed properties and watchers, so there's no need to manually declare dependencies.\n\nNo need to manually cache callback functions to avoid unnecessary child updates. In general, Vue's fine-grained reactivity system ensures child components only update when they need to. Manual child-update optimizations are rarely a concern for Vue developers.\n\nWe acknowledge the creativity of React Hooks, and it is a major source of inspiration for Composition API. However, the issues mentioned above do exist in its design and we noticed Vue's reactivity model happens to provide a way around them.\n\nEdit this page on GitHub\n\n Previous\nWays of Using Vue\nNext \nReactivity in Depth\nComposition API FAQ has loaded"
  },
  {
    "title": "Ways of Using Vue | Vue.js",
    "url": "https://vuejs.org/guide/extras/ways-of-using-vue",
    "html": "Skip to content\nGet 60% off a year of Vue Mastery courses\nGET DISCOUNT\nVue.js\nSearch\nCtrl\nK\nMain Navigation\nDocs\nAPI\nPlayground\nEcosystem\nAbout\nSponsor\nPartners\ngithub\ntwitter\ndiscord\nAPI Preference\nOptions\nComposition\n?\n\nAPI style now defaults to Composition API.\n\nSome pages contain different content based on the API style chosen. Use this switch to toggle between APIs styles.\n\nLearn moreGot it\n\nSidebar Navigation\nGetting Started\n\nIntroduction\n\nQuick Start\n\nEssentials\n\nCreating an Application\n\nTemplate Syntax\n\nReactivity Fundamentals\n\nComputed Properties\n\nClass and Style Bindings\n\nConditional Rendering\n\nList Rendering\n\nEvent Handling\n\nForm Input Bindings\n\nLifecycle Hooks\n\nWatchers\n\nTemplate Refs\n\nComponents Basics\n\nComponents In-Depth\n\nRegistration\n\nProps\n\nEvents\n\nComponent v-model\n\nFallthrough Attributes\n\nSlots\n\nProvide / inject\n\nAsync Components\n\nReusability\n\nComposables\n\nCustom Directives\n\nPlugins\n\nBuilt-in Components\n\nTransition\n\nTransitionGroup\n\nKeepAlive\n\nTeleport\n\nSuspense\n\nScaling Up\n\nSingle-File Components\n\nTooling\n\nRouting\n\nState Management\n\nTesting\n\nServer-Side Rendering (SSR)\n\nBest Practices\n\nProduction Deployment\n\nPerformance\n\nAccessibility\n\nSecurity\n\nTypeScript\n\nOverview\n\nTS with Composition API\n\nTS with Options API\n\nExtra Topics\n\nWays of Using Vue\n\nComposition API FAQ\n\nReactivity in Depth\n\nRendering Mechanism\n\nRender Functions & JSX\n\nVue and Web Components\n\nAnimation Techniques\n\nON THIS PAGE\nTable of Contents for current page\nStandalone Script\nEmbedded Web Components\nSingle-Page Application (SPA)\nFullstack / SSR\nJAMStack / SSG\nBeyond the Web\nSPONSORS\nBecome a Sponsor\nYour Baremetal Lifeline: Online Guides if you get stuck. Let's Dive In, Shall We?\nADS VIA CARBON\nWays of Using Vue\n​\n\nWe believe there is no \"one size fits all\" story for the web. This is why Vue is designed to be flexible and incrementally adoptable. Depending on your use case, Vue can be used in different ways to strike the optimal balance between stack complexity, developer experience and end performance.\n\nStandalone Script\n​\n\nVue can be used as a standalone script file - no build step required! If you have a backend framework already rendering most of the HTML, or your frontend logic isn't complex enough to justify a build step, this is the easiest way to integrate Vue into your stack. You can think of Vue as a more declarative replacement of jQuery in such cases.\n\nVue also provides an alternative distribution called petite-vue that is specifically optimized for progressively enhancing existing HTML. It has a smaller feature set, but is extremely lightweight and uses an implementation that is more efficient in no-build-step scenarios.\n\nEmbedded Web Components\n​\n\nYou can use Vue to build standard Web Components that can be embedded in any HTML page, regardless of how they are rendered. This option allows you to leverage Vue in a completely consumer-agnostic fashion: the resulting web components can be embedded in legacy applications, static HTML, or even applications built with other frameworks.\n\nSingle-Page Application (SPA)\n​\n\nSome applications require rich interactivity, deep session depth, and non-trivial stateful logic on the frontend. The best way to build such applications is to use an architecture where Vue not only controls the entire page, but also handles data updates and navigation without having to reload the page. This type of application is typically referred to as a Single-Page Application (SPA).\n\nVue provides core libraries and comprehensive tooling support with amazing developer experience for building modern SPAs, including:\n\nClient-side router\nBlazing fast build tool chain\nIDE support\nBrowser devtools\nTypeScript integrations\nTesting utilities\n\nSPAs typically require the backend to expose API endpoints - but you can also pair Vue with solutions like Inertia.js to get the SPA benefits while retaining a server-centric development model.\n\nFullstack / SSR\n​\n\nPure client-side SPAs are problematic when the app is sensitive to SEO and time-to-content. This is because the browser will receive a largely empty HTML page, and has to wait until the JavaScript is loaded before rendering anything.\n\nVue provides first-class APIs to \"render\" a Vue app into HTML strings on the server. This allows the server to send back already-rendered HTML, allowing end users to see the content immediately while the JavaScript is being downloaded. Vue will then \"hydrate\" the application on the client side to make it interactive. This is called Server-Side Rendering (SSR) and it greatly improves Core Web Vital metrics such as Largest Contentful Paint (LCP).\n\nThere are higher-level Vue-based frameworks built on top of this paradigm, such as Nuxt, which allow you to develop a fullstack application using Vue and JavaScript.\n\nJAMStack / SSG\n​\n\nServer-side rendering can be done ahead of time if the required data is static. This means we can pre-render an entire application into HTML and serve them as static files. This improves site performance and makes deployment a lot simpler since we no longer need to dynamically render pages on each request. Vue can still hydrate such applications to provide rich interactivity on the client. This technique is commonly referred to as Static-Site Generation (SSG), also known as JAMStack.\n\nThere are two flavors of SSG: single-page and multi-page. Both flavors pre-render the site into static HTML, the difference is that:\n\nAfter the initial page load, a single-page SSG \"hydrates\" the page into an SPA. This requires more upfront JS payload and hydration cost, but subsequent navigations will be faster, since it only needs to partially update the page content instead of reloading the entire page.\n\nA multi-page SSG loads a new page on every navigation. The upside is that it can ship minimal JS - or no JS at all if the page requires no interaction! Some multi-page SSG frameworks such as Astro also support \"partial hydration\" - which allows you to use Vue components to create interactive \"islands\" inside static HTML.\n\nSingle-page SSGs are better suited if you expect non-trivial interactivity, deep session lengths, or persisted elements / state across navigations. Otherwise, multi-page SSG would be the better choice.\n\nThe Vue team also maintains a static-site generator called VitePress, which powers this website you are reading right now! VitePress supports both flavors of SSG. Nuxt also supports SSG. You can even mix SSR and SSG for different routes in the same Nuxt app.\n\nBeyond the Web\n​\n\nAlthough Vue is primarily designed for building web applications, it is by no means limited to just the browser. You can:\n\nBuild desktop apps with Electron\nBuild mobile apps with Ionic Vue\nBuild desktop and mobile apps from the same codebase with Quasar or Tauri\nBuild 3D WebGL experiences with TresJS\nUse Vue's Custom Renderer API to build custom renderers, like those for the terminal!\n\nEdit this page on GitHub\n\n Previous\nTS with Options API\nNext \nComposition API FAQ\nWays of Using Vue has loaded"
  },
  {
    "title": "TypeScript with Options API | Vue.js",
    "url": "https://vuejs.org/guide/typescript/options-api",
    "html": "Skip to content\nGet 60% off a year of Vue Mastery courses\nGET DISCOUNT\nVue.js\nSearch\nCtrl\nK\nMain Navigation\nDocs\nAPI\nPlayground\nEcosystem\nAbout\nSponsor\nPartners\ngithub\ntwitter\ndiscord\nAPI Preference\nOptions\nComposition\n?\n\nAPI style now defaults to Composition API.\n\nSome pages contain different content based on the API style chosen. Use this switch to toggle between APIs styles.\n\nLearn moreGot it\n\nSidebar Navigation\nGetting Started\n\nIntroduction\n\nQuick Start\n\nEssentials\n\nCreating an Application\n\nTemplate Syntax\n\nReactivity Fundamentals\n\nComputed Properties\n\nClass and Style Bindings\n\nConditional Rendering\n\nList Rendering\n\nEvent Handling\n\nForm Input Bindings\n\nLifecycle Hooks\n\nWatchers\n\nTemplate Refs\n\nComponents Basics\n\nComponents In-Depth\n\nRegistration\n\nProps\n\nEvents\n\nComponent v-model\n\nFallthrough Attributes\n\nSlots\n\nProvide / inject\n\nAsync Components\n\nReusability\n\nComposables\n\nCustom Directives\n\nPlugins\n\nBuilt-in Components\n\nTransition\n\nTransitionGroup\n\nKeepAlive\n\nTeleport\n\nSuspense\n\nScaling Up\n\nSingle-File Components\n\nTooling\n\nRouting\n\nState Management\n\nTesting\n\nServer-Side Rendering (SSR)\n\nBest Practices\n\nProduction Deployment\n\nPerformance\n\nAccessibility\n\nSecurity\n\nTypeScript\n\nOverview\n\nTS with Composition API\n\nTS with Options API\n\nExtra Topics\n\nWays of Using Vue\n\nComposition API FAQ\n\nReactivity in Depth\n\nRendering Mechanism\n\nRender Functions & JSX\n\nVue and Web Components\n\nAnimation Techniques\n\nON THIS PAGE\nTable of Contents for current page\nTyping Component Props\nTyping Component Emits\nTyping Computed Properties\nTyping Event Handlers\nAugmenting Global Properties\nAugmenting Custom Options\nSPONSORS\nBecome a Sponsor\nGitLab is the only place where enterprises build mission‑critical software.\nADS VIA CARBON\nTypeScript with Options API\n​\n\nThis page assumes you've already read the overview on Using Vue with TypeScript.\n\nTIP\n\nWhile Vue does support TypeScript usage with Options API, it is recommended to use Vue with TypeScript via Composition API as it offers simpler, more efficient and more robust type inference.\n\nTyping Component Props\n​\n\nType inference for props in Options API requires wrapping the component with defineComponent(). With it, Vue is able to infer the types for the props based on the props option, taking additional options such as required: true and default into account:\n\nts\nimport { defineComponent } from 'vue'\n\nexport default defineComponent({\n  // type inference enabled\n  props: {\n    name: String,\n    id: [Number, String],\n    msg: { type: String, required: true },\n    metadata: null\n  },\n  mounted() {\n    this.name // type: string | undefined\n    this.id // type: number | string | undefined\n    this.msg // type: string\n    this.metadata // type: any\n  }\n})\n\nHowever, the runtime props options only support using constructor functions as a prop's type - there is no way to specify complex types such as objects with nested properties or function call signatures.\n\nTo annotate complex props types, we can use the PropType utility type:\n\nts\nimport { defineComponent } from 'vue'\nimport type { PropType } from 'vue'\n\ninterface Book {\n  title: string\n  author: string\n  year: number\n}\n\nexport default defineComponent({\n  props: {\n    book: {\n      // provide more specific type to `Object`\n      type: Object as PropType<Book>,\n      required: true\n    },\n    // can also annotate functions\n    callback: Function as PropType<(id: number) => void>\n  },\n  mounted() {\n    this.book.title // string\n    this.book.year // number\n\n    // TS Error: argument of type 'string' is not\n    // assignable to parameter of type 'number'\n    this.callback?.('123')\n  }\n})\nCaveats\n​\n\nIf your TypeScript version is less than 4.7, you have to be careful when using function values for validator and default prop options - make sure to use arrow functions:\n\nts\nimport { defineComponent } from 'vue'\nimport type { PropType } from 'vue'\n\ninterface Book {\n  title: string\n  year?: number\n}\n\nexport default defineComponent({\n  props: {\n    bookA: {\n      type: Object as PropType<Book>,\n      // Make sure to use arrow functions if your TypeScript version is less than 4.7\n      default: () => ({\n        title: 'Arrow Function Expression'\n      }),\n      validator: (book: Book) => !!book.title\n    }\n  }\n})\n\nThis prevents TypeScript from having to infer the type of this inside these functions, which, unfortunately, can cause the type inference to fail. It was a previous design limitation, and now has been improved in TypeScript 4.7.\n\nTyping Component Emits\n​\n\nWe can declare the expected payload type for an emitted event using the object syntax of the emits option. Also, all non-declared emitted events will throw a type error when called:\n\nts\nimport { defineComponent } from 'vue'\n\nexport default defineComponent({\n  emits: {\n    addBook(payload: { bookName: string }) {\n      // perform runtime validation\n      return payload.bookName.length > 0\n    }\n  },\n  methods: {\n    onSubmit() {\n      this.$emit('addBook', {\n        bookName: 123 // Type error!\n      })\n\n      this.$emit('non-declared-event') // Type error!\n    }\n  }\n})\nTyping Computed Properties\n​\n\nA computed property infers its type based on its return value:\n\nts\nimport { defineComponent } from 'vue'\n\nexport default defineComponent({\n  data() {\n    return {\n      message: 'Hello!'\n    }\n  },\n  computed: {\n    greeting() {\n      return this.message + '!'\n    }\n  },\n  mounted() {\n    this.greeting // type: string\n  }\n})\n\nIn some cases, you may want to explicitly annotate the type of a computed property to ensure its implementation is correct:\n\nts\nimport { defineComponent } from 'vue'\n\nexport default defineComponent({\n  data() {\n    return {\n      message: 'Hello!'\n    }\n  },\n  computed: {\n    // explicitly annotate return type\n    greeting(): string {\n      return this.message + '!'\n    },\n\n    // annotating a writable computed property\n    greetingUppercased: {\n      get(): string {\n        return this.greeting.toUpperCase()\n      },\n      set(newValue: string) {\n        this.message = newValue.toUpperCase()\n      }\n    }\n  }\n})\n\nExplicit annotations may also be required in some edge cases where TypeScript fails to infer the type of a computed property due to circular inference loops.\n\nTyping Event Handlers\n​\n\nWhen dealing with native DOM events, it might be useful to type the argument we pass to the handler correctly. Let's take a look at this example:\n\nvue\n<script lang=\"ts\">\nimport { defineComponent } from 'vue'\n\nexport default defineComponent({\n  methods: {\n    handleChange(event) {\n      // `event` implicitly has `any` type\n      console.log(event.target.value)\n    }\n  }\n})\n</script>\n\n<template>\n  <input type=\"text\" @change=\"handleChange\" />\n</template>\n\nWithout type annotation, the event argument will implicitly have a type of any. This will also result in a TS error if \"strict\": true or \"noImplicitAny\": true are used in tsconfig.json. It is therefore recommended to explicitly annotate the argument of event handlers. In addition, you may need to use type assertions when accessing the properties of event:\n\nts\nimport { defineComponent } from 'vue'\n\nexport default defineComponent({\n  methods: {\n    handleChange(event: Event) {\n      console.log((event.target as HTMLInputElement).value)\n    }\n  }\n})\nAugmenting Global Properties\n​\n\nSome plugins install globally available properties to all component instances via app.config.globalProperties. For example, we may install this.$http for data-fetching or this.$translate for internationalization. To make this play well with TypeScript, Vue exposes a ComponentCustomProperties interface designed to be augmented via TypeScript module augmentation:\n\nts\nimport axios from 'axios'\n\ndeclare module 'vue' {\n  interface ComponentCustomProperties {\n    $http: typeof axios\n    $translate: (key: string) => string\n  }\n}\n\nSee also:\n\nTypeScript unit tests for component type extensions\nType Augmentation Placement\n​\n\nWe can put this type augmentation in a .ts file, or in a project-wide *.d.ts file. Either way, make sure it is included in tsconfig.json. For library / plugin authors, this file should be specified in the types property in package.json.\n\nIn order to take advantage of module augmentation, you will need to ensure the augmentation is placed in a TypeScript module. That is to say, the file needs to contain at least one top-level import or export, even if it is just export {}. If the augmentation is placed outside of a module, it will overwrite the original types rather than augmenting them!\n\nts\n// Does not work, overwrites the original types.\ndeclare module 'vue' {\n  interface ComponentCustomProperties {\n    $translate: (key: string) => string\n  }\n}\nts\n// Works correctly\nexport {}\n\ndeclare module 'vue' {\n  interface ComponentCustomProperties {\n    $translate: (key: string) => string\n  }\n}\nAugmenting Custom Options\n​\n\nSome plugins, for example vue-router, provide support for custom component options such as beforeRouteEnter:\n\nts\nimport { defineComponent } from 'vue'\n\nexport default defineComponent({\n  beforeRouteEnter(to, from, next) {\n    // ...\n  }\n})\n\nWithout proper type augmentation, the arguments of this hook will implicitly have any type. We can augment the ComponentCustomOptions interface to support these custom options:\n\nts\nimport { Route } from 'vue-router'\n\ndeclare module 'vue' {\n  interface ComponentCustomOptions {\n    beforeRouteEnter?(to: Route, from: Route, next: () => void): void\n  }\n}\n\nNow the beforeRouteEnter option will be properly typed. Note this is just an example - well-typed libraries like vue-router should automatically perform these augmentations in their own type definitions.\n\nThe placement of this augmentation is subject the same restrictions as global property augmentations.\n\nSee also:\n\nTypeScript unit tests for component type extensions\n\nEdit this page on GitHub\n\n Previous\nTS with Composition API\nNext \nWays of Using Vue\nTypeScript with Options API has loaded"
  },
  {
    "title": "TypeScript with Composition API | Vue.js",
    "url": "https://vuejs.org/guide/typescript/composition-api",
    "html": "Skip to content\nGet 60% off a year of Vue Mastery courses\nGET DISCOUNT\nVue.js\nSearch\nCtrl\nK\nMain Navigation\nDocs\nAPI\nPlayground\nEcosystem\nAbout\nSponsor\nPartners\ngithub\ntwitter\ndiscord\nAPI Preference\nOptions\nComposition\n?\n\nAPI style now defaults to Composition API.\n\nSome pages contain different content based on the API style chosen. Use this switch to toggle between APIs styles.\n\nLearn moreGot it\n\nSidebar Navigation\nGetting Started\n\nIntroduction\n\nQuick Start\n\nEssentials\n\nCreating an Application\n\nTemplate Syntax\n\nReactivity Fundamentals\n\nComputed Properties\n\nClass and Style Bindings\n\nConditional Rendering\n\nList Rendering\n\nEvent Handling\n\nForm Input Bindings\n\nLifecycle Hooks\n\nWatchers\n\nTemplate Refs\n\nComponents Basics\n\nComponents In-Depth\n\nRegistration\n\nProps\n\nEvents\n\nComponent v-model\n\nFallthrough Attributes\n\nSlots\n\nProvide / inject\n\nAsync Components\n\nReusability\n\nComposables\n\nCustom Directives\n\nPlugins\n\nBuilt-in Components\n\nTransition\n\nTransitionGroup\n\nKeepAlive\n\nTeleport\n\nSuspense\n\nScaling Up\n\nSingle-File Components\n\nTooling\n\nRouting\n\nState Management\n\nTesting\n\nServer-Side Rendering (SSR)\n\nBest Practices\n\nProduction Deployment\n\nPerformance\n\nAccessibility\n\nSecurity\n\nTypeScript\n\nOverview\n\nTS with Composition API\n\nTS with Options API\n\nExtra Topics\n\nWays of Using Vue\n\nComposition API FAQ\n\nReactivity in Depth\n\nRendering Mechanism\n\nRender Functions & JSX\n\nVue and Web Components\n\nAnimation Techniques\n\nON THIS PAGE\nTable of Contents for current page\nTyping Component Props\nTyping Component Emits\nTyping ref()\nTyping reactive()\nTyping computed()\nTyping Event Handlers\nTyping Provide / Inject\nTyping Template Refs\nTyping Component Template Refs\nSPONSORS\nBecome a Sponsor\nPower your business better. Discover powerful dedicated servers based on Intel® Xeon®\nADS VIA CARBON\nTypeScript with Composition API\n​\n\nThis page assumes you've already read the overview on Using Vue with TypeScript.\n\nTyping Component Props\n​\nUsing <script setup>\n​\n\nWhen using <script setup>, the defineProps() macro supports inferring the props types based on its argument:\n\nvue\n<script setup lang=\"ts\">\nconst props = defineProps({\n  foo: { type: String, required: true },\n  bar: Number\n})\n\nprops.foo // string\nprops.bar // number | undefined\n</script>\n\nThis is called \"runtime declaration\", because the argument passed to defineProps() will be used as the runtime props option.\n\nHowever, it is usually more straightforward to define props with pure types via a generic type argument:\n\nvue\n<script setup lang=\"ts\">\nconst props = defineProps<{\n  foo: string\n  bar?: number\n}>()\n</script>\n\nThis is called \"type-based declaration\". The compiler will try to do its best to infer the equivalent runtime options based on the type argument. In this case, our second example compiles into the exact same runtime options as the first example.\n\nYou can use either type-based declaration OR runtime declaration, but you cannot use both at the same time.\n\nWe can also move the props types into a separate interface:\n\nvue\n<script setup lang=\"ts\">\ninterface Props {\n  foo: string\n  bar?: number\n}\n\nconst props = defineProps<Props>()\n</script>\n\nThis also works if Props is imported from an external source. This feature requires TypeScript to be a peer dependency of Vue.\n\nvue\n<script setup lang=\"ts\">\nimport type { Props } from './foo'\n\nconst props = defineProps<Props>()\n</script>\nSyntax Limitations\n​\n\nIn version 3.2 and below, the generic type parameter for defineProps() were limited to a type literal or a reference to a local interface.\n\nThis limitation has been resolved in 3.3. The latest version of Vue supports referencing imported and a limited set of complex types in the type parameter position. However, because the type to runtime conversion is still AST-based, some complex types that require actual type analysis, e.g. conditional types, are not supported. You can use conditional types for the type of a single prop, but not the entire props object.\n\nProps Default Values\n​\n\nWhen using type-based declaration, we lose the ability to declare default values for the props. This can be resolved by the withDefaults compiler macro:\n\nts\nexport interface Props {\n  msg?: string\n  labels?: string[]\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  msg: 'hello',\n  labels: () => ['one', 'two']\n})\n\nThis will be compiled to equivalent runtime props default options. In addition, the withDefaults helper provides type checks for the default values, and ensures the returned props type has the optional flags removed for properties that do have default values declared.\n\nWithout <script setup>\n​\n\nIf not using <script setup>, it is necessary to use defineComponent() to enable props type inference. The type of the props object passed to setup() is inferred from the props option.\n\nts\nimport { defineComponent } from 'vue'\n\nexport default defineComponent({\n  props: {\n    message: String\n  },\n  setup(props) {\n    props.message // <-- type: string\n  }\n})\nComplex prop types\n​\n\nWith type-based declaration, a prop can use a complex type much like any other type:\n\nvue\n<script setup lang=\"ts\">\ninterface Book {\n  title: string\n  author: string\n  year: number\n}\n\nconst props = defineProps<{\n  book: Book\n}>()\n</script>\n\nFor runtime declaration, we can use the PropType utility type:\n\nts\nimport type { PropType } from 'vue'\n\nconst props = defineProps({\n  book: Object as PropType<Book>\n})\n\nThis works in much the same way if we're specifying the props option directly:\n\nts\nimport { defineComponent } from 'vue'\nimport type { PropType } from 'vue'\n\nexport default defineComponent({\n  props: {\n    book: Object as PropType<Book>\n  }\n})\n\nThe props option is more commonly used with the Options API, so you'll find more detailed examples in the guide to TypeScript with Options API. The techniques shown in those examples also apply to runtime declarations using defineProps().\n\nTyping Component Emits\n​\n\nIn <script setup>, the emit function can also be typed using either runtime declaration OR type declaration:\n\nvue\n<script setup lang=\"ts\">\n// runtime\nconst emit = defineEmits(['change', 'update'])\n\n// options based\nconst emit = defineEmits({\n  change: (id: number) => {\n    // return `true` or `false` to indicate\n    // validation pass / fail\n  },\n  update: (value: string) => {\n    // return `true` or `false` to indicate\n    // validation pass / fail\n  }\n})\n\n// type-based\nconst emit = defineEmits<{\n  (e: 'change', id: number): void\n  (e: 'update', value: string): void\n}>()\n\n// 3.3+: alternative, more succinct syntax\nconst emit = defineEmits<{\n  change: [id: number]\n  update: [value: string]\n}>()\n</script>\n\nThe type argument can be one of the following:\n\nA callable function type, but written as a type literal with Call Signatures. It will be used as the type of the returned emit function.\nA type literal where the keys are the event names, and values are array / tuple types representing the additional accepted parameters for the event. The example above is using named tuples so each argument can have an explicit name.\n\nAs we can see, the type declaration gives us much finer-grained control over the type constraints of emitted events.\n\nWhen not using <script setup>, defineComponent() is able to infer the allowed events for the emit function exposed on the setup context:\n\nts\nimport { defineComponent } from 'vue'\n\nexport default defineComponent({\n  emits: ['change'],\n  setup(props, { emit }) {\n    emit('change') // <-- type check / auto-completion\n  }\n})\nTyping ref()\n​\n\nRefs infer the type from the initial value:\n\nts\nimport { ref } from 'vue'\n\n// inferred type: Ref<number>\nconst year = ref(2020)\n\n// => TS Error: Type 'string' is not assignable to type 'number'.\nyear.value = '2020'\n\nSometimes we may need to specify complex types for a ref's inner value. We can do that by using the Ref type:\n\nts\nimport { ref } from 'vue'\nimport type { Ref } from 'vue'\n\nconst year: Ref<string | number> = ref('2020')\n\nyear.value = 2020 // ok!\n\nOr, by passing a generic argument when calling ref() to override the default inference:\n\nts\n// resulting type: Ref<string | number>\nconst year = ref<string | number>('2020')\n\nyear.value = 2020 // ok!\n\nIf you specify a generic type argument but omit the initial value, the resulting type will be a union type that includes undefined:\n\nts\n// inferred type: Ref<number | undefined>\nconst n = ref<number>()\nTyping reactive()\n​\n\nreactive() also implicitly infers the type from its argument:\n\nts\nimport { reactive } from 'vue'\n\n// inferred type: { title: string }\nconst book = reactive({ title: 'Vue 3 Guide' })\n\nTo explicitly type a reactive property, we can use interfaces:\n\nts\nimport { reactive } from 'vue'\n\ninterface Book {\n  title: string\n  year?: number\n}\n\nconst book: Book = reactive({ title: 'Vue 3 Guide' })\n\nTIP\n\nIt's not recommended to use the generic argument of reactive() because the returned type, which handles nested ref unwrapping, is different from the generic argument type.\n\nTyping computed()\n​\n\ncomputed() infers its type based on the getter's return value:\n\nts\nimport { ref, computed } from 'vue'\n\nconst count = ref(0)\n\n// inferred type: ComputedRef<number>\nconst double = computed(() => count.value * 2)\n\n// => TS Error: Property 'split' does not exist on type 'number'\nconst result = double.value.split('')\n\nYou can also specify an explicit type via a generic argument:\n\nts\nconst double = computed<number>(() => {\n  // type error if this doesn't return a number\n})\nTyping Event Handlers\n​\n\nWhen dealing with native DOM events, it might be useful to type the argument we pass to the handler correctly. Let's take a look at this example:\n\nvue\n<script setup lang=\"ts\">\nfunction handleChange(event) {\n  // `event` implicitly has `any` type\n  console.log(event.target.value)\n}\n</script>\n\n<template>\n  <input type=\"text\" @change=\"handleChange\" />\n</template>\n\nWithout type annotation, the event argument will implicitly have a type of any. This will also result in a TS error if \"strict\": true or \"noImplicitAny\": true are used in tsconfig.json. It is therefore recommended to explicitly annotate the argument of event handlers. In addition, you may need to use type assertions when accessing the properties of event:\n\nts\nfunction handleChange(event: Event) {\n  console.log((event.target as HTMLInputElement).value)\n}\nTyping Provide / Inject\n​\n\nProvide and inject are usually performed in separate components. To properly type injected values, Vue provides an InjectionKey interface, which is a generic type that extends Symbol. It can be used to sync the type of the injected value between the provider and the consumer:\n\nts\nimport { provide, inject } from 'vue'\nimport type { InjectionKey } from 'vue'\n\nconst key = Symbol() as InjectionKey<string>\n\nprovide(key, 'foo') // providing non-string value will result in error\n\nconst foo = inject(key) // type of foo: string | undefined\n\nIt's recommended to place the injection key in a separate file so that it can be imported in multiple components.\n\nWhen using string injection keys, the type of the injected value will be unknown, and needs to be explicitly declared via a generic type argument:\n\nts\nconst foo = inject<string>('foo') // type: string | undefined\n\nNotice the injected value can still be undefined, because there is no guarantee that a provider will provide this value at runtime.\n\nThe undefined type can be removed by providing a default value:\n\nts\nconst foo = inject<string>('foo', 'bar') // type: string\n\nIf you are sure that the value is always provided, you can also force cast the value:\n\nts\nconst foo = inject('foo') as string\nTyping Template Refs\n​\n\nTemplate refs should be created with an explicit generic type argument and an initial value of null:\n\nvue\n<script setup lang=\"ts\">\nimport { ref, onMounted } from 'vue'\n\nconst el = ref<HTMLInputElement | null>(null)\n\nonMounted(() => {\n  el.value?.focus()\n})\n</script>\n\n<template>\n  <input ref=\"el\" />\n</template>\n\nTo get the right DOM interface you can check pages like MDN.\n\nNote that for strict type safety, it is necessary to use optional chaining or type guards when accessing el.value. This is because the initial ref value is null until the component is mounted, and it can also be set to null if the referenced element is unmounted by v-if.\n\nTyping Component Template Refs\n​\n\nSometimes you might need to annotate a template ref for a child component in order to call its public method. For example, we have a MyModal child component with a method that opens the modal:\n\nvue\n<!-- MyModal.vue -->\n<script setup lang=\"ts\">\nimport { ref } from 'vue'\n\nconst isContentShown = ref(false)\nconst open = () => (isContentShown.value = true)\n\ndefineExpose({\n  open\n})\n</script>\n\nIn order to get the instance type of MyModal, we need to first get its type via typeof, then use TypeScript's built-in InstanceType utility to extract its instance type:\n\nvue\n<!-- App.vue -->\n<script setup lang=\"ts\">\nimport MyModal from './MyModal.vue'\n\nconst modal = ref<InstanceType<typeof MyModal> | null>(null)\n\nconst openModal = () => {\n  modal.value?.open()\n}\n</script>\n\nIn cases where the exact type of the component isn't available or isn't important, ComponentPublicInstance can be used instead. This will only include properties that are shared by all components, such as $el:\n\nts\nimport { ref } from 'vue'\nimport type { ComponentPublicInstance } from 'vue'\n\nconst child = ref<ComponentPublicInstance | null>(null)\n\nEdit this page on GitHub\n\n Previous\nOverview\nNext \nTS with Options API\nTypeScript with Composition API has loaded"
  },
  {
    "title": "Using Vue with TypeScript | Vue.js",
    "url": "https://vuejs.org/guide/typescript/overview",
    "html": "Skip to content\nGet 60% off a year of Vue Mastery courses\nGET DISCOUNT\nVue.js\nSearch\nCtrl\nK\nMain Navigation\nDocs\nAPI\nPlayground\nEcosystem\nAbout\nSponsor\nPartners\ngithub\ntwitter\ndiscord\nAPI Preference\nOptions\nComposition\n?\n\nAPI style now defaults to Composition API.\n\nSome pages contain different content based on the API style chosen. Use this switch to toggle between APIs styles.\n\nLearn moreGot it\n\nSidebar Navigation\nGetting Started\n\nIntroduction\n\nQuick Start\n\nEssentials\n\nCreating an Application\n\nTemplate Syntax\n\nReactivity Fundamentals\n\nComputed Properties\n\nClass and Style Bindings\n\nConditional Rendering\n\nList Rendering\n\nEvent Handling\n\nForm Input Bindings\n\nLifecycle Hooks\n\nWatchers\n\nTemplate Refs\n\nComponents Basics\n\nComponents In-Depth\n\nRegistration\n\nProps\n\nEvents\n\nComponent v-model\n\nFallthrough Attributes\n\nSlots\n\nProvide / inject\n\nAsync Components\n\nReusability\n\nComposables\n\nCustom Directives\n\nPlugins\n\nBuilt-in Components\n\nTransition\n\nTransitionGroup\n\nKeepAlive\n\nTeleport\n\nSuspense\n\nScaling Up\n\nSingle-File Components\n\nTooling\n\nRouting\n\nState Management\n\nTesting\n\nServer-Side Rendering (SSR)\n\nBest Practices\n\nProduction Deployment\n\nPerformance\n\nAccessibility\n\nSecurity\n\nTypeScript\n\nOverview\n\nTS with Composition API\n\nTS with Options API\n\nExtra Topics\n\nWays of Using Vue\n\nComposition API FAQ\n\nReactivity in Depth\n\nRendering Mechanism\n\nRender Functions & JSX\n\nVue and Web Components\n\nAnimation Techniques\n\nON THIS PAGE\nTable of Contents for current page\nProject Setup\nOverview\nIDE Support\nConfiguring tsconfig.json\nNote on Vue CLI and ts-loader\nGeneral Usage Notes\ndefineComponent()\nUsage in Single-File Components\nTypeScript in Templates\nUsage with TSX\nGeneric Components\nAPI-Specific Recipes\nSPONSORS\nBecome a Sponsor\nTop-tier Infra protection. Robust Baremetal. Anti-DDoS Included. Secure your Infra\nADS VIA CARBON\nUsing Vue with TypeScript\n​\n\nA type system like TypeScript can detect many common errors via static analysis at build time. This reduces the chance of runtime errors in production, and also allows us to more confidently refactor code in large-scale applications. TypeScript also improves developer ergonomics via type-based auto-completion in IDEs.\n\nVue is written in TypeScript itself and provides first-class TypeScript support. All official Vue packages come with bundled type declarations that should work out-of-the-box.\n\nProject Setup\n​\n\ncreate-vue, the official project scaffolding tool, offers the options to scaffold a Vite-powered, TypeScript-ready Vue project.\n\nOverview\n​\n\nWith a Vite-based setup, the dev server and the bundler are transpilation-only and do not perform any type-checking. This ensures the Vite dev server stays blazing fast even when using TypeScript.\n\nDuring development, we recommend relying on a good IDE setup for instant feedback on type errors.\n\nIf using SFCs, use the vue-tsc utility for command line type checking and type declaration generation. vue-tsc is a wrapper around tsc, TypeScript's own command line interface. It works largely the same as tsc except that it supports Vue SFCs in addition to TypeScript files. You can run vue-tsc in watch mode in parallel to the Vite dev server, or use a Vite plugin like vite-plugin-checker which runs the checks in a separate worker thread.\n\nVue CLI also provides TypeScript support, but is no longer recommended. See notes below.\n\nIDE Support\n​\n\nVisual Studio Code (VS Code) is strongly recommended for its great out-of-the-box support for TypeScript.\n\nVue - Official (previously Volar) is the official VS Code extension that provides TypeScript support inside Vue SFCs, along with many other great features.\n\nTIP\n\nVue - Official extension replaces Vetur, our previous official VS Code extension for Vue 2. If you have Vetur currently installed, make sure to disable it in Vue 3 projects.\n\nWebStorm also provides out-of-the-box support for both TypeScript and Vue. Other JetBrains IDEs support them too, either out of the box or via a free plugin. As of version 2023.2, WebStorm and the Vue Plugin come with built-in support for the Vue Language Server. You can set the Vue service to use Volar integration on all TypeScript versions, under Settings > Languages & Frameworks > TypeScript > Vue. By default, Volar will be used for TypeScript versions 5.0 and higher.\n\nConfiguring tsconfig.json\n​\n\nProjects scaffolded via create-vue include pre-configured tsconfig.json. The base config is abstracted in the @vue/tsconfig package. Inside the project, we use Project References to ensure correct types for code running in different environments (e.g. app code and test code should have different global variables).\n\nWhen configuring tsconfig.json manually, some notable options include:\n\ncompilerOptions.isolatedModules is set to true because Vite uses esbuild for transpiling TypeScript and is subject to single-file transpile limitations. compilerOptions.verbatimModuleSyntax is a superset of isolatedModules and is a good choice, too - it's what @vue/tsconfig uses.\n\nIf you're using Options API, you need to set compilerOptions.strict to true (or at least enable compilerOptions.noImplicitThis, which is a part of the strict flag) to leverage type checking of this in component options. Otherwise this will be treated as any.\n\nIf you have configured resolver aliases in your build tool, for example the @/* alias configured by default in a create-vue project, you need to also configure it for TypeScript via compilerOptions.paths.\n\nIf you intend to use TSX with Vue, set compilerOptions.jsx to \"preserve\", and set compilerOptions.jsxImportSource to \"vue\".\n\nSee also:\n\nOfficial TypeScript compiler options docs\nesbuild TypeScript compilation caveats\nNote on Vue CLI and ts-loader\n​\n\nIn webpack-based setups such as Vue CLI, it is common to perform type checking as part of the module transform pipeline, for example with ts-loader. This, however, isn't a clean solution because the type system needs knowledge of the entire module graph to perform type checks. Individual module's transform step simply is not the right place for the task. It leads to the following problems:\n\nts-loader can only type check post-transform code. This doesn't align with the errors we see in IDEs or from vue-tsc, which map directly back to the source code.\n\nType checking can be slow. When it is performed in the same thread / process with code transformations, it significantly affects the build speed of the entire application.\n\nWe already have type checking running right in our IDE in a separate process, so the cost of dev experience slow down simply isn't a good trade-off.\n\nIf you are currently using Vue 3 + TypeScript via Vue CLI, we strongly recommend migrating over to Vite. We are also working on CLI options to enable transpile-only TS support, so that you can switch to vue-tsc for type checking.\n\nGeneral Usage Notes\n​\ndefineComponent()\n​\n\nTo let TypeScript properly infer types inside component options, we need to define components with defineComponent():\n\nts\nimport { defineComponent } from 'vue'\n\nexport default defineComponent({\n  // type inference enabled\n  props: {\n    name: String,\n    msg: { type: String, required: true }\n  },\n  data() {\n    return {\n      count: 1\n    }\n  },\n  mounted() {\n    this.name // type: string | undefined\n    this.msg // type: string\n    this.count // type: number\n  }\n})\n\ndefineComponent() also supports inferring the props passed to setup() when using Composition API without <script setup>:\n\nts\nimport { defineComponent } from 'vue'\n\nexport default defineComponent({\n  // type inference enabled\n  props: {\n    message: String\n  },\n  setup(props) {\n    props.message // type: string | undefined\n  }\n})\n\nSee also:\n\nNote on webpack Treeshaking\ntype tests for defineComponent\n\nTIP\n\ndefineComponent() also enables type inference for components defined in plain JavaScript.\n\nUsage in Single-File Components\n​\n\nTo use TypeScript in SFCs, add the lang=\"ts\" attribute to <script> tags. When lang=\"ts\" is present, all template expressions also enjoy stricter type checking.\n\nvue\n<script lang=\"ts\">\nimport { defineComponent } from 'vue'\n\nexport default defineComponent({\n  data() {\n    return {\n      count: 1\n    }\n  }\n})\n</script>\n\n<template>\n  <!-- type checking and auto-completion enabled -->\n  {{ count.toFixed(2) }}\n</template>\n\nlang=\"ts\" can also be used with <script setup>:\n\nvue\n<script setup lang=\"ts\">\n// TypeScript enabled\nimport { ref } from 'vue'\n\nconst count = ref(1)\n</script>\n\n<template>\n  <!-- type checking and auto-completion enabled -->\n  {{ count.toFixed(2) }}\n</template>\nTypeScript in Templates\n​\n\nThe <template> also supports TypeScript in binding expressions when <script lang=\"ts\"> or <script setup lang=\"ts\"> is used. This is useful in cases where you need to perform type casting in template expressions.\n\nHere's a contrived example:\n\nvue\n<script setup lang=\"ts\">\nlet x: string | number = 1\n</script>\n\n<template>\n  <!-- error because x could be a string -->\n  {{ x.toFixed(2) }}\n</template>\n\nThis can be worked around with an inline type cast:\n\nvue\n<script setup lang=\"ts\">\nlet x: string | number = 1\n</script>\n\n<template>\n  {{ (x as number).toFixed(2) }}\n</template>\n\nTIP\n\nIf using Vue CLI or a webpack-based setup, TypeScript in template expressions requires vue-loader@^16.8.0.\n\nUsage with TSX\n​\n\nVue also supports authoring components with JSX / TSX. Details are covered in the Render Function & JSX guide.\n\nGeneric Components\n​\n\nGeneric components are supported in two cases:\n\nIn SFCs: <script setup> with the generic attribute\nRender function / JSX components: defineComponent()'s function signature\nAPI-Specific Recipes\n​\nTS with Composition API\nTS with Options API\n\nEdit this page on GitHub\n\n Previous\nSecurity\nNext \nTS with Composition API\nUsing Vue with TypeScript has loaded"
  },
  {
    "title": "Security | Vue.js",
    "url": "https://vuejs.org/guide/best-practices/security",
    "html": "Skip to content\nGet 60% off a year of Vue Mastery courses\nGET DISCOUNT\nVue.js\nSearch\nCtrl\nK\nMain Navigation\nDocs\nAPI\nPlayground\nEcosystem\nAbout\nSponsor\nPartners\ngithub\ntwitter\ndiscord\nAPI Preference\nOptions\nComposition\n?\n\nAPI style now defaults to Composition API.\n\nSome pages contain different content based on the API style chosen. Use this switch to toggle between APIs styles.\n\nLearn moreGot it\n\nSidebar Navigation\nGetting Started\n\nIntroduction\n\nQuick Start\n\nEssentials\n\nCreating an Application\n\nTemplate Syntax\n\nReactivity Fundamentals\n\nComputed Properties\n\nClass and Style Bindings\n\nConditional Rendering\n\nList Rendering\n\nEvent Handling\n\nForm Input Bindings\n\nLifecycle Hooks\n\nWatchers\n\nTemplate Refs\n\nComponents Basics\n\nComponents In-Depth\n\nRegistration\n\nProps\n\nEvents\n\nComponent v-model\n\nFallthrough Attributes\n\nSlots\n\nProvide / inject\n\nAsync Components\n\nReusability\n\nComposables\n\nCustom Directives\n\nPlugins\n\nBuilt-in Components\n\nTransition\n\nTransitionGroup\n\nKeepAlive\n\nTeleport\n\nSuspense\n\nScaling Up\n\nSingle-File Components\n\nTooling\n\nRouting\n\nState Management\n\nTesting\n\nServer-Side Rendering (SSR)\n\nBest Practices\n\nProduction Deployment\n\nPerformance\n\nAccessibility\n\nSecurity\n\nTypeScript\n\nOverview\n\nTS with Composition API\n\nTS with Options API\n\nExtra Topics\n\nWays of Using Vue\n\nComposition API FAQ\n\nReactivity in Depth\n\nRendering Mechanism\n\nRender Functions & JSX\n\nVue and Web Components\n\nAnimation Techniques\n\nON THIS PAGE\nTable of Contents for current page\nReporting Vulnerabilities\nRule No.1: Never Use Non-trusted Templates\nWhat Vue Does to Protect You\nPotential Dangers\nBest Practices\nBackend Coordination\nServer-Side Rendering (SSR)\nSPONSORS\nBecome a Sponsor\nSquarespace tools make it easy to create a beautiful and unique website.\nADS VIA CARBON\nSecurity\n​\nReporting Vulnerabilities\n​\n\nWhen a vulnerability is reported, it immediately becomes our top concern, with a full-time contributor dropping everything to work on it. To report a vulnerability, please email security@vuejs.org.\n\nWhile the discovery of new vulnerabilities is rare, we also recommend always using the latest versions of Vue and its official companion libraries to ensure your application remains as secure as possible.\n\nRule No.1: Never Use Non-trusted Templates\n​\n\nThe most fundamental security rule when using Vue is never use non-trusted content as your component template. Doing so is equivalent to allowing arbitrary JavaScript execution in your application - and worse, could lead to server breaches if the code is executed during server-side rendering. An example of such usage:\n\njs\nVue.createApp({\n  template: `<div>` + userProvidedString + `</div>` // NEVER DO THIS\n}).mount('#app')\n\nVue templates are compiled into JavaScript, and expressions inside templates will be executed as part of the rendering process. Although the expressions are evaluated against a specific rendering context, due to the complexity of potential global execution environments, it is impractical for a framework like Vue to completely shield you from potential malicious code execution without incurring unrealistic performance overhead. The most straightforward way to avoid this category of problems altogether is to make sure the contents of your Vue templates are always trusted and entirely controlled by you.\n\nWhat Vue Does to Protect You\n​\nHTML content\n​\n\nWhether using templates or render functions, content is automatically escaped. That means in this template:\n\ntemplate\n<h1>{{ userProvidedString }}</h1>\n\nif userProvidedString contained:\n\njs\n'<script>alert(\"hi\")</script>'\n\nthen it would be escaped to the following HTML:\n\ntemplate\n&lt;script&gt;alert(&quot;hi&quot;)&lt;/script&gt;\n\nthus preventing the script injection. This escaping is done using native browser APIs, like textContent, so a vulnerability can only exist if the browser itself is vulnerable.\n\nAttribute bindings\n​\n\nSimilarly, dynamic attribute bindings are also automatically escaped. That means in this template:\n\ntemplate\n<h1 :title=\"userProvidedString\">\n  hello\n</h1>\n\nif userProvidedString contained:\n\njs\n'\" onclick=\"alert(\\'hi\\')'\n\nthen it would be escaped to the following HTML:\n\ntemplate\n&quot; onclick=&quot;alert('hi')\n\nthus preventing the close of the title attribute to inject new, arbitrary HTML. This escaping is done using native browser APIs, like setAttribute, so a vulnerability can only exist if the browser itself is vulnerable.\n\nPotential Dangers\n​\n\nIn any web application, allowing unsanitized, user-provided content to be executed as HTML, CSS, or JavaScript is potentially dangerous, so it should be avoided wherever possible. There are times when some risk may be acceptable, though.\n\nFor example, services like CodePen and JSFiddle allow user-provided content to be executed, but it's in a context where this is expected and sandboxed to some extent inside iframes. In the cases when an important feature inherently requires some level of vulnerability, it's up to your team to weigh the importance of the feature against the worst-case scenarios the vulnerability enables.\n\nHTML Injection\n​\n\nAs you learned earlier, Vue automatically escapes HTML content, preventing you from accidentally injecting executable HTML into your application. However, in cases where you know the HTML is safe, you can explicitly render HTML content:\n\nUsing a template:\n\ntemplate\n<div v-html=\"userProvidedHtml\"></div>\n\nUsing a render function:\n\njs\nh('div', {\n  innerHTML: this.userProvidedHtml\n})\n\nUsing a render function with JSX:\n\njsx\n<div innerHTML={this.userProvidedHtml}></div>\n\nWARNING\n\nUser-provided HTML can never be considered 100% safe unless it's in a sandboxed iframe or in a part of the app where only the user who wrote that HTML can ever be exposed to it. Additionally, allowing users to write their own Vue templates brings similar dangers.\n\nURL Injection\n​\n\nIn a URL like this:\n\ntemplate\n<a :href=\"userProvidedUrl\">\n  click me\n</a>\n\nThere's a potential security issue if the URL has not been \"sanitized\" to prevent JavaScript execution using javascript:. There are libraries such as sanitize-url to help with this, but note: if you're ever doing URL sanitization on the frontend, you already have a security issue. User-provided URLs should always be sanitized by your backend before even being saved to a database. Then the problem is avoided for every client connecting to your API, including native mobile apps. Also note that even with sanitized URLs, Vue cannot help you guarantee that they lead to safe destinations.\n\nStyle Injection\n​\n\nLooking at this example:\n\ntemplate\n<a\n  :href=\"sanitizedUrl\"\n  :style=\"userProvidedStyles\"\n>\n  click me\n</a>\n\nLet's assume that sanitizedUrl has been sanitized, so that it's definitely a real URL and not JavaScript. With the userProvidedStyles, malicious users could still provide CSS to \"click jack\", e.g. styling the link into a transparent box over the \"Log in\" button. Then if https://user-controlled-website.com/ is built to resemble the login page of your application, they might have just captured a user's real login information.\n\nYou may be able to imagine how allowing user-provided content for a <style> element would create an even greater vulnerability, giving that user full control over how to style the entire page. That's why Vue prevents rendering of style tags inside templates, such as:\n\ntemplate\n<style>{{ userProvidedStyles }}</style>\n\nTo keep your users fully safe from clickjacking, we recommend only allowing full control over CSS inside a sandboxed iframe. Alternatively, when providing user control through a style binding, we recommend using its object syntax and only allowing users to provide values for specific properties it's safe for them to control, like this:\n\ntemplate\n<a\n  :href=\"sanitizedUrl\"\n  :style=\"{\n    color: userProvidedColor,\n    background: userProvidedBackground\n  }\"\n>\n  click me\n</a>\nJavaScript Injection\n​\n\nWe strongly discourage ever rendering a <script> element with Vue, since templates and render functions should never have side effects. However, this isn't the only way to include strings that would be evaluated as JavaScript at runtime.\n\nEvery HTML element has attributes with values accepting strings of JavaScript, such as onclick, onfocus, and onmouseenter. Binding user-provided JavaScript to any of these event attributes is a potential security risk, so it should be avoided.\n\nWARNING\n\nUser-provided JavaScript can never be considered 100% safe unless it's in a sandboxed iframe or in a part of the app where only the user who wrote that JavaScript can ever be exposed to it.\n\nSometimes we receive vulnerability reports on how it's possible to do cross-site scripting (XSS) in Vue templates. In general, we do not consider such cases to be actual vulnerabilities because there's no practical way to protect developers from the two scenarios that would allow XSS:\n\nThe developer is explicitly asking Vue to render user-provided, unsanitized content as Vue templates. This is inherently unsafe, and there's no way for Vue to know the origin.\n\nThe developer is mounting Vue to an entire HTML page which happens to contain server-rendered and user-provided content. This is fundamentally the same problem as #1, but sometimes devs may do it without realizing it. This can lead to possible vulnerabilities where the attacker provides HTML which is safe as plain HTML but unsafe as a Vue template. The best practice is to never mount Vue on nodes that may contain server-rendered and user-provided content.\n\nBest Practices\n​\n\nThe general rule is that if you allow unsanitized, user-provided content to be executed (as either HTML, JavaScript, or even CSS), you might open yourself up to attacks. This advice actually holds true whether using Vue, another framework, or even no framework.\n\nBeyond the recommendations made above for Potential Dangers, we also recommend familiarizing yourself with these resources:\n\nHTML5 Security Cheat Sheet\nOWASP's Cross Site Scripting (XSS) Prevention Cheat Sheet\n\nThen use what you learn to also review the source code of your dependencies for potentially dangerous patterns, if any of them include 3rd-party components or otherwise influence what's rendered to the DOM.\n\nBackend Coordination\n​\n\nHTTP security vulnerabilities, such as cross-site request forgery (CSRF/XSRF) and cross-site script inclusion (XSSI), are primarily addressed on the backend, so they aren't a concern of Vue's. However, it's still a good idea to communicate with your backend team to learn how to best interact with their API, e.g., by submitting CSRF tokens with form submissions.\n\nServer-Side Rendering (SSR)\n​\n\nThere are some additional security concerns when using SSR, so make sure to follow the best practices outlined throughout our SSR documentation to avoid vulnerabilities.\n\nEdit this page on GitHub\n\n Previous\nAccessibility\nNext \nOverview\nSecurity has loaded"
  },
  {
    "title": "Accessibility | Vue.js",
    "url": "https://vuejs.org/guide/best-practices/accessibility",
    "html": "Skip to content\nGet 60% off a year of Vue Mastery courses\nGET DISCOUNT\nVue.js\nSearch\nCtrl\nK\nMain Navigation\nDocs\nAPI\nPlayground\nEcosystem\nAbout\nSponsor\nPartners\ngithub\ntwitter\ndiscord\nAPI Preference\nOptions\nComposition\n?\n\nAPI style now defaults to Composition API.\n\nSome pages contain different content based on the API style chosen. Use this switch to toggle between APIs styles.\n\nLearn moreGot it\n\nSidebar Navigation\nGetting Started\n\nIntroduction\n\nQuick Start\n\nEssentials\n\nCreating an Application\n\nTemplate Syntax\n\nReactivity Fundamentals\n\nComputed Properties\n\nClass and Style Bindings\n\nConditional Rendering\n\nList Rendering\n\nEvent Handling\n\nForm Input Bindings\n\nLifecycle Hooks\n\nWatchers\n\nTemplate Refs\n\nComponents Basics\n\nComponents In-Depth\n\nRegistration\n\nProps\n\nEvents\n\nComponent v-model\n\nFallthrough Attributes\n\nSlots\n\nProvide / inject\n\nAsync Components\n\nReusability\n\nComposables\n\nCustom Directives\n\nPlugins\n\nBuilt-in Components\n\nTransition\n\nTransitionGroup\n\nKeepAlive\n\nTeleport\n\nSuspense\n\nScaling Up\n\nSingle-File Components\n\nTooling\n\nRouting\n\nState Management\n\nTesting\n\nServer-Side Rendering (SSR)\n\nBest Practices\n\nProduction Deployment\n\nPerformance\n\nAccessibility\n\nSecurity\n\nTypeScript\n\nOverview\n\nTS with Composition API\n\nTS with Options API\n\nExtra Topics\n\nWays of Using Vue\n\nComposition API FAQ\n\nReactivity in Depth\n\nRendering Mechanism\n\nRender Functions & JSX\n\nVue and Web Components\n\nAnimation Techniques\n\nON THIS PAGE\nTable of Contents for current page\nSkip link\nContent Structure\nSemantic Forms\nStandards\nResources\nSPONSORS\nBecome a Sponsor\nRun resilient apps anywhere in public, private, or hybrid clouds\nADS VIA CARBON\nAccessibility\n​\n\nWeb accessibility (also known as a11y) refers to the practice of creating websites that can be used by anyone — be that a person with a disability, a slow connection, outdated or broken hardware or simply someone in an unfavorable environment. For example, adding subtitles to a video would help both your deaf and hard-of-hearing users and your users who are in a loud environment and can't hear their phone. Similarly, making sure your text isn't too low contrast will help both your low-vision users and your users who are trying to use their phone in bright sunlight.\n\nReady to start but aren’t sure where?\n\nCheckout the Planning and managing web accessibility guide provided by World Wide Web Consortium (W3C)\n\nSkip link\n​\n\nYou should add a link at the top of each page that goes directly to the main content area so users can skip content that is repeated on multiple Web pages.\n\nTypically this is done on the top of App.vue as it will be the first focusable element on all your pages:\n\ntemplate\n<ul class=\"skip-links\">\n  <li>\n    <a href=\"#main\" ref=\"skipLink\" class=\"skip-link\">Skip to main content</a>\n  </li>\n</ul>\n\nTo hide the link unless it is focused, you can add the following style:\n\ncss\n.skip-link {\n  white-space: nowrap;\n  margin: 1em auto;\n  top: 0;\n  position: fixed;\n  left: 50%;\n  margin-left: -72px;\n  opacity: 0;\n}\n.skip-link:focus {\n  opacity: 1;\n  background-color: white;\n  padding: 0.5em;\n  border: 1px solid black;\n}\n\nOnce a user changes route, bring focus back to the skip link. This can be achieved by calling focus on the skip link's template ref (assuming usage of vue-router):\n\nvue\n<script setup>\nimport { ref, watch } from 'vue'\nimport { useRoute } from 'vue-router'\n\nconst route = useRoute()\nconst skipLink = ref()\n\nwatch(\n  () => route.path,\n  () => {\n    skipLink.value.focus()\n  }\n)\n</script>\n\nRead documentation on skip link to main content\n\nContent Structure\n​\n\nOne of the most important pieces of accessibility is making sure that design can support accessible implementation. Design should consider not only color contrast, font selection, text sizing, and language, but also how the content is structured in the application.\n\nHeadings\n​\n\nUsers can navigate an application through headings. Having descriptive headings for every section of your application makes it easier for users to predict the content of each section. When it comes to headings, there are a couple of recommended accessibility practices:\n\nNest headings in their ranking order: <h1> - <h6>\nDon’t skip headings within a section\nUse actual heading tags instead of styling text to give the visual appearance of headings\n\nRead more about headings\n\ntemplate\n<main role=\"main\" aria-labelledby=\"main-title\">\n  <h1 id=\"main-title\">Main title</h1>\n  <section aria-labelledby=\"section-title-1\">\n    <h2 id=\"section-title-1\"> Section Title </h2>\n    <h3>Section Subtitle</h3>\n    <!-- Content -->\n  </section>\n  <section aria-labelledby=\"section-title-2\">\n    <h2 id=\"section-title-2\"> Section Title </h2>\n    <h3>Section Subtitle</h3>\n    <!-- Content -->\n    <h3>Section Subtitle</h3>\n    <!-- Content -->\n  </section>\n</main>\nLandmarks\n​\n\nLandmarks provide programmatic access to sections within an application. Users who rely on assistive technology can navigate to each section of the application and skip over content. You can use ARIA roles to help you achieve this.\n\nHTML\tARIA Role\tLandmark Purpose\nheader\trole=\"banner\"\tPrime heading: title of the page\nnav\trole=\"navigation\"\tCollection of links suitable for use when navigating the document or related documents\nmain\trole=\"main\"\tThe main or central content of the document.\nfooter\trole=\"contentinfo\"\tInformation about the parent document: footnotes/copyrights/links to privacy statement\naside\trole=\"complementary\"\tSupports the main content, yet is separated and meaningful on its own content\nsearch\trole=\"search\"\tThis section contains the search functionality for the application\nform\trole=\"form\"\tCollection of form-associated elements\nsection\trole=\"region\"\tContent that is relevant and that users will likely want to navigate to. Label must be provided for this element\n\nTip:\n\nIt is recommended to use landmark HTML elements with redundant landmark role attributes in order to maximize compatibility with legacy browsers that don’t support HTML5 semantic elements.\n\nRead more about landmarks\n\nSemantic Forms\n​\n\nWhen creating a form, you can use the following elements: <form>, <label>, <input>, <textarea>, and <button>\n\nLabels are typically placed on top or to the left of the form fields:\n\ntemplate\n<form action=\"/dataCollectionLocation\" method=\"post\" autocomplete=\"on\">\n  <div v-for=\"item in formItems\" :key=\"item.id\" class=\"form-item\">\n    <label :for=\"item.id\">{{ item.label }}: </label>\n    <input\n      :type=\"item.type\"\n      :id=\"item.id\"\n      :name=\"item.id\"\n      v-model=\"item.value\"\n    />\n  </div>\n  <button type=\"submit\">Submit</button>\n</form>\n\nNotice how you can include autocomplete='on' on the form element and it will apply to all inputs in your form. You can also set different values for autocomplete attribute for each input.\n\nLabels\n​\n\nProvide labels to describe the purpose of all form control; linking for and id:\n\ntemplate\n<label for=\"name\">Name: </label>\n<input type=\"text\" name=\"name\" id=\"name\" v-model=\"name\" />\n\nIf you inspect this element in your Chrome DevTools and open the Accessibility tab inside the Elements tab, you will see how the input gets its name from the label:\n\nWarning:\n\nThough you might have seen labels wrapping the input fields like this:\n\ntemplate\n<label>\n  Name:\n  <input type=\"text\" name=\"name\" id=\"name\" v-model=\"name\" />\n</label>\n\nExplicitly setting the labels with a matching id is better supported by assistive technology.\n\naria-label\n​\n\nYou can also give the input an accessible name with aria-label.\n\ntemplate\n<label for=\"name\">Name: </label>\n<input\n  type=\"text\"\n  name=\"name\"\n  id=\"name\"\n  v-model=\"name\"\n  :aria-label=\"nameLabel\"\n/>\n\nFeel free to inspect this element in Chrome DevTools to see how the accessible name has changed:\n\naria-labelledby\n​\n\nUsing aria-labelledby is similar to aria-label except it is used if the label text is visible on screen. It is paired to other elements by their id and you can link multiple ids:\n\ntemplate\n<form\n  class=\"demo\"\n  action=\"/dataCollectionLocation\"\n  method=\"post\"\n  autocomplete=\"on\"\n>\n  <h1 id=\"billing\">Billing</h1>\n  <div class=\"form-item\">\n    <label for=\"name\">Name: </label>\n    <input\n      type=\"text\"\n      name=\"name\"\n      id=\"name\"\n      v-model=\"name\"\n      aria-labelledby=\"billing name\"\n    />\n  </div>\n  <button type=\"submit\">Submit</button>\n</form>\n\naria-describedby\n​\n\naria-describedby is used the same way as aria-labelledby except provides a description with additional information that the user might need. This can be used to describe the criteria for any input:\n\ntemplate\n<form\n  class=\"demo\"\n  action=\"/dataCollectionLocation\"\n  method=\"post\"\n  autocomplete=\"on\"\n>\n  <h1 id=\"billing\">Billing</h1>\n  <div class=\"form-item\">\n    <label for=\"name\">Full Name: </label>\n    <input\n      type=\"text\"\n      name=\"name\"\n      id=\"name\"\n      v-model=\"name\"\n      aria-labelledby=\"billing name\"\n      aria-describedby=\"nameDescription\"\n    />\n    <p id=\"nameDescription\">Please provide first and last name.</p>\n  </div>\n  <button type=\"submit\">Submit</button>\n</form>\n\nYou can see the description by inspecting Chrome DevTools:\n\nPlaceholder\n​\n\nAvoid using placeholders as they can confuse many users.\n\nOne of the issues with placeholders is that they don't meet the color contrast criteria by default; fixing the color contrast makes the placeholder look like pre-populated data in the input fields. Looking at the following example, you can see that the Last Name placeholder which meets the color contrast criteria looks like pre-populated data:\n\ntemplate\n<form\n  class=\"demo\"\n  action=\"/dataCollectionLocation\"\n  method=\"post\"\n  autocomplete=\"on\"\n>\n  <div v-for=\"item in formItems\" :key=\"item.id\" class=\"form-item\">\n    <label :for=\"item.id\">{{ item.label }}: </label>\n    <input\n      type=\"text\"\n      :id=\"item.id\"\n      :name=\"item.id\"\n      v-model=\"item.value\"\n      :placeholder=\"item.placeholder\"\n    />\n  </div>\n  <button type=\"submit\">Submit</button>\n</form>\ncss\n/* https://www.w3schools.com/howto/howto_css_placeholder.asp */\n\n#lastName::placeholder {\n  /* Chrome, Firefox, Opera, Safari 10.1+ */\n  color: black;\n  opacity: 1; /* Firefox */\n}\n\n#lastName:-ms-input-placeholder {\n  /* Internet Explorer 10-11 */\n  color: black;\n}\n\n#lastName::-ms-input-placeholder {\n  /* Microsoft Edge */\n  color: black;\n}\n\nIt is best to provide all the information the user needs to fill out forms outside any inputs.\n\nInstructions\n​\n\nWhen adding instructions for your input fields, make sure to link it correctly to the input. You can provide additional instructions and bind multiple ids inside an aria-labelledby. This allows for more flexible design.\n\ntemplate\n<fieldset>\n  <legend>Using aria-labelledby</legend>\n  <label id=\"date-label\" for=\"date\">Current Date: </label>\n  <input\n    type=\"date\"\n    name=\"date\"\n    id=\"date\"\n    aria-labelledby=\"date-label date-instructions\"\n  />\n  <p id=\"date-instructions\">MM/DD/YYYY</p>\n</fieldset>\n\nAlternatively, you can attach the instructions to the input with aria-describedby:\n\ntemplate\n<fieldset>\n  <legend>Using aria-describedby</legend>\n  <label id=\"dob\" for=\"dob\">Date of Birth: </label>\n  <input type=\"date\" name=\"dob\" id=\"dob\" aria-describedby=\"dob-instructions\" />\n  <p id=\"dob-instructions\">MM/DD/YYYY</p>\n</fieldset>\nHiding Content\n​\n\nUsually it is not recommended to visually hide labels, even if the input has an accessible name. However, if the functionality of the input can be understood with surrounding content, then we can hide the visual label.\n\nLet's look at this search field:\n\ntemplate\n<form role=\"search\">\n  <label for=\"search\" class=\"hidden-visually\">Search: </label>\n  <input type=\"text\" name=\"search\" id=\"search\" v-model=\"search\" />\n  <button type=\"submit\">Search</button>\n</form>\n\nWe can do this because the search button will help visual users identify the purpose of the input field.\n\nWe can use CSS to visually hide elements but keep them available for assistive technology:\n\ncss\n.hidden-visually {\n  position: absolute;\n  overflow: hidden;\n  white-space: nowrap;\n  margin: 0;\n  padding: 0;\n  height: 1px;\n  width: 1px;\n  clip: rect(0 0 0 0);\n  clip-path: inset(100%);\n}\naria-hidden=\"true\"\n​\n\nAdding aria-hidden=\"true\" will hide the element from assistive technology but leave it visually available for other users. Do not use it on focusable elements, purely on decorative, duplicated or offscreen content.\n\ntemplate\n<p>This is not hidden from screen readers.</p>\n<p aria-hidden=\"true\">This is hidden from screen readers.</p>\nButtons\n​\n\nWhen using buttons inside a form, you must set the type to prevent submitting the form. You can also use an input to create buttons:\n\ntemplate\n<form action=\"/dataCollectionLocation\" method=\"post\" autocomplete=\"on\">\n  <!-- Buttons -->\n  <button type=\"button\">Cancel</button>\n  <button type=\"submit\">Submit</button>\n\n  <!-- Input buttons -->\n  <input type=\"button\" value=\"Cancel\" />\n  <input type=\"submit\" value=\"Submit\" />\n</form>\nFunctional Images\n​\n\nYou can use this technique to create functional images.\n\nInput fields\n\nThese images will act as a submit type button on forms\ntemplate\n<form role=\"search\">\n  <label for=\"search\" class=\"hidden-visually\">Search: </label>\n  <input type=\"text\" name=\"search\" id=\"search\" v-model=\"search\" />\n  <input\n    type=\"image\"\n    class=\"btnImg\"\n    src=\"https://img.icons8.com/search\"\n    alt=\"Search\"\n  />\n</form>\n\nIcons\n\ntemplate\n<form role=\"search\">\n  <label for=\"searchIcon\" class=\"hidden-visually\">Search: </label>\n  <input type=\"text\" name=\"searchIcon\" id=\"searchIcon\" v-model=\"searchIcon\" />\n  <button type=\"submit\">\n    <i class=\"fas fa-search\" aria-hidden=\"true\"></i>\n    <span class=\"hidden-visually\">Search</span>\n  </button>\n</form>\nStandards\n​\n\nThe World Wide Web Consortium (W3C) Web Accessibility Initiative (WAI) develops web accessibility standards for the different components:\n\nUser Agent Accessibility Guidelines (UAAG)\nweb browsers and media players, including some aspects of assistive technologies\nAuthoring Tool Accessibility Guidelines (ATAG)\nauthoring tools\nWeb Content Accessibility Guidelines (WCAG)\nweb content - used by developers, authoring tools, and accessibility evaluation tools\nWeb Content Accessibility Guidelines (WCAG)\n​\n\nWCAG 2.1 extends on WCAG 2.0 and allows implementation of new technologies by addressing changes to the web. The W3C encourages use of the most current version of WCAG when developing or updating Web accessibility policies.\n\nWCAG 2.1 Four Main Guiding Principles (abbreviated as POUR):\n​\nPerceivable\nUsers must be able to perceive the information being presented\nOperable\nInterface forms, controls, and navigation are operable\nUnderstandable\nInformation and the operation of user interface must be understandable to all users\nRobust\nUsers must be able to access the content as technologies advance\nWeb Accessibility Initiative – Accessible Rich Internet Applications (WAI-ARIA)\n​\n\nW3C's WAI-ARIA provides guidance on how to build dynamic content and advanced user interface controls.\n\nAccessible Rich Internet Applications (WAI-ARIA) 1.2\nWAI-ARIA Authoring Practices 1.2\nResources\n​\nDocumentation\n​\nWCAG 2.0\nWCAG 2.1\nAccessible Rich Internet Applications (WAI-ARIA) 1.2\nWAI-ARIA Authoring Practices 1.2\nAssistive Technologies\n​\nScreen Readers\nNVDA\nVoiceOver\nJAWS\nChromeVox\nZooming Tools\nMAGic\nZoomText\nMagnifier\nTesting\n​\nAutomated Tools\nLighthouse\nWAVE\nARC Toolkit\nColor Tools\nWebAim Color Contrast\nWebAim Link Color Contrast\nOther Helpful Tools\nHeadingMap\nColor Oracle\nNerdeFocus\nVisual Aria\nSilktide Website Accessibility Simulator\nUsers\n​\n\nThe World Health Organization estimates that 15% of the world's population has some form of disability, 2-4% of them severely so. That is an estimated 1 billion people worldwide; making people with disabilities the largest minority group in the world.\n\nThere are a huge range of disabilities, which can be divided roughly into four categories:\n\nVisual - These users can benefit from the use of screen readers, screen magnification, controlling screen contrast, or braille display.\nAuditory - These users can benefit from captioning, transcripts or sign language video.\nMotor - These users can benefit from a range of assistive technologies for motor impairments: voice recognition software, eye tracking, single-switch access, head wand, sip and puff switch, oversized trackball mouse, adaptive keyboard or other assistive technologies.\nCognitive - These users can benefit from supplemental media, structural organization of content, clear and simple writing.\n\nCheck out the following links from WebAim to understand from users:\n\nWeb Accessibility Perspectives: Explore the Impact and Benefits for Everyone\nStories of Web Users\n\nEdit this page on GitHub\n\n Previous\nPerformance\nNext \nSecurity\nAccessibility has loaded"
  },
  {
    "title": "Performance | Vue.js",
    "url": "https://vuejs.org/guide/best-practices/performance",
    "html": "Skip to content\nGet 60% off a year of Vue Mastery courses\nGET DISCOUNT\nVue.js\nSearch\nCtrl\nK\nMain Navigation\nDocs\nAPI\nPlayground\nEcosystem\nAbout\nSponsor\nPartners\ngithub\ntwitter\ndiscord\nAPI Preference\nOptions\nComposition\n?\n\nAPI style now defaults to Composition API.\n\nSome pages contain different content based on the API style chosen. Use this switch to toggle between APIs styles.\n\nLearn moreGot it\n\nSidebar Navigation\nGetting Started\n\nIntroduction\n\nQuick Start\n\nEssentials\n\nCreating an Application\n\nTemplate Syntax\n\nReactivity Fundamentals\n\nComputed Properties\n\nClass and Style Bindings\n\nConditional Rendering\n\nList Rendering\n\nEvent Handling\n\nForm Input Bindings\n\nLifecycle Hooks\n\nWatchers\n\nTemplate Refs\n\nComponents Basics\n\nComponents In-Depth\n\nRegistration\n\nProps\n\nEvents\n\nComponent v-model\n\nFallthrough Attributes\n\nSlots\n\nProvide / inject\n\nAsync Components\n\nReusability\n\nComposables\n\nCustom Directives\n\nPlugins\n\nBuilt-in Components\n\nTransition\n\nTransitionGroup\n\nKeepAlive\n\nTeleport\n\nSuspense\n\nScaling Up\n\nSingle-File Components\n\nTooling\n\nRouting\n\nState Management\n\nTesting\n\nServer-Side Rendering (SSR)\n\nBest Practices\n\nProduction Deployment\n\nPerformance\n\nAccessibility\n\nSecurity\n\nTypeScript\n\nOverview\n\nTS with Composition API\n\nTS with Options API\n\nExtra Topics\n\nWays of Using Vue\n\nComposition API FAQ\n\nReactivity in Depth\n\nRendering Mechanism\n\nRender Functions & JSX\n\nVue and Web Components\n\nAnimation Techniques\n\nON THIS PAGE\nTable of Contents for current page\nOverview\nProfiling Options\nPage Load Optimizations\nChoosing the Right Architecture\nBundle Size and Tree-shaking\nCode Splitting\nUpdate Optimizations\nProps Stability\nv-once\nv-memo\nComputed Stability\nGeneral Optimizations\nVirtualize Large Lists\nReduce Reactivity Overhead for Large Immutable Structures\nAvoid Unnecessary Component Abstractions\nSPONSORS\nBecome a Sponsor\nGet a complete overview on all your web app’s security issues in just a few minutes. Start free.\nADS VIA CARBON\nPerformance\n​\nOverview\n​\n\nVue is designed to be performant for most common use cases without much need for manual optimizations. However, there are always challenging scenarios where extra fine-tuning is needed. In this section, we will discuss what you should pay attention to when it comes to performance in a Vue application.\n\nFirst, let's discuss the two major aspects of web performance:\n\nPage Load Performance: how fast the application shows content and becomes interactive on the initial visit. This is usually measured using web vital metrics like Largest Contentful Paint (LCP) and First Input Delay (FID).\n\nUpdate Performance: how fast the application updates in response to user input. For example, how fast a list updates when the user types in a search box, or how fast the page switches when the user clicks a navigation link in a Single-Page Application (SPA).\n\nWhile it would be ideal to maximize both, different frontend architectures tend to affect how easy it is to attain desired performance in these aspects. In addition, the type of application you are building greatly influences what you should prioritize in terms of performance. Therefore, the first step of ensuring optimal performance is picking the right architecture for the type of application you are building:\n\nConsult Ways of Using Vue to see how you can leverage Vue in different ways.\n\nJason Miller discusses the types of web applications and their respective ideal implementation / delivery in Application Holotypes.\n\nProfiling Options\n​\n\nTo improve performance, we need to first know how to measure it. There are a number of great tools that can help in this regard:\n\nFor profiling load performance of production deployments:\n\nPageSpeed Insights\nWebPageTest\n\nFor profiling performance during local development:\n\nChrome DevTools Performance Panel\napp.config.performance enables Vue-specific performance markers in Chrome DevTools' performance timeline.\nVue DevTools Extension also provides a performance profiling feature.\nPage Load Optimizations\n​\n\nThere are many framework-agnostic aspects for optimizing page load performance - check out this web.dev guide for a comprehensive round up. Here, we will primarily focus on techniques that are specific to Vue.\n\nChoosing the Right Architecture\n​\n\nIf your use case is sensitive to page load performance, avoid shipping it as a pure client-side SPA. You want your server to be directly sending HTML containing the content the users want to see. Pure client-side rendering suffers from slow time-to-content. This can be mitigated with Server-Side Rendering (SSR) or Static Site Generation (SSG). Check out the SSR Guide to learn about performing SSR with Vue. If your app doesn't have rich interactivity requirements, you can also use a traditional backend server to render the HTML and enhance it with Vue on the client.\n\nIf your main application has to be an SPA, but has marketing pages (landing, about, blog), ship them separately! Your marketing pages should ideally be deployed as static HTML with minimal JS, by using SSG.\n\nBundle Size and Tree-shaking\n​\n\nOne of the most effective ways to improve page load performance is shipping smaller JavaScript bundles. Here are a few ways to reduce bundle size when using Vue:\n\nUse a build step if possible.\n\nMany of Vue's APIs are \"tree-shakable\" if bundled via a modern build tool. For example, if you don't use the built-in <Transition> component, it won't be included in the final production bundle. Tree-shaking can also remove other unused modules in your source code.\n\nWhen using a build step, templates are pre-compiled so we don't need to ship the Vue compiler to the browser. This saves 14kb min+gzipped JavaScript and avoids the runtime compilation cost.\n\nBe cautious of size when introducing new dependencies! In real-world applications, bloated bundles are most often a result of introducing heavy dependencies without realizing it.\n\nIf using a build step, prefer dependencies that offer ES module formats and are tree-shaking friendly. For example, prefer lodash-es over lodash.\n\nCheck a dependency's size and evaluate whether it is worth the functionality it provides. Note if the dependency is tree-shaking friendly, the actual size increase will depend on the APIs you actually import from it. Tools like bundlejs.com can be used for quick checks, but measuring with your actual build setup will always be the most accurate.\n\nIf you are using Vue primarily for progressive enhancement and prefer to avoid a build step, consider using petite-vue (only 6kb) instead.\n\nCode Splitting\n​\n\nCode splitting is where a build tool splits the application bundle into multiple smaller chunks, which can then be loaded on demand or in parallel. With proper code splitting, features required at page load can be downloaded immediately, with additional chunks being lazy loaded only when needed, thus improving performance.\n\nBundlers like Rollup (which Vite is based upon) or webpack can automatically create split chunks by detecting the ESM dynamic import syntax:\n\njs\n// lazy.js and its dependencies will be split into a separate chunk\n// and only loaded when `loadLazy()` is called.\nfunction loadLazy() {\n  return import('./lazy.js')\n}\n\nLazy loading is best used on features that are not immediately needed after initial page load. In Vue applications, this can be used in combination with Vue's Async Component feature to create split chunks for component trees:\n\njs\nimport { defineAsyncComponent } from 'vue'\n\n// a separate chunk is created for Foo.vue and its dependencies.\n// it is only fetched on demand when the async component is\n// rendered on the page.\nconst Foo = defineAsyncComponent(() => import('./Foo.vue'))\n\nFor applications using Vue Router, it is strongly recommended to use lazy loading for route components. Vue Router has explicit support for lazy loading, separate from defineAsyncComponent. See Lazy Loading Routes for more details.\n\nUpdate Optimizations\n​\nProps Stability\n​\n\nIn Vue, a child component only updates when at least one of its received props has changed. Consider the following example:\n\ntemplate\n<ListItem\n  v-for=\"item in list\"\n  :id=\"item.id\"\n  :active-id=\"activeId\" />\n\nInside the <ListItem> component, it uses its id and activeId props to determine whether it is the currently active item. While this works, the problem is that whenever activeId changes, every <ListItem> in the list has to update!\n\nIdeally, only the items whose active status changed should update. We can achieve that by moving the active status computation into the parent, and make <ListItem> directly accept an active prop instead:\n\ntemplate\n<ListItem\n  v-for=\"item in list\"\n  :id=\"item.id\"\n  :active=\"item.id === activeId\" />\n\nNow, for most components the active prop will remain the same when activeId changes, so they no longer need to update. In general, the idea is keeping the props passed to child components as stable as possible.\n\nv-once\n​\n\nv-once is a built-in directive that can be used to render content that relies on runtime data but never needs to update. The entire sub-tree it is used on will be skipped for all future updates. Consult its API reference for more details.\n\nv-memo\n​\n\nv-memo is a built-in directive that can be used to conditionally skip the update of large sub-trees or v-for lists. Consult its API reference for more details.\n\nComputed Stability \n​\n\nStarting in 3.4, a computed property will only trigger effects when its computed value has changed from the previous one. For example, the following isEven computed only triggers effects if the returned value has changed from true to false, or vice-versa:\n\njs\nconst count = ref(0)\nconst isEven = computed(() => count.value % 2 === 0)\n\nwatchEffect(() => console.log(isEven.value)) // true\n\n// will not trigger new logs because the computed value stays `true`\ncount.value = 2\ncount.value = 4\n\nThis reduces unnecessary effect triggers, but unfortunately doesn't work if the computed creates a new object on each compute:\n\njs\nconst computedObj = computed(() => {\n  return {\n    isEven: count.value % 2 === 0\n  }\n})\n\nBecause a new object is created each time, the new value is technically always different from the old value. Even if the isEven property remains the same, Vue won't be able to know unless it performs a deep comparison of the old value and the new value. Such comparison could be expensive and likely not worth it.\n\nInstead, we can optimize this by manually comparing the new value with the old value, and conditionally returning the old value if we know nothing has changed:\n\njs\nconst computedObj = computed((oldValue) => {\n  const newValue = {\n    isEven: count.value % 2 === 0\n  }\n  if (oldValue && oldValue.isEven === newValue.isEven) {\n    return oldValue\n  }\n  return newValue\n})\n\nTry it in the playground\n\nNote that you should always perform the full computation before comparing and returning the old value, so that the same dependencies can be collected on every run.\n\nGeneral Optimizations\n​\n\nThe following tips affect both page load and update performance.\n\nVirtualize Large Lists\n​\n\nOne of the most common performance issues in all frontend applications is rendering large lists. No matter how performant a framework is, rendering a list with thousands of items will be slow due to the sheer number of DOM nodes that the browser needs to handle.\n\nHowever, we don't necessarily have to render all these nodes upfront. In most cases, the user's screen size can display only a small subset of our large list. We can greatly improve the performance with list virtualization, the technique of only rendering the items that are currently in or close to the viewport in a large list.\n\nImplementing list virtualization isn't easy, luckily there are existing community libraries that you can directly use:\n\nvue-virtual-scroller\nvue-virtual-scroll-grid\nvueuc/VVirtualList\nReduce Reactivity Overhead for Large Immutable Structures\n​\n\nVue's reactivity system is deep by default. While this makes state management intuitive, it does create a certain level of overhead when the data size is large, because every property access triggers proxy traps that perform dependency tracking. This typically becomes noticeable when dealing with large arrays of deeply nested objects, where a single render needs to access 100,000+ properties, so it should only affect very specific use cases.\n\nVue does provide an escape hatch to opt-out of deep reactivity by using shallowRef() and shallowReactive(). Shallow APIs create state that is reactive only at the root level, and exposes all nested objects untouched. This keeps nested property access fast, with the trade-off being that we must now treat all nested objects as immutable, and updates can only be triggered by replacing the root state:\n\njs\nconst shallowArray = shallowRef([\n  /* big list of deep objects */\n])\n\n// this won't trigger updates...\nshallowArray.value.push(newObject)\n// this does:\nshallowArray.value = [...shallowArray.value, newObject]\n\n// this won't trigger updates...\nshallowArray.value[0].foo = 1\n// this does:\nshallowArray.value = [\n  {\n    ...shallowArray.value[0],\n    foo: 1\n  },\n  ...shallowArray.value.slice(1)\n]\nAvoid Unnecessary Component Abstractions\n​\n\nSometimes we may create renderless components or higher-order components (i.e. components that render other components with extra props) for better abstraction or code organization. While there is nothing wrong with this, do keep in mind that component instances are much more expensive than plain DOM nodes, and creating too many of them due to abstraction patterns will incur performance costs.\n\nNote that reducing only a few instances won't have noticeable effect, so don't sweat it if the component is rendered only a few times in the app. The best scenario to consider this optimization is again in large lists. Imagine a list of 100 items where each item component contains many child components. Removing one unnecessary component abstraction here could result in a reduction of hundreds of component instances.\n\nEdit this page on GitHub\n\n Previous\nProduction Deployment\nNext \nAccessibility\nPerformance has loaded"
  },
  {
    "title": "Production Deployment | Vue.js",
    "url": "https://vuejs.org/guide/best-practices/production-deployment",
    "html": "Skip to content\nGet 60% off a year of Vue Mastery courses\nGET DISCOUNT\nVue.js\nSearch\nCtrl\nK\nMain Navigation\nDocs\nAPI\nPlayground\nEcosystem\nAbout\nSponsor\nPartners\ngithub\ntwitter\ndiscord\nAPI Preference\nOptions\nComposition\n?\n\nAPI style now defaults to Composition API.\n\nSome pages contain different content based on the API style chosen. Use this switch to toggle between APIs styles.\n\nLearn moreGot it\n\nSidebar Navigation\nGetting Started\n\nIntroduction\n\nQuick Start\n\nEssentials\n\nCreating an Application\n\nTemplate Syntax\n\nReactivity Fundamentals\n\nComputed Properties\n\nClass and Style Bindings\n\nConditional Rendering\n\nList Rendering\n\nEvent Handling\n\nForm Input Bindings\n\nLifecycle Hooks\n\nWatchers\n\nTemplate Refs\n\nComponents Basics\n\nComponents In-Depth\n\nRegistration\n\nProps\n\nEvents\n\nComponent v-model\n\nFallthrough Attributes\n\nSlots\n\nProvide / inject\n\nAsync Components\n\nReusability\n\nComposables\n\nCustom Directives\n\nPlugins\n\nBuilt-in Components\n\nTransition\n\nTransitionGroup\n\nKeepAlive\n\nTeleport\n\nSuspense\n\nScaling Up\n\nSingle-File Components\n\nTooling\n\nRouting\n\nState Management\n\nTesting\n\nServer-Side Rendering (SSR)\n\nBest Practices\n\nProduction Deployment\n\nPerformance\n\nAccessibility\n\nSecurity\n\nTypeScript\n\nOverview\n\nTS with Composition API\n\nTS with Options API\n\nExtra Topics\n\nWays of Using Vue\n\nComposition API FAQ\n\nReactivity in Depth\n\nRendering Mechanism\n\nRender Functions & JSX\n\nVue and Web Components\n\nAnimation Techniques\n\nON THIS PAGE\nTable of Contents for current page\nDevelopment vs. Production\nWithout Build Tools\nWith Build Tools\nTracking Runtime Errors\nSPONSORS\nBecome a Sponsor\nMinimise attack area with Intel® Xeon® powered servers equipped with Intel® SGX\nADS VIA CARBON\nProduction Deployment\n​\nDevelopment vs. Production\n​\n\nDuring development, Vue provides a number of features to improve the development experience:\n\nWarning for common errors and pitfalls\nProps / events validation\nReactivity debugging hooks\nDevtools integration\n\nHowever, these features become useless in production. Some of the warning checks can also incur a small amount of performance overhead. When deploying to production, we should drop all the unused, development-only code branches for smaller payload size and better performance.\n\nWithout Build Tools\n​\n\nIf you are using Vue without a build tool by loading it from a CDN or self-hosted script, make sure to use the production build (dist files that end in .prod.js) when deploying to production. Production builds are pre-minified with all development-only code branches removed.\n\nIf using global build (accessing via the Vue global): use vue.global.prod.js.\nIf using ESM build (accessing via native ESM imports): use vue.esm-browser.prod.js.\n\nConsult the dist file guide for more details.\n\nWith Build Tools\n​\n\nProjects scaffolded via create-vue (based on Vite) or Vue CLI (based on webpack) are pre-configured for production builds.\n\nIf using a custom setup, make sure that:\n\nvue resolves to vue.runtime.esm-bundler.js.\nThe compile time feature flags are properly configured.\nprocess.env.NODE_ENV is replaced with \"production\" during build.\n\nAdditional references:\n\nVite production build guide\nVite deployment guide\nVue CLI deployment guide\nTracking Runtime Errors\n​\n\nThe app-level error handler can be used to report errors to tracking services:\n\njs\nimport { createApp } from 'vue'\n\nconst app = createApp(...)\n\napp.config.errorHandler = (err, instance, info) => {\n  // report error to tracking services\n}\n\nServices such as Sentry and Bugsnag also provide official integrations for Vue.\n\nEdit this page on GitHub\n\n Previous\nServer-Side Rendering (SSR)\nNext \nPerformance\nProduction Deployment has loaded"
  },
  {
    "title": "Server-Side Rendering (SSR) | Vue.js",
    "url": "https://vuejs.org/guide/scaling-up/ssr",
    "html": "Skip to content\nGet 60% off a year of Vue Mastery courses\nGET DISCOUNT\nVue.js\nSearch\nCtrl\nK\nMain Navigation\nDocs\nAPI\nPlayground\nEcosystem\nAbout\nSponsor\nPartners\ngithub\ntwitter\ndiscord\nAPI Preference\nOptions\nComposition\n?\n\nAPI style now defaults to Composition API.\n\nSome pages contain different content based on the API style chosen. Use this switch to toggle between APIs styles.\n\nLearn moreGot it\n\nSidebar Navigation\nGetting Started\n\nIntroduction\n\nQuick Start\n\nEssentials\n\nCreating an Application\n\nTemplate Syntax\n\nReactivity Fundamentals\n\nComputed Properties\n\nClass and Style Bindings\n\nConditional Rendering\n\nList Rendering\n\nEvent Handling\n\nForm Input Bindings\n\nLifecycle Hooks\n\nWatchers\n\nTemplate Refs\n\nComponents Basics\n\nComponents In-Depth\n\nRegistration\n\nProps\n\nEvents\n\nComponent v-model\n\nFallthrough Attributes\n\nSlots\n\nProvide / inject\n\nAsync Components\n\nReusability\n\nComposables\n\nCustom Directives\n\nPlugins\n\nBuilt-in Components\n\nTransition\n\nTransitionGroup\n\nKeepAlive\n\nTeleport\n\nSuspense\n\nScaling Up\n\nSingle-File Components\n\nTooling\n\nRouting\n\nState Management\n\nTesting\n\nServer-Side Rendering (SSR)\n\nBest Practices\n\nProduction Deployment\n\nPerformance\n\nAccessibility\n\nSecurity\n\nTypeScript\n\nOverview\n\nTS with Composition API\n\nTS with Options API\n\nExtra Topics\n\nWays of Using Vue\n\nComposition API FAQ\n\nReactivity in Depth\n\nRendering Mechanism\n\nRender Functions & JSX\n\nVue and Web Components\n\nAnimation Techniques\n\nON THIS PAGE\nTable of Contents for current page\nOverview\nWhat is SSR?\nWhy SSR?\nSSR vs. SSG\nBasic Tutorial\nRendering an App\nClient Hydration\nCode Structure\nHigher Level Solutions\nNuxt\nQuasar\nVite SSR\nWriting SSR-friendly Code\nReactivity on the Server\nComponent Lifecycle Hooks\nAccess to Platform-Specific APIs\nCross-Request State Pollution\nHydration Mismatch\nCustom Directives\nTeleports\nSPONSORS\nBecome a Sponsor\nHow do passkeys increase user security and how can you use them? Find out in our free white paper\nADS VIA CARBON\nServer-Side Rendering (SSR)\n​\nOverview\n​\nWhat is SSR?\n​\n\nVue.js is a framework for building client-side applications. By default, Vue components produce and manipulate DOM in the browser as output. However, it is also possible to render the same components into HTML strings on the server, send them directly to the browser, and finally \"hydrate\" the static markup into a fully interactive app on the client.\n\nA server-rendered Vue.js app can also be considered \"isomorphic\" or \"universal\", in the sense that the majority of your app's code runs on both the server and the client.\n\nWhy SSR?\n​\n\nCompared to a client-side Single-Page Application (SPA), the advantage of SSR primarily lies in:\n\nFaster time-to-content: this is more prominent on slow internet or slow devices. Server-rendered markup doesn't need to wait until all JavaScript has been downloaded and executed to be displayed, so your user will see a fully-rendered page sooner. In addition, data fetching is done on the server-side for the initial visit, which likely has a faster connection to your database than the client. This generally results in improved Core Web Vitals metrics, better user experience, and can be critical for applications where time-to-content is directly associated with conversion rate.\n\nUnified mental model: you get to use the same language and the same declarative, component-oriented mental model for developing your entire app, instead of jumping back and forth between a backend templating system and a frontend framework.\n\nBetter SEO: the search engine crawlers will directly see the fully rendered page.\n\nTIP\n\nAs of now, Google and Bing can index synchronous JavaScript applications just fine. Synchronous being the key word there. If your app starts with a loading spinner, then fetches content via Ajax, the crawler will not wait for you to finish. This means if you have content fetched asynchronously on pages where SEO is important, SSR might be necessary.\n\nThere are also some trade-offs to consider when using SSR:\n\nDevelopment constraints. Browser-specific code can only be used inside certain lifecycle hooks; some external libraries may need special treatment to be able to run in a server-rendered app.\n\nMore involved build setup and deployment requirements. Unlike a fully static SPA that can be deployed on any static file server, a server-rendered app requires an environment where a Node.js server can run.\n\nMore server-side load. Rendering a full app in Node.js is going to be more CPU-intensive than just serving static files, so if you expect high traffic, be prepared for corresponding server load and wisely employ caching strategies.\n\nBefore using SSR for your app, the first question you should ask is whether you actually need it. It mostly depends on how important time-to-content is for your app. For example, if you are building an internal dashboard where an extra few hundred milliseconds on initial load doesn't matter that much, SSR would be an overkill. However, in cases where time-to-content is absolutely critical, SSR can help you achieve the best possible initial load performance.\n\nSSR vs. SSG\n​\n\nStatic Site Generation (SSG), also referred to as pre-rendering, is another popular technique for building fast websites. If the data needed to server-render a page is the same for every user, then instead of rendering the page every time a request comes in, we can render it only once, ahead of time, during the build process. Pre-rendered pages are generated and served as static HTML files.\n\nSSG retains the same performance characteristics of SSR apps: it provides great time-to-content performance. At the same time, it is cheaper and easier to deploy than SSR apps because the output is static HTML and assets. The keyword here is static: SSG can only be applied to pages consuming static data, i.e. data that is known at build time and does not change between deploys. Every time the data changes, a new deployment is needed.\n\nIf you're only investigating SSR to improve the SEO of a handful of marketing pages (e.g. /, /about, /contact, etc.), then you probably want SSG instead of SSR. SSG is also great for content-based websites such as documentation sites or blogs. In fact, this website you are reading right now is statically generated using VitePress, a Vue-powered static site generator.\n\nBasic Tutorial\n​\nRendering an App\n​\n\nLet's take a look at the most bare-bones example of Vue SSR in action.\n\nCreate a new directory and cd into it\nRun npm init -y\nAdd \"type\": \"module\" in package.json so that Node.js runs in ES modules mode.\nRun npm install vue\nCreate an example.js file:\njs\n// this runs in Node.js on the server.\nimport { createSSRApp } from 'vue'\n// Vue's server-rendering API is exposed under `vue/server-renderer`.\nimport { renderToString } from 'vue/server-renderer'\n\nconst app = createSSRApp({\n  data: () => ({ count: 1 }),\n  template: `<button @click=\"count++\">{{ count }}</button>`\n})\n\nrenderToString(app).then((html) => {\n  console.log(html)\n})\n\nThen run:\n\nsh\n> node example.js\n\nIt should print the following to the command line:\n\n<button>1</button>\n\nrenderToString() takes a Vue app instance and returns a Promise that resolves to the rendered HTML of the app. It is also possible to stream rendering using the Node.js Stream API or Web Streams API. Check out the SSR API Reference for full details.\n\nWe can then move the Vue SSR code into a server request handler, which wraps the application markup with the full page HTML. We will be using express for the next steps:\n\nRun npm install express\nCreate the following server.js file:\njs\nimport express from 'express'\nimport { createSSRApp } from 'vue'\nimport { renderToString } from 'vue/server-renderer'\n\nconst server = express()\n\nserver.get('/', (req, res) => {\n  const app = createSSRApp({\n    data: () => ({ count: 1 }),\n    template: `<button @click=\"count++\">{{ count }}</button>`\n  })\n\n  renderToString(app).then((html) => {\n    res.send(`\n    <!DOCTYPE html>\n    <html>\n      <head>\n        <title>Vue SSR Example</title>\n      </head>\n      <body>\n        <div id=\"app\">${html}</div>\n      </body>\n    </html>\n    `)\n  })\n})\n\nserver.listen(3000, () => {\n  console.log('ready')\n})\n\nFinally, run node server.js and visit http://localhost:3000. You should see the page working with the button.\n\nTry it on StackBlitz\n\nClient Hydration\n​\n\nIf you click the button, you'll notice the number doesn't change. The HTML is completely static on the client since we are not loading Vue in the browser.\n\nTo make the client-side app interactive, Vue needs to perform the hydration step. During hydration, it creates the same Vue application that was run on the server, matches each component to the DOM nodes it should control, and attaches DOM event listeners.\n\nTo mount an app in hydration mode, we need to use createSSRApp() instead of createApp():\n\njs\n// this runs in the browser.\nimport { createSSRApp } from 'vue'\n\nconst app = createSSRApp({\n  // ...same app as on server\n})\n\n// mounting an SSR app on the client assumes\n// the HTML was pre-rendered and will perform\n// hydration instead of mounting new DOM nodes.\napp.mount('#app')\nCode Structure\n​\n\nNotice how we need to reuse the same app implementation as on the server. This is where we need to start thinking about code structure in an SSR app - how do we share the same application code between the server and the client?\n\nHere we will demonstrate the most bare-bones setup. First, let's split the app creation logic into a dedicated file, app.js:\n\njs\n// app.js (shared between server and client)\nimport { createSSRApp } from 'vue'\n\nexport function createApp() {\n  return createSSRApp({\n    data: () => ({ count: 1 }),\n    template: `<button @click=\"count++\">{{ count }}</button>`\n  })\n}\n\nThis file and its dependencies are shared between the server and the client - we call them universal code. There are a number of things you need to pay attention to when writing universal code, as we will discuss below.\n\nOur client entry imports the universal code, creates the app, and performs the mount:\n\njs\n// client.js\nimport { createApp } from './app.js'\n\ncreateApp().mount('#app')\n\nAnd the server uses the same app creation logic in the request handler:\n\njs\n// server.js (irrelevant code omitted)\nimport { createApp } from './app.js'\n\nserver.get('/', (req, res) => {\n  const app = createApp()\n  renderToString(app).then(html => {\n    // ...\n  })\n})\n\nIn addition, in order to load the client files in the browser, we also need to:\n\nServe client files by adding server.use(express.static('.')) in server.js.\nLoad the client entry by adding <script type=\"module\" src=\"/client.js\"></script> to the HTML shell.\nSupport usage like import * from 'vue' in the browser by adding an Import Map to the HTML shell.\n\nTry the completed example on StackBlitz. The button is now interactive!\n\nHigher Level Solutions\n​\n\nMoving from the example to a production-ready SSR app involves a lot more. We will need to:\n\nSupport Vue SFCs and other build step requirements. In fact, we will need to coordinate two builds for the same app: one for the client, and one for the server.\n\nTIP\n\nVue components are compiled differently when used for SSR - templates are compiled into string concatenations instead of Virtual DOM render functions for more efficient rendering performance.\n\nIn the server request handler, render the HTML with the correct client-side asset links and optimal resource hints. We may also need to switch between SSR and SSG mode, or even mix both in the same app.\n\nManage routing, data fetching, and state management stores in a universal manner.\n\nA complete implementation would be quite complex and depends on the build toolchain you have chosen to work with. Therefore, we highly recommend going with a higher-level, opinionated solution that abstracts away the complexity for you. Below we will introduce a few recommended SSR solutions in the Vue ecosystem.\n\nNuxt\n​\n\nNuxt is a higher-level framework built on top of the Vue ecosystem which provides a streamlined development experience for writing universal Vue applications. Better yet, you can also use it as a static site generator! We highly recommend giving it a try.\n\nQuasar\n​\n\nQuasar is a complete Vue-based solution that allows you to target SPA, SSR, PWA, mobile app, desktop app, and browser extension all using one codebase. It not only handles the build setup, but also provides a full collection of Material Design compliant UI components.\n\nVite SSR\n​\n\nVite provides built-in support for Vue server-side rendering, but it is intentionally low-level. If you wish to go directly with Vite, check out vite-plugin-ssr, a community plugin that abstracts away many challenging details for you.\n\nYou can also find an example Vue + Vite SSR project using manual setup here, which can serve as a base to build upon. Note this is only recommended if you are experienced with SSR / build tools and really want to have complete control over the higher-level architecture.\n\nWriting SSR-friendly Code\n​\n\nRegardless of your build setup or higher-level framework choice, there are some principles that apply in all Vue SSR applications.\n\nReactivity on the Server\n​\n\nDuring SSR, each request URL maps to a desired state of our application. There is no user interaction and no DOM updates, so reactivity is unnecessary on the server. By default, reactivity is disabled during SSR for better performance.\n\nComponent Lifecycle Hooks\n​\n\nSince there are no dynamic updates, lifecycle hooks such as onMounted or onUpdated will NOT be called during SSR and will only be executed on the client.\n\nYou should avoid code that produces side effects that need cleanup in setup() or the root scope of <script setup>. An example of such side effects is setting up timers with setInterval. In client-side only code we may setup a timer and then tear it down in onBeforeUnmount or onUnmounted. However, because the unmount hooks will never be called during SSR, the timers will stay around forever. To avoid this, move your side-effect code into onMounted instead.\n\nAccess to Platform-Specific APIs\n​\n\nUniversal code cannot assume access to platform-specific APIs, so if your code directly uses browser-only globals like window or document, they will throw errors when executed in Node.js, and vice-versa.\n\nFor tasks that are shared between server and client but with different platform APIs, it's recommended to wrap the platform-specific implementations inside a universal API, or use libraries that do this for you. For example, you can use node-fetch to use the same fetch API on both server and client.\n\nFor browser-only APIs, the common approach is to lazily access them inside client-only lifecycle hooks such as onMounted.\n\nNote that if a third-party library is not written with universal usage in mind, it could be tricky to integrate it into a server-rendered app. You might be able to get it working by mocking some of the globals, but it would be hacky and may interfere with the environment detection code of other libraries.\n\nCross-Request State Pollution\n​\n\nIn the State Management chapter, we introduced a simple state management pattern using Reactivity APIs. In an SSR context, this pattern requires some additional adjustments.\n\nThe pattern declares shared state in a JavaScript module's root scope. This makes them singletons - i.e. there is only one instance of the reactive object throughout the entire lifecycle of our application. This works as expected in a pure client-side Vue application, since the modules in our application are initialized fresh for each browser page visit.\n\nHowever, in an SSR context, the application modules are typically initialized only once on the server, when the server boots up. The same module instances will be reused across multiple server requests, and so will our singleton state objects. If we mutate the shared singleton state with data specific to one user, it can be accidentally leaked to a request from another user. We call this cross-request state pollution.\n\nWe can technically re-initialize all the JavaScript modules on each request, just like we do in browsers. However, initializing JavaScript modules can be costly, so this would significantly affect server performance.\n\nThe recommended solution is to create a new instance of the entire application - including the router and global stores - on each request. Then, instead of directly importing it in our components, we provide the shared state using app-level provide and inject it in components that need it:\n\njs\n// app.js (shared between server and client)\nimport { createSSRApp } from 'vue'\nimport { createStore } from './store.js'\n\n// called on each request\nexport function createApp() {\n  const app = createSSRApp(/* ... */)\n  // create new instance of store per request\n  const store = createStore(/* ... */)\n  // provide store at the app level\n  app.provide('store', store)\n  // also expose store for hydration purposes\n  return { app, store }\n}\n\nState Management libraries like Pinia are designed with this in mind. Consult Pinia's SSR guide for more details.\n\nHydration Mismatch\n​\n\nIf the DOM structure of the pre-rendered HTML does not match the expected output of the client-side app, there will be a hydration mismatch error. Hydration mismatch is most commonly introduced by the following causes:\n\nThe template contains invalid HTML nesting structure, and the rendered HTML got \"corrected\" by the browser's native HTML parsing behavior. For example, a common gotcha is that <div> cannot be placed inside <p>:\n\nhtml\n<p><div>hi</div></p>\n\nIf we produce this in our server-rendered HTML, the browser will terminate the first <p> when <div> is encountered and parse it into the following DOM structure:\n\nhtml\n<p></p>\n<div>hi</div>\n<p></p>\n\nThe data used during render contains randomly generated values. Since the same application will run twice - once on the server, and once on the client - the random values are not guaranteed to be the same between the two runs. There are two ways to avoid random-value-induced mismatches:\n\nUse v-if + onMounted to render the part that depends on random values only on the client. Your framework may also have built-in features to make this easier, for example the <ClientOnly> component in VitePress.\n\nUse a random number generator library that supports generating with seeds, and guarantee the server run and the client run are using the same seed (e.g. by including the seed in serialized state and retrieving it on the client).\n\nThe server and the client are in different time zones. Sometimes, we may want to convert a timestamp into the user's local time. However, the timezone during the server run and the timezone during the client run are not always the same, and we may not reliably know the user's timezone during the server run. In such cases, the local time conversion should also be performed as a client-only operation.\n\nWhen Vue encounters a hydration mismatch, it will attempt to automatically recover and adjust the pre-rendered DOM to match the client-side state. This will lead to some rendering performance loss due to incorrect nodes being discarded and new nodes being mounted, but in most cases, the app should continue to work as expected. That said, it is still best to eliminate hydration mismatches during development.\n\nCustom Directives\n​\n\nSince most custom directives involve direct DOM manipulation, they are ignored during SSR. However, if you want to specify how a custom directive should be rendered (i.e. what attributes it should add to the rendered element), you can use the getSSRProps directive hook:\n\njs\nconst myDirective = {\n  mounted(el, binding) {\n    // client-side implementation:\n    // directly update the DOM\n    el.id = binding.value\n  },\n  getSSRProps(binding) {\n    // server-side implementation:\n    // return the props to be rendered.\n    // getSSRProps only receives the directive binding.\n    return {\n      id: binding.value\n    }\n  }\n}\nTeleports\n​\n\nTeleports require special handling during SSR. If the rendered app contains Teleports, the teleported content will not be part of the rendered string. An easier solution is to conditionally render the Teleport on mount.\n\nIf you do need to hydrate teleported content, they are exposed under the teleports property of the ssr context object:\n\njs\nconst ctx = {}\nconst html = await renderToString(app, ctx)\n\nconsole.log(ctx.teleports) // { '#teleported': 'teleported content' }\n\nYou need to inject the teleport markup into the correct location in your final page HTML similar to how you need to inject the main app markup.\n\nTIP\n\nAvoid targeting body when using Teleports and SSR together - usually, <body> will contain other server-rendered content which makes it impossible for Teleports to determine the correct starting location for hydration.\n\nInstead, prefer a dedicated container, e.g. <div id=\"teleported\"></div> which contains only teleported content.\n\nEdit this page on GitHub\n\n Previous\nTesting\nNext \nProduction Deployment\nServer-Side Rendering (SSR) has loaded"
  },
  {
    "title": "Testing | Vue.js",
    "url": "https://vuejs.org/guide/scaling-up/testing",
    "html": "Skip to content\nGet 60% off a year of Vue Mastery courses\nGET DISCOUNT\nVue.js\nSearch\nCtrl\nK\nMain Navigation\nDocs\nAPI\nPlayground\nEcosystem\nAbout\nSponsor\nPartners\ngithub\ntwitter\ndiscord\nAPI Preference\nOptions\nComposition\n?\n\nAPI style now defaults to Composition API.\n\nSome pages contain different content based on the API style chosen. Use this switch to toggle between APIs styles.\n\nLearn moreGot it\n\nSidebar Navigation\nGetting Started\n\nIntroduction\n\nQuick Start\n\nEssentials\n\nCreating an Application\n\nTemplate Syntax\n\nReactivity Fundamentals\n\nComputed Properties\n\nClass and Style Bindings\n\nConditional Rendering\n\nList Rendering\n\nEvent Handling\n\nForm Input Bindings\n\nLifecycle Hooks\n\nWatchers\n\nTemplate Refs\n\nComponents Basics\n\nComponents In-Depth\n\nRegistration\n\nProps\n\nEvents\n\nComponent v-model\n\nFallthrough Attributes\n\nSlots\n\nProvide / inject\n\nAsync Components\n\nReusability\n\nComposables\n\nCustom Directives\n\nPlugins\n\nBuilt-in Components\n\nTransition\n\nTransitionGroup\n\nKeepAlive\n\nTeleport\n\nSuspense\n\nScaling Up\n\nSingle-File Components\n\nTooling\n\nRouting\n\nState Management\n\nTesting\n\nServer-Side Rendering (SSR)\n\nBest Practices\n\nProduction Deployment\n\nPerformance\n\nAccessibility\n\nSecurity\n\nTypeScript\n\nOverview\n\nTS with Composition API\n\nTS with Options API\n\nExtra Topics\n\nWays of Using Vue\n\nComposition API FAQ\n\nReactivity in Depth\n\nRendering Mechanism\n\nRender Functions & JSX\n\nVue and Web Components\n\nAnimation Techniques\n\nON THIS PAGE\nTable of Contents for current page\nWhy Test?\nWhen to Test\nTesting Types\nOverview\nUnit Testing\nComponent Testing\nE2E Testing\nRecipes\nSPONSORS\nBecome a Sponsor\nHow do game devs ensure secure user experiences and handle spiky logins? Find out in this free eBook\nADS VIA CARBON\nTesting\n​\nWhy Test?\n​\n\nAutomated tests help you and your team build complex Vue applications quickly and confidently by preventing regressions and encouraging you to break apart your application into testable functions, modules, classes, and components. As with any application, your new Vue app can break in many ways, and it's important that you can catch these issues and fix them before releasing.\n\nIn this guide, we'll cover basic terminology and provide our recommendations on which tools to choose for your Vue 3 application.\n\nThere is one Vue-specific section covering composables. See Testing Composables below for more details.\n\nWhen to Test\n​\n\nStart testing early! We recommend you begin writing tests as soon as you can. The longer you wait to add tests to your application, the more dependencies your application will have, and the harder it will be to start.\n\nTesting Types\n​\n\nWhen designing your Vue application's testing strategy, you should leverage the following testing types:\n\nUnit: Checks that inputs to a given function, class, or composable are producing the expected output or side effects.\nComponent: Checks that your component mounts, renders, can be interacted with, and behaves as expected. These tests import more code than unit tests, are more complex, and require more time to execute.\nEnd-to-end: Checks features that span multiple pages and makes real network requests against your production-built Vue application. These tests often involve standing up a database or other backend.\n\nEach testing type plays a role in your application's testing strategy, and each will protect you against different types of issues.\n\nOverview\n​\n\nWe will briefly discuss what each of these are, how they can be implemented for Vue applications, and provide some general recommendations.\n\nUnit Testing\n​\n\nUnit tests are written to verify that small, isolated units of code are working as expected. A unit test usually covers a single function, class, composable, or module. Unit tests focus on logical correctness and only concern themselves with a small portion of the application's overall functionality. They may mock large parts of your application's environment (e.g. initial state, complex classes, 3rd party modules, and network requests).\n\nIn general, unit tests will catch issues with a function's business logic and logical correctness.\n\nTake for example this increment function:\n\njs\n// helpers.js\nexport function increment (current, max = 10) {\n  if (current < max) {\n    return current + 1\n  }\n  return current\n}\n\nBecause it's very self-contained, it'll be easy to invoke the increment function and assert that it returns what it's supposed to, so we'll write a Unit Test.\n\nIf any of these assertions fail, it's clear that the issue is contained within the increment function.\n\njs\n// helpers.spec.js\nimport { increment } from './helpers'\n\ndescribe('increment', () => {\n  test('increments the current number by 1', () => {\n    expect(increment(0, 10)).toBe(1)\n  })\n\n  test('does not increment the current number over the max', () => {\n    expect(increment(10, 10)).toBe(10)\n  })\n\n  test('has a default max of 10', () => {\n    expect(increment(10)).toBe(10)\n  })\n})\n\nAs mentioned previously, unit testing is typically applied to self-contained business logic, components, classes, modules, or functions that do not involve UI rendering, network requests, or other environmental concerns.\n\nThese are typically plain JavaScript / TypeScript modules unrelated to Vue. In general, writing unit tests for business logic in Vue applications does not differ significantly from applications using other frameworks.\n\nThere are two instances where you DO unit test Vue-specific features:\n\nComposables\nComponents\nComposables\n​\n\nOne category of functions specific to Vue applications is Composables, which may require special handling during tests. See Testing Composables below for more details.\n\nUnit Testing Components\n​\n\nA component can be tested in two ways:\n\nWhitebox: Unit Testing\n\nTests that are \"Whitebox tests\" are aware of the implementation details and dependencies of a component. They are focused on isolating the component under test. These tests will usually involve mocking some, if not all of your component's children, as well as setting up plugin state and dependencies (e.g. Pinia).\n\nBlackbox: Component Testing\n\nTests that are \"Blackbox tests\" are unaware of the implementation details of a component. These tests mock as little as possible to test the integration of your component and the entire system. They usually render all child components and are considered more of an \"integration test\". See the Component Testing recommendations below.\n\nRecommendation\n​\n\nVitest\n\nSince the official setup created by create-vue is based on Vite, we recommend using a unit testing framework that can leverage the same configuration and transform pipeline directly from Vite. Vitest is a unit testing framework designed specifically for this purpose, created and maintained by Vue / Vite team members. It integrates with Vite-based projects with minimal effort, and is blazing fast.\n\nOther Options\n​\nJest is a popular unit testing framework. However, we only recommend Jest if you have an existing Jest test suite that needs to be migrated over to a Vite-based project, as Vitest offers a more seamless integration and better performance.\nComponent Testing\n​\n\nIn Vue applications, components are the main building blocks of the UI. Components are therefore the natural unit of isolation when it comes to validating your application's behavior. From a granularity perspective, component testing sits somewhere above unit testing and can be considered a form of integration testing. Much of your Vue Application should be covered by a component test and we recommend that each Vue component has its own spec file.\n\nComponent tests should catch issues relating to your component's props, events, slots that it provides, styles, classes, lifecycle hooks, and more.\n\nComponent tests should not mock child components, but instead test the interactions between your component and its children by interacting with the components as a user would. For example, a component test should click on an element like a user would instead of programmatically interacting with the component.\n\nComponent tests should focus on the component's public interfaces rather than internal implementation details. For most components, the public interface is limited to: events emitted, props, and slots. When testing, remember to test what a component does, not how it does it.\n\nDO\n\nFor Visual logic: assert correct render output based on inputted props and slots.\n\nFor Behavioral logic: assert correct render updates or emitted events in response to user input events.\n\nIn the below example, we demonstrate a Stepper component that has a DOM element labeled \"increment\" and can be clicked. We pass a prop called max that prevents the Stepper from being incremented past 2, so if we click the button 3 times, the UI should still say 2.\n\nWe know nothing about the implementation of Stepper, only that the \"input\" is the max prop and the \"output\" is the state of the DOM as the user will see it.\n\nVue Test Utils\nCypress\nTesting Library\njs\nconst valueSelector = '[data-testid=stepper-value]'\nconst buttonSelector = '[data-testid=increment]'\n\nconst wrapper = mount(Stepper, {\n  props: {\n    max: 1\n  }\n})\n\nexpect(wrapper.find(valueSelector).text()).toContain('0')\n\nawait wrapper.find(buttonSelector).trigger('click')\n\nexpect(wrapper.find(valueSelector).text()).toContain('1')\n\nDON'T\n\nDon't assert the private state of a component instance or test the private methods of a component. Testing implementation details makes the tests brittle, as they are more likely to break and require updates when the implementation changes.\n\nThe component's ultimate job is rendering the correct DOM output, so tests focusing on the DOM output provide the same level of correctness assurance (if not more) while being more robust and resilient to change.\n\nDon't rely exclusively on snapshot tests. Asserting HTML strings does not describe correctness. Write tests with intentionality.\n\nIf a method needs to be tested thoroughly, consider extracting it into a standalone utility function and write a dedicated unit test for it. If it cannot be extracted cleanly, it may be tested as a part of a component, integration, or end-to-end test that covers it.\n\nRecommendation\n​\n\nVitest for components or composables that render headlessly (e.g. the useFavicon function in VueUse). Components and DOM can be tested using @vue/test-utils.\n\nCypress Component Testing for components whose expected behavior depends on properly rendering styles or triggering native DOM events. It can be used with Testing Library via @testing-library/cypress.\n\nThe main differences between Vitest and browser-based runners are speed and execution context. In short, browser-based runners, like Cypress, can catch issues that node-based runners, like Vitest, cannot (e.g. style issues, real native DOM events, cookies, local storage, and network failures), but browser-based runners are orders of magnitude slower than Vitest because they do open a browser, compile your stylesheets, and more. Cypress is a browser-based runner that supports component testing. Please read Vitest's comparison page for the latest information comparing Vitest and Cypress.\n\nMounting Libraries\n​\n\nComponent testing often involves mounting the component being tested in isolation, triggering simulated user input events, and asserting on the rendered DOM output. There are dedicated utility libraries that make these tasks simpler.\n\n@vue/test-utils is the official low-level component testing library that was written to provide users access to Vue specific APIs. It's also the lower-level library @testing-library/vue is built on top of.\n\n@testing-library/vue is a Vue testing library focused on testing components without relying on implementation details. Its guiding principle is that the more tests resemble the way software is used, the more confidence they can provide.\n\nWe recommend using @vue/test-utils for testing components in applications. @testing-library/vue has issues with testing asynchronous component with Suspense, so it should be used with caution.\n\nOther Options\n​\n\nNightwatch is an E2E test runner with Vue Component Testing support. (Example Project)\n\nWebdriverIO for cross-browser component testing that relies on native user interaction based on standardized automation. It can also be used with Testing Library.\n\nE2E Testing\n​\n\nWhile unit tests provide developers with some degree of confidence, unit and component tests are limited in their abilities to provide holistic coverage of an application when deployed to production. As a result, end-to-end (E2E) tests provide coverage on what is arguably the most important aspect of an application: what happens when users actually use your applications.\n\nEnd-to-end tests focus on multi-page application behavior that makes network requests against your production-built Vue application. They often involve standing up a database or other backend and may even be run against a live staging environment.\n\nEnd-to-end tests will often catch issues with your router, state management library, top-level components (e.g. an App or Layout), public assets, or any request handling. As stated above, they catch critical issues that may be impossible to catch with unit tests or component tests.\n\nEnd-to-end tests do not import any of your Vue application's code but instead rely completely on testing your application by navigating through entire pages in a real browser.\n\nEnd-to-end tests validate many of the layers in your application. They can either target your locally built application or even a live Staging environment. Testing against your Staging environment not only includes your frontend code and static server but all associated backend services and infrastructure.\n\nThe more your tests resemble how your software is used, the more confidence they can give you. - Kent C. Dodds - Author of the Testing Library\n\nBy testing how user actions impact your application, E2E tests are often the key to higher confidence in whether an application is functioning properly or not.\n\nChoosing an E2E Testing Solution\n​\n\nWhile end-to-end (E2E) testing on the web has gained a negative reputation for unreliable (flaky) tests and slowing down development processes, modern E2E tools have made strides forward to create more reliable, interactive, and useful tests. When choosing an E2E testing framework, the following sections provide some guidance on things to keep in mind when choosing a testing framework for your application.\n\nCross-browser testing\n​\n\nOne of the primary benefits that end-to-end (E2E) testing is known for is its ability to test your application across multiple browsers. While it may seem desirable to have 100% cross-browser coverage, it is important to note that cross browser testing has diminishing returns on a team's resources due to the additional time and machine power required to run them consistently. As a result, it is important to be mindful of this trade-off when choosing the amount of cross-browser testing your application needs.\n\nFaster feedback loops\n​\n\nOne of the primary problems with end-to-end (E2E) tests and development is that running the entire suite takes a long time. Typically, this is only done in continuous integration and deployment (CI/CD) pipelines. Modern E2E testing frameworks have helped to solve this by adding features like parallelization, which allows for CI/CD pipelines to often run magnitudes faster than before. In addition, when developing locally, the ability to selectively run a single test for the page you are working on while also providing hot reloading of tests can help boost a developer's workflow and productivity.\n\nFirst-class debugging experience\n​\n\nWhile developers have traditionally relied on scanning logs in a terminal window to help determine what went wrong in a test, modern end-to-end (E2E) test frameworks allow developers to leverage tools they are already familiar with, e.g. browser developer tools.\n\nVisibility in headless mode\n​\n\nWhen end-to-end (E2E) tests are run in continuous integration/deployment pipelines, they are often run in headless browsers (i.e., no visible browser is opened for the user to watch). A critical feature of modern E2E testing frameworks is the ability to see snapshots and/or videos of the application during testing, providing some insight into why errors are happening. Historically, it was tedious to maintain these integrations.\n\nRecommendation\n​\n\nCypress\n\nOverall, we believe Cypress provides the most complete E2E solution with features like an informative graphical interface, excellent debuggability, built-in assertions, stubs, flake-resistance, parallelization, and snapshots. As mentioned above, it also provides support for Component Testing. It supports Chromium-based browsers, Firefox, and Electron. WebKit support is available, but marked experimental.\n\nOther Options\n​\n\nPlaywright is also a great E2E testing solution that supports all modern rendering engines including Chromium, WebKit, and Firefox. Test on Windows, Linux, and macOS, locally or on CI, headless or headed with native mobile emulation of Google Chrome for Android and Mobile Safari.\n\nNightwatch is an E2E testing solution based on Selenium WebDriver. This gives it the widest browser support range, including native mobile testing. Selenium-based solutions will be slower than Playwright or Cypress.\n\nWebdriverIO is a test automation framework for web and mobile testing based on the WebDriver protocol.\n\nRecipes\n​\nAdding Vitest to a Project\n​\n\nIn a Vite-based Vue project, run:\n\nsh\n> npm install -D vitest happy-dom @testing-library/vue\n\nNext, update the Vite configuration to add the test option block:\n\njs\n// vite.config.js\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  // ...\n  test: {\n    // enable jest-like global test APIs\n    globals: true,\n    // simulate DOM with happy-dom\n    // (requires installing happy-dom as a peer dependency)\n    environment: 'happy-dom'\n  }\n})\n\nTIP\n\nIf you use TypeScript, add vitest/globals to the types field in your tsconfig.json.\n\njson\n// tsconfig.json\n\n{\n  \"compilerOptions\": {\n    \"types\": [\"vitest/globals\"]\n  }\n}\n\nThen, create a file ending in *.test.js in your project. You can place all test files in a test directory in the project root or in test directories next to your source files. Vitest will automatically search for them using the naming convention.\n\njs\n// MyComponent.test.js\nimport { render } from '@testing-library/vue'\nimport MyComponent from './MyComponent.vue'\n\ntest('it should work', () => {\n  const { getByText } = render(MyComponent, {\n    props: {\n      /* ... */\n    }\n  })\n\n  // assert output\n  getByText('...')\n})\n\nFinally, update package.json to add the test script and run it:\n\njson\n{\n  // ...\n  \"scripts\": {\n    \"test\": \"vitest\"\n  }\n}\nsh\n> npm test\nTesting Composables\n​\n\nThis section assumes you have read the Composables section.\n\nWhen it comes to testing composables, we can divide them into two categories: composables that do not rely on a host component instance, and composables that do.\n\nA composable depends on a host component instance when it uses the following APIs:\n\nLifecycle hooks\nProvide / Inject\n\nIf a composable only uses Reactivity APIs, then it can be tested by directly invoking it and asserting its returned state/methods:\n\njs\n// counter.js\nimport { ref } from 'vue'\n\nexport function useCounter() {\n  const count = ref(0)\n  const increment = () => count.value++\n\n  return {\n    count,\n    increment\n  }\n}\njs\n// counter.test.js\nimport { useCounter } from './counter.js'\n\ntest('useCounter', () => {\n  const { count, increment } = useCounter()\n  expect(count.value).toBe(0)\n\n  increment()\n  expect(count.value).toBe(1)\n})\n\nA composable that relies on lifecycle hooks or Provide / Inject needs to be wrapped in a host component to be tested. We can create a helper like the following:\n\njs\n// test-utils.js\nimport { createApp } from 'vue'\n\nexport function withSetup(composable) {\n  let result\n  const app = createApp({\n    setup() {\n      result = composable()\n      // suppress missing template warning\n      return () => {}\n    }\n  })\n  app.mount(document.createElement('div'))\n  // return the result and the app instance\n  // for testing provide/unmount\n  return [result, app]\n}\njs\nimport { withSetup } from './test-utils'\nimport { useFoo } from './foo'\n\ntest('useFoo', () => {\n  const [result, app] = withSetup(() => useFoo(123))\n  // mock provide for testing injections\n  app.provide(...)\n  // run assertions\n  expect(result.foo.value).toBe(1)\n  // trigger onUnmounted hook if needed\n  app.unmount()\n})\n\nFor more complex composables, it could also be easier to test it by writing tests against the wrapper component using Component Testing techniques.\n\nEdit this page on GitHub\n\n Previous\nState Management\nNext \nServer-Side Rendering (SSR)\nTesting has loaded"
  },
  {
    "title": "State Management | Vue.js",
    "url": "https://vuejs.org/guide/scaling-up/state-management",
    "html": "Skip to content\nGet 60% off a year of Vue Mastery courses\nGET DISCOUNT\nVue.js\nSearch\nCtrl\nK\nMain Navigation\nDocs\nAPI\nPlayground\nEcosystem\nAbout\nSponsor\nPartners\ngithub\ntwitter\ndiscord\nAPI Preference\nOptions\nComposition\n?\n\nAPI style now defaults to Composition API.\n\nSome pages contain different content based on the API style chosen. Use this switch to toggle between APIs styles.\n\nLearn moreGot it\n\nSidebar Navigation\nGetting Started\n\nIntroduction\n\nQuick Start\n\nEssentials\n\nCreating an Application\n\nTemplate Syntax\n\nReactivity Fundamentals\n\nComputed Properties\n\nClass and Style Bindings\n\nConditional Rendering\n\nList Rendering\n\nEvent Handling\n\nForm Input Bindings\n\nLifecycle Hooks\n\nWatchers\n\nTemplate Refs\n\nComponents Basics\n\nComponents In-Depth\n\nRegistration\n\nProps\n\nEvents\n\nComponent v-model\n\nFallthrough Attributes\n\nSlots\n\nProvide / inject\n\nAsync Components\n\nReusability\n\nComposables\n\nCustom Directives\n\nPlugins\n\nBuilt-in Components\n\nTransition\n\nTransitionGroup\n\nKeepAlive\n\nTeleport\n\nSuspense\n\nScaling Up\n\nSingle-File Components\n\nTooling\n\nRouting\n\nState Management\n\nTesting\n\nServer-Side Rendering (SSR)\n\nBest Practices\n\nProduction Deployment\n\nPerformance\n\nAccessibility\n\nSecurity\n\nTypeScript\n\nOverview\n\nTS with Composition API\n\nTS with Options API\n\nExtra Topics\n\nWays of Using Vue\n\nComposition API FAQ\n\nReactivity in Depth\n\nRendering Mechanism\n\nRender Functions & JSX\n\nVue and Web Components\n\nAnimation Techniques\n\nON THIS PAGE\nTable of Contents for current page\nWhat is State Management?\nSimple State Management with Reactivity API\nSSR Considerations\nPinia\nSPONSORS\nBecome a Sponsor\nScale effortlessly with Intel® Xeon® based servers while staying in control of your data\nADS VIA CARBON\nState Management\n​\nWhat is State Management?\n​\n\nTechnically, every Vue component instance already \"manages\" its own reactive state. Take a simple counter component as an example:\n\nvue\n<script setup>\nimport { ref } from 'vue'\n\n// state\nconst count = ref(0)\n\n// actions\nfunction increment() {\n  count.value++\n}\n</script>\n\n<!-- view -->\n<template>{{ count }}</template>\n\nIt is a self-contained unit with the following parts:\n\nThe state, the source of truth that drives our app;\nThe view, a declarative mapping of the state;\nThe actions, the possible ways the state could change in reaction to user inputs from the view.\n\nThis is a simple representation of the concept of \"one-way data flow\":\n\nHowever, the simplicity starts to break down when we have multiple components that share a common state:\n\nMultiple views may depend on the same piece of state.\nActions from different views may need to mutate the same piece of state.\n\nFor case one, a possible workaround is by \"lifting\" the shared state up to a common ancestor component, and then pass it down as props. However, this quickly gets tedious in component trees with deep hierarchies, leading to another problem known as Prop Drilling.\n\nFor case two, we often find ourselves resorting to solutions such as reaching for direct parent / child instances via template refs, or trying to mutate and synchronize multiple copies of the state via emitted events. Both of these patterns are brittle and quickly lead to unmaintainable code.\n\nA simpler and more straightforward solution is to extract the shared state out of the components, and manage it in a global singleton. With this, our component tree becomes a big \"view\", and any component can access the state or trigger actions, no matter where they are in the tree!\n\nSimple State Management with Reactivity API\n​\n\nIf you have a piece of state that should be shared by multiple instances, you can use reactive() to create a reactive object, and then import it into multiple components:\n\njs\n// store.js\nimport { reactive } from 'vue'\n\nexport const store = reactive({\n  count: 0\n})\nvue\n<!-- ComponentA.vue -->\n<script setup>\nimport { store } from './store.js'\n</script>\n\n<template>From A: {{ store.count }}</template>\nvue\n<!-- ComponentB.vue -->\n<script setup>\nimport { store } from './store.js'\n</script>\n\n<template>From B: {{ store.count }}</template>\n\nNow whenever the store object is mutated, both <ComponentA> and <ComponentB> will update their views automatically - we have a single source of truth now.\n\nHowever, this also means any component importing store can mutate it however they want:\n\ntemplate\n<template>\n  <button @click=\"store.count++\">\n    From B: {{ store.count }}\n  </button>\n</template>\n\nWhile this works in simple cases, global state that can be arbitrarily mutated by any component is not going to be very maintainable in the long run. To ensure the state-mutating logic is centralized like the state itself, it is recommended to define methods on the store with names that express the intention of the actions:\n\njs\n// store.js\nimport { reactive } from 'vue'\n\nexport const store = reactive({\n  count: 0,\n  increment() {\n    this.count++\n  }\n})\ntemplate\n<template>\n  <button @click=\"store.increment()\">\n    From B: {{ store.count }}\n  </button>\n</template>\n\nTry it in the Playground\n\nTIP\n\nNote the click handler uses store.increment() with parentheses - this is necessary to call the method with the proper this context since it's not a component method.\n\nAlthough here we are using a single reactive object as a store, you can also share reactive state created using other Reactivity APIs such as ref() or computed(), or even return global state from a Composable:\n\njs\nimport { ref } from 'vue'\n\n// global state, created in module scope\nconst globalCount = ref(1)\n\nexport function useCount() {\n  // local state, created per-component\n  const localCount = ref(1)\n\n  return {\n    globalCount,\n    localCount\n  }\n}\n\nThe fact that Vue's reactivity system is decoupled from the component model makes it extremely flexible.\n\nSSR Considerations\n​\n\nIf you are building an application that leverages Server-Side Rendering (SSR), the above pattern can lead to issues due to the store being a singleton shared across multiple requests. This is discussed in more details in the SSR guide.\n\nPinia\n​\n\nWhile our hand-rolled state management solution will suffice in simple scenarios, there are many more things to consider in large-scale production applications:\n\nStronger conventions for team collaboration\nIntegrating with the Vue DevTools, including timeline, in-component inspection, and time-travel debugging\nHot Module Replacement\nServer-Side Rendering support\n\nPinia is a state management library that implements all of the above. It is maintained by the Vue core team, and works with both Vue 2 and Vue 3.\n\nExisting users may be familiar with Vuex, the previous official state management library for Vue. With Pinia serving the same role in the ecosystem, Vuex is now in maintenance mode. It still works, but will no longer receive new features. It is recommended to use Pinia for new applications.\n\nPinia started out as an exploration of what the next iteration of Vuex could look like, incorporating many ideas from core team discussions for Vuex 5. Eventually, we realized that Pinia already implements most of what we wanted in Vuex 5, and decided to make it the new recommendation instead.\n\nCompared to Vuex, Pinia provides a simpler API with less ceremony, offers Composition-API-style APIs, and most importantly, has solid type inference support when used with TypeScript.\n\nEdit this page on GitHub\n\n Previous\nRouting\nNext \nTesting\nState Management has loaded"
  },
  {
    "title": "Routing | Vue.js",
    "url": "https://vuejs.org/guide/scaling-up/routing",
    "html": "Skip to content\nGet 60% off a year of Vue Mastery courses\nGET DISCOUNT\nVue.js\nSearch\nCtrl\nK\nMain Navigation\nDocs\nAPI\nPlayground\nEcosystem\nAbout\nSponsor\nPartners\ngithub\ntwitter\ndiscord\nAPI Preference\nOptions\nComposition\n?\n\nAPI style now defaults to Composition API.\n\nSome pages contain different content based on the API style chosen. Use this switch to toggle between APIs styles.\n\nLearn moreGot it\n\nSidebar Navigation\nGetting Started\n\nIntroduction\n\nQuick Start\n\nEssentials\n\nCreating an Application\n\nTemplate Syntax\n\nReactivity Fundamentals\n\nComputed Properties\n\nClass and Style Bindings\n\nConditional Rendering\n\nList Rendering\n\nEvent Handling\n\nForm Input Bindings\n\nLifecycle Hooks\n\nWatchers\n\nTemplate Refs\n\nComponents Basics\n\nComponents In-Depth\n\nRegistration\n\nProps\n\nEvents\n\nComponent v-model\n\nFallthrough Attributes\n\nSlots\n\nProvide / inject\n\nAsync Components\n\nReusability\n\nComposables\n\nCustom Directives\n\nPlugins\n\nBuilt-in Components\n\nTransition\n\nTransitionGroup\n\nKeepAlive\n\nTeleport\n\nSuspense\n\nScaling Up\n\nSingle-File Components\n\nTooling\n\nRouting\n\nState Management\n\nTesting\n\nServer-Side Rendering (SSR)\n\nBest Practices\n\nProduction Deployment\n\nPerformance\n\nAccessibility\n\nSecurity\n\nTypeScript\n\nOverview\n\nTS with Composition API\n\nTS with Options API\n\nExtra Topics\n\nWays of Using Vue\n\nComposition API FAQ\n\nReactivity in Depth\n\nRendering Mechanism\n\nRender Functions & JSX\n\nVue and Web Components\n\nAnimation Techniques\n\nON THIS PAGE\nTable of Contents for current page\nClient-Side vs. Server-Side Routing\nOfficial Router\nSimple Routing from Scratch\nSPONSORS\nBecome a Sponsor\nMinimise attack area with Intel® Xeon® powered servers equipped with Intel® SGX\nADS VIA CARBON\nRouting\n​\nClient-Side vs. Server-Side Routing\n​\n\nRouting on the server side means the server is sending a response based on the URL path that the user is visiting. When we click on a link in a traditional server-rendered web app, the browser receives an HTML response from the server and reloads the entire page with the new HTML.\n\nIn a Single-Page Application (SPA), however, the client-side JavaScript can intercept the navigation, dynamically fetch new data, and update the current page without full page reloads. This typically results in a more snappy user experience, especially for use cases that are more like actual \"applications\", where the user is expected to perform many interactions over a long period of time.\n\nIn such SPAs, the \"routing\" is done on the client side, in the browser. A client-side router is responsible for managing the application's rendered view using browser APIs such as History API or the hashchange event.\n\nOfficial Router\n​\nWatch a Free Video Course on Vue School\n\nVue is well-suited for building SPAs. For most SPAs, it's recommended to use the officially-supported Vue Router library. For more details, see Vue Router's documentation.\n\nSimple Routing from Scratch\n​\n\nIf you only need very simple routing and do not wish to involve a full-featured router library, you can do so with Dynamic Components and update the current component state by listening to browser hashchange events or using the History API.\n\nHere's a bare-bone example:\n\nvue\n<script setup>\nimport { ref, computed } from 'vue'\nimport Home from './Home.vue'\nimport About from './About.vue'\nimport NotFound from './NotFound.vue'\n\nconst routes = {\n  '/': Home,\n  '/about': About\n}\n\nconst currentPath = ref(window.location.hash)\n\nwindow.addEventListener('hashchange', () => {\n  currentPath.value = window.location.hash\n})\n\nconst currentView = computed(() => {\n  return routes[currentPath.value.slice(1) || '/'] || NotFound\n})\n</script>\n\n<template>\n  <a href=\"#/\">Home</a> |\n  <a href=\"#/about\">About</a> |\n  <a href=\"#/non-existent-path\">Broken Link</a>\n  <component :is=\"currentView\" />\n</template>\n\nTry it in the Playground\n\nEdit this page on GitHub\n\n Previous\nTooling\nNext \nState Management\nRouting has loaded"
  },
  {
    "title": "Single-File Components | Vue.js",
    "url": "https://vuejs.org/guide/scaling-up/sfc",
    "html": "Skip to content\nGet 60% off a year of Vue Mastery courses\nGET DISCOUNT\nVue.js\nSearch\nCtrl\nK\nMain Navigation\nDocs\nAPI\nPlayground\nEcosystem\nAbout\nSponsor\nPartners\ngithub\ntwitter\ndiscord\nAPI Preference\nOptions\nComposition\n?\n\nAPI style now defaults to Composition API.\n\nSome pages contain different content based on the API style chosen. Use this switch to toggle between APIs styles.\n\nLearn moreGot it\n\nSidebar Navigation\nGetting Started\n\nIntroduction\n\nQuick Start\n\nEssentials\n\nCreating an Application\n\nTemplate Syntax\n\nReactivity Fundamentals\n\nComputed Properties\n\nClass and Style Bindings\n\nConditional Rendering\n\nList Rendering\n\nEvent Handling\n\nForm Input Bindings\n\nLifecycle Hooks\n\nWatchers\n\nTemplate Refs\n\nComponents Basics\n\nComponents In-Depth\n\nRegistration\n\nProps\n\nEvents\n\nComponent v-model\n\nFallthrough Attributes\n\nSlots\n\nProvide / inject\n\nAsync Components\n\nReusability\n\nComposables\n\nCustom Directives\n\nPlugins\n\nBuilt-in Components\n\nTransition\n\nTransitionGroup\n\nKeepAlive\n\nTeleport\n\nSuspense\n\nScaling Up\n\nSingle-File Components\n\nTooling\n\nRouting\n\nState Management\n\nTesting\n\nServer-Side Rendering (SSR)\n\nBest Practices\n\nProduction Deployment\n\nPerformance\n\nAccessibility\n\nSecurity\n\nTypeScript\n\nOverview\n\nTS with Composition API\n\nTS with Options API\n\nExtra Topics\n\nWays of Using Vue\n\nComposition API FAQ\n\nReactivity in Depth\n\nRendering Mechanism\n\nRender Functions & JSX\n\nVue and Web Components\n\nAnimation Techniques\n\nON THIS PAGE\nTable of Contents for current page\nIntroduction\nWhy SFC\nHow It Works\nWhat About Separation of Concerns?\nSPONSORS\nBecome a Sponsor\nEnsure your apps are always ready for growth. Go Cloud Native\nADS VIA CARBON\nSingle-File Components\n​\nIntroduction\n​\n\nVue Single-File Components (a.k.a. *.vue files, abbreviated as SFC) is a special file format that allows us to encapsulate the template, logic, and styling of a Vue component in a single file. Here's an example SFC:\n\nvue\n<script setup>\nimport { ref } from 'vue'\nconst greeting = ref('Hello World!')\n</script>\n\n<template>\n  <p class=\"greeting\">{{ greeting }}</p>\n</template>\n\n<style>\n.greeting {\n  color: red;\n  font-weight: bold;\n}\n</style>\n\nAs we can see, Vue SFC is a natural extension of the classic trio of HTML, CSS and JavaScript. The <template>, <script>, and <style> blocks encapsulate and colocate the view, logic and styling of a component in the same file. The full syntax is defined in the SFC Syntax Specification.\n\nWhy SFC\n​\n\nWhile SFCs require a build step, there are numerous benefits in return:\n\nAuthor modularized components using familiar HTML, CSS and JavaScript syntax\nColocation of inherently coupled concerns\nPre-compiled templates without runtime compilation cost\nComponent-scoped CSS\nMore ergonomic syntax when working with Composition API\nMore compile-time optimizations by cross-analyzing template and script\nIDE support with auto-completion and type-checking for template expressions\nOut-of-the-box Hot-Module Replacement (HMR) support\n\nSFC is a defining feature of Vue as a framework, and is the recommended approach for using Vue in the following scenarios:\n\nSingle-Page Applications (SPA)\nStatic Site Generation (SSG)\nAny non-trivial frontend where a build step can be justified for better development experience (DX).\n\nThat said, we do realize there are scenarios where SFCs can feel like overkill. This is why Vue can still be used via plain JavaScript without a build step. If you are just looking for enhancing largely static HTML with light interactions, you can also check out petite-vue, a 6 kB subset of Vue optimized for progressive enhancement.\n\nHow It Works\n​\n\nVue SFC is a framework-specific file format and must be pre-compiled by @vue/compiler-sfc into standard JavaScript and CSS. A compiled SFC is a standard JavaScript (ES) module - which means with proper build setup you can import an SFC like a module:\n\njs\nimport MyComponent from './MyComponent.vue'\n\nexport default {\n  components: {\n    MyComponent\n  }\n}\n\n<style> tags inside SFCs are typically injected as native <style> tags during development to support hot updates. For production they can be extracted and merged into a single CSS file.\n\nYou can play with SFCs and explore how they are compiled in the Vue SFC Playground.\n\nIn actual projects, we typically integrate the SFC compiler with a build tool such as Vite or Vue CLI (which is based on webpack), and Vue provides official scaffolding tools to get you started with SFCs as fast as possible. Check out more details in the SFC Tooling section.\n\nWhat About Separation of Concerns?\n​\n\nSome users coming from a traditional web development background may have the concern that SFCs are mixing different concerns in the same place - which HTML/CSS/JS were supposed to separate!\n\nTo answer this question, it is important for us to agree that separation of concerns is not equal to the separation of file types. The ultimate goal of engineering principles is to improve the maintainability of codebases. Separation of concerns, when applied dogmatically as separation of file types, does not help us reach that goal in the context of increasingly complex frontend applications.\n\nIn modern UI development, we have found that instead of dividing the codebase into three huge layers that interweave with one another, it makes much more sense to divide them into loosely-coupled components and compose them. Inside a component, its template, logic, and styles are inherently coupled, and colocating them actually makes the component more cohesive and maintainable.\n\nNote even if you don't like the idea of Single-File Components, you can still leverage its hot-reloading and pre-compilation features by separating your JavaScript and CSS into separate files using Src Imports.\n\nEdit this page on GitHub\n\n Previous\nSuspense\nNext \nTooling\nSingle-File Components has loaded"
  },
  {
    "title": "Suspense | Vue.js",
    "url": "https://vuejs.org/guide/built-ins/suspense",
    "html": "Skip to content\nGet 60% off a year of Vue Mastery courses\nGET DISCOUNT\nVue.js\nSearch\nCtrl\nK\nMain Navigation\nDocs\nAPI\nPlayground\nEcosystem\nAbout\nSponsor\nPartners\ngithub\ntwitter\ndiscord\nAPI Preference\nOptions\nComposition\n?\n\nAPI style now defaults to Composition API.\n\nSome pages contain different content based on the API style chosen. Use this switch to toggle between APIs styles.\n\nLearn moreGot it\n\nSidebar Navigation\nGetting Started\n\nIntroduction\n\nQuick Start\n\nEssentials\n\nCreating an Application\n\nTemplate Syntax\n\nReactivity Fundamentals\n\nComputed Properties\n\nClass and Style Bindings\n\nConditional Rendering\n\nList Rendering\n\nEvent Handling\n\nForm Input Bindings\n\nLifecycle Hooks\n\nWatchers\n\nTemplate Refs\n\nComponents Basics\n\nComponents In-Depth\n\nRegistration\n\nProps\n\nEvents\n\nComponent v-model\n\nFallthrough Attributes\n\nSlots\n\nProvide / inject\n\nAsync Components\n\nReusability\n\nComposables\n\nCustom Directives\n\nPlugins\n\nBuilt-in Components\n\nTransition\n\nTransitionGroup\n\nKeepAlive\n\nTeleport\n\nSuspense\n\nScaling Up\n\nSingle-File Components\n\nTooling\n\nRouting\n\nState Management\n\nTesting\n\nServer-Side Rendering (SSR)\n\nBest Practices\n\nProduction Deployment\n\nPerformance\n\nAccessibility\n\nSecurity\n\nTypeScript\n\nOverview\n\nTS with Composition API\n\nTS with Options API\n\nExtra Topics\n\nWays of Using Vue\n\nComposition API FAQ\n\nReactivity in Depth\n\nRendering Mechanism\n\nRender Functions & JSX\n\nVue and Web Components\n\nAnimation Techniques\n\nON THIS PAGE\nTable of Contents for current page\nAsync Dependencies\nasync setup()\nAsync Components\nLoading State\nEvents\nError Handling\nCombining with Other Components\nNested Suspense\nSPONSORS\nBecome a Sponsor\nShip Code. Not Containers. Render, the modern cloud for software teams.\nADS VIA CARBON\nSuspense\n​\n\nExperimental Feature\n\n<Suspense> is an experimental feature. It is not guaranteed to reach stable status and the API may change before it does.\n\n<Suspense> is a built-in component for orchestrating async dependencies in a component tree. It can render a loading state while waiting for multiple nested async dependencies down the component tree to be resolved.\n\nAsync Dependencies\n​\n\nTo explain the problem <Suspense> is trying to solve and how it interacts with these async dependencies, let's imagine a component hierarchy like the following:\n\n<Suspense>\n└─ <Dashboard>\n   ├─ <Profile>\n   │  └─ <FriendStatus> (component with async setup())\n   └─ <Content>\n      ├─ <ActivityFeed> (async component)\n      └─ <Stats> (async component)\n\nIn the component tree there are multiple nested components whose rendering depends on some async resource to be resolved first. Without <Suspense>, each of them will need to handle its own loading / error and loaded states. In the worst case scenario, we may see three loading spinners on the page, with content displayed at different times.\n\nThe <Suspense> component gives us the ability to display top-level loading / error states while we wait on these nested async dependencies to be resolved.\n\nThere are two types of async dependencies that <Suspense> can wait on:\n\nComponents with an async setup() hook. This includes components using <script setup> with top-level await expressions.\n\nAsync Components.\n\nasync setup()\n​\n\nA Composition API component's setup() hook can be async:\n\njs\nexport default {\n  async setup() {\n    const res = await fetch(...)\n    const posts = await res.json()\n    return {\n      posts\n    }\n  }\n}\n\nIf using <script setup>, the presence of top-level await expressions automatically makes the component an async dependency:\n\nvue\n<script setup>\nconst res = await fetch(...)\nconst posts = await res.json()\n</script>\n\n<template>\n  {{ posts }}\n</template>\nAsync Components\n​\n\nAsync components are \"suspensible\" by default. This means that if it has a <Suspense> in the parent chain, it will be treated as an async dependency of that <Suspense>. In this case, the loading state will be controlled by the <Suspense>, and the component's own loading, error, delay and timeout options will be ignored.\n\nThe async component can opt-out of Suspense control and let the component always control its own loading state by specifying suspensible: false in its options.\n\nLoading State\n​\n\nThe <Suspense> component has two slots: #default and #fallback. Both slots only allow for one immediate child node. The node in the default slot is shown if possible. If not, the node in the fallback slot will be shown instead.\n\ntemplate\n<Suspense>\n  <!-- component with nested async dependencies -->\n  <Dashboard />\n\n  <!-- loading state via #fallback slot -->\n  <template #fallback>\n    Loading...\n  </template>\n</Suspense>\n\nOn initial render, <Suspense> will render its default slot content in memory. If any async dependencies are encountered during the process, it will enter a pending state. During the pending state, the fallback content will be displayed. When all encountered async dependencies have been resolved, <Suspense> enters a resolved state and the resolved default slot content is displayed.\n\nIf no async dependencies were encountered during the initial render, <Suspense> will directly go into a resolved state.\n\nOnce in a resolved state, <Suspense> will only revert to a pending state if the root node of the #default slot is replaced. New async dependencies nested deeper in the tree will not cause the <Suspense> to revert to a pending state.\n\nWhen a revert happens, fallback content will not be immediately displayed. Instead, <Suspense> will display the previous #default content while waiting for the new content and its async dependencies to be resolved. This behavior can be configured with the timeout prop: <Suspense> will switch to fallback content if it takes longer than timeout to render the new default content. A timeout value of 0 will cause the fallback content to be displayed immediately when default content is replaced.\n\nEvents\n​\n\nThe <Suspense> component emits 3 events: pending, resolve and fallback. The pending event occurs when entering a pending state. The resolve event is emitted when new content has finished resolving in the default slot. The fallback event is fired when the contents of the fallback slot are shown.\n\nThe events could be used, for example, to show a loading indicator in front of the old DOM while new components are loading.\n\nError Handling\n​\n\n<Suspense> currently does not provide error handling via the component itself - however, you can use the errorCaptured option or the onErrorCaptured() hook to capture and handle async errors in the parent component of <Suspense>.\n\nCombining with Other Components\n​\n\nIt is common to want to use <Suspense> in combination with the <Transition> and <KeepAlive> components. The nesting order of these components is important to get them all working correctly.\n\nIn addition, these components are often used in conjunction with the <RouterView> component from Vue Router.\n\nThe following example shows how to nest these components so that they all behave as expected. For simpler combinations you can remove the components that you don't need:\n\ntemplate\n<RouterView v-slot=\"{ Component }\">\n  <template v-if=\"Component\">\n    <Transition mode=\"out-in\">\n      <KeepAlive>\n        <Suspense>\n          <!-- main content -->\n          <component :is=\"Component\"></component>\n\n          <!-- loading state -->\n          <template #fallback>\n            Loading...\n          </template>\n        </Suspense>\n      </KeepAlive>\n    </Transition>\n  </template>\n</RouterView>\n\nVue Router has built-in support for lazily loading components using dynamic imports. These are distinct from async components and currently they will not trigger <Suspense>. However, they can still have async components as descendants and those can trigger <Suspense> in the usual way.\n\nNested Suspense\n​\n\nWhen we have multiple async components (common for nested or layout-based routes) like this:\n\ntemplate\n<Suspense>\n  <component :is=\"DynamicAsyncOuter\">\n    <component :is=\"DynamicAsyncInner\" />\n  </component>\n</Suspense>\n\n<Suspense> creates a boundary that will resolve all the async components down the tree, as expected. However, when we change DynamicAsyncOuter, <Suspense> awaits it correctly, but when we change DynamicAsyncInner, the nested DynamicAsyncInner renders an empty node until it has been resolved (instead of the previous one or fallback slot).\n\nIn order to solve that, we could have a nested suspense to handle the patch for the nested component, like:\n\ntemplate\n<Suspense>\n  <component :is=\"DynamicAsyncOuter\">\n    <Suspense suspensible> <!-- this -->\n      <component :is=\"DynamicAsyncInner\" />\n    </Suspense>\n  </component>\n</Suspense>\n\nIf you don't set the suspensible prop, the inner <Suspense> will be treated like a sync component by the parent <Suspense>. That means that it has its own fallback slot and if both Dynamic components change at the same time, there might be empty nodes and multiple patching cycles while the child <Suspense> is loading its own dependency tree, which might not be desirable. When it's set, all the async dependency handling is given to the parent <Suspense> (including the events emitted) and the inner <Suspense> serves solely as another boundary for the dependency resolution and patching.\n\nRelated\n\n<Suspense> API reference\n\nEdit this page on GitHub\n\n Previous\nTeleport\nNext \nSingle-File Components\nSuspense has loaded"
  },
  {
    "title": "Teleport | Vue.js",
    "url": "https://vuejs.org/guide/built-ins/teleport",
    "html": "Skip to content\nGet 60% off a year of Vue Mastery courses\nGET DISCOUNT\nVue.js\nSearch\nCtrl\nK\nMain Navigation\nDocs\nAPI\nPlayground\nEcosystem\nAbout\nSponsor\nPartners\ngithub\ntwitter\ndiscord\nAPI Preference\nOptions\nComposition\n?\n\nAPI style now defaults to Composition API.\n\nSome pages contain different content based on the API style chosen. Use this switch to toggle between APIs styles.\n\nLearn moreGot it\n\nSidebar Navigation\nGetting Started\n\nIntroduction\n\nQuick Start\n\nEssentials\n\nCreating an Application\n\nTemplate Syntax\n\nReactivity Fundamentals\n\nComputed Properties\n\nClass and Style Bindings\n\nConditional Rendering\n\nList Rendering\n\nEvent Handling\n\nForm Input Bindings\n\nLifecycle Hooks\n\nWatchers\n\nTemplate Refs\n\nComponents Basics\n\nComponents In-Depth\n\nRegistration\n\nProps\n\nEvents\n\nComponent v-model\n\nFallthrough Attributes\n\nSlots\n\nProvide / inject\n\nAsync Components\n\nReusability\n\nComposables\n\nCustom Directives\n\nPlugins\n\nBuilt-in Components\n\nTransition\n\nTransitionGroup\n\nKeepAlive\n\nTeleport\n\nSuspense\n\nScaling Up\n\nSingle-File Components\n\nTooling\n\nRouting\n\nState Management\n\nTesting\n\nServer-Side Rendering (SSR)\n\nBest Practices\n\nProduction Deployment\n\nPerformance\n\nAccessibility\n\nSecurity\n\nTypeScript\n\nOverview\n\nTS with Composition API\n\nTS with Options API\n\nExtra Topics\n\nWays of Using Vue\n\nComposition API FAQ\n\nReactivity in Depth\n\nRendering Mechanism\n\nRender Functions & JSX\n\nVue and Web Components\n\nAnimation Techniques\n\nON THIS PAGE\nTable of Contents for current page\nBasic Usage\nUsing with Components\nDisabling Teleport\nMultiple Teleports on the Same Target\nSPONSORS\nBecome a Sponsor\nShip Code. Not Containers. Render, the modern cloud for software teams.\nADS VIA CARBON\nTeleport\n​\nWatch a free video lesson on Vue School\n\n<Teleport> is a built-in component that allows us to \"teleport\" a part of a component's template into a DOM node that exists outside the DOM hierarchy of that component.\n\nBasic Usage\n​\n\nSometimes we may run into the following scenario: a part of a component's template belongs to it logically, but from a visual standpoint, it should be displayed somewhere else in the DOM, outside of the Vue application.\n\nThe most common example of this is when building a full-screen modal. Ideally, we want the modal's button and the modal itself to live within the same component, since they are both related to the open / close state of the modal. But that means the modal will be rendered alongside the button, deeply nested in the application's DOM hierarchy. This can create some tricky issues when positioning the modal via CSS.\n\nConsider the following HTML structure.\n\ntemplate\n<div class=\"outer\">\n  <h3>Vue Teleport Example</h3>\n  <div>\n    <MyModal />\n  </div>\n</div>\n\nAnd here is the implementation of <MyModal>:\n\nvue\n<script setup>\nimport { ref } from 'vue'\n\nconst open = ref(false)\n</script>\n\n<template>\n  <button @click=\"open = true\">Open Modal</button>\n\n  <div v-if=\"open\" class=\"modal\">\n    <p>Hello from the modal!</p>\n    <button @click=\"open = false\">Close</button>\n  </div>\n</template>\n\n<style scoped>\n.modal {\n  position: fixed;\n  z-index: 999;\n  top: 20%;\n  left: 50%;\n  width: 300px;\n  margin-left: -150px;\n}\n</style>\n\nThe component contains a <button> to trigger the opening of the modal, and a <div> with a class of .modal, which will contain the modal's content and a button to self-close.\n\nWhen using this component inside the initial HTML structure, there are a number of potential issues:\n\nposition: fixed only places the element relative to the viewport when no ancestor element has transform, perspective or filter property set. If, for example, we intend to animate the ancestor <div class=\"outer\"> with a CSS transform, it would break the modal layout!\n\nThe modal's z-index is constrained by its containing elements. If there is another element that overlaps with <div class=\"outer\"> and has a higher z-index, it would cover our modal.\n\n<Teleport> provides a clean way to work around these, by allowing us to break out of the nested DOM structure. Let's modify <MyModal> to use <Teleport>:\n\ntemplate\n<button @click=\"open = true\">Open Modal</button>\n\n<Teleport to=\"body\">\n  <div v-if=\"open\" class=\"modal\">\n    <p>Hello from the modal!</p>\n    <button @click=\"open = false\">Close</button>\n  </div>\n</Teleport>\n\nThe to target of <Teleport> expects a CSS selector string or an actual DOM node. Here, we are essentially telling Vue to \"teleport this template fragment to the body tag\".\n\nYou can click the button below and inspect the <body> tag via your browser's devtools:\n\nOpen Modal\n\nYou can combine <Teleport> with <Transition> to create animated modals - see Example here.\n\nTIP\n\nThe teleport to target must be already in the DOM when the <Teleport> component is mounted. Ideally, this should be an element outside the entire Vue application. If targeting another element rendered by Vue, you need to make sure that element is mounted before the <Teleport>.\n\nUsing with Components\n​\n\n<Teleport> only alters the rendered DOM structure - it does not affect the logical hierarchy of the components. That is to say, if <Teleport> contains a component, that component will remain a logical child of the parent component containing the <Teleport>. Props passing and event emitting will continue to work the same way.\n\nThis also means that injections from a parent component work as expected, and that the child component will be nested below the parent component in the Vue Devtools, instead of being placed where the actual content moved to.\n\nDisabling Teleport\n​\n\nIn some cases, we may want to conditionally disable <Teleport>. For example, we may want to render a component as an overlay for desktop, but inline on mobile. <Teleport> supports the disabled prop which can be dynamically toggled:\n\ntemplate\n<Teleport :disabled=\"isMobile\">\n  ...\n</Teleport>\n\nWhere the isMobile state can be dynamically updated by detecting media query changes.\n\nMultiple Teleports on the Same Target\n​\n\nA common use case would be a reusable <Modal> component, with the potential for multiple instances to be active at the same time. For this kind of scenario, multiple <Teleport> components can mount their content to the same target element. The order will be a simple append - later mounts will be located after earlier ones within the target element.\n\nGiven the following usage:\n\ntemplate\n<Teleport to=\"#modals\">\n  <div>A</div>\n</Teleport>\n<Teleport to=\"#modals\">\n  <div>B</div>\n</Teleport>\n\nThe rendered result would be:\n\nhtml\n<div id=\"modals\">\n  <div>A</div>\n  <div>B</div>\n</div>\n\nRelated\n\n<Teleport> API reference\nHandling Teleports in SSR\n\nEdit this page on GitHub\n\n Previous\nKeepAlive\nNext \nSuspense\nTeleport has loaded"
  },
  {
    "title": "TransitionGroup | Vue.js",
    "url": "https://vuejs.org/guide/built-ins/transition-group",
    "html": "Skip to content\nGet 60% off a year of Vue Mastery courses\nGET DISCOUNT\nVue.js\nSearch\nCtrl\nK\nMain Navigation\nDocs\nAPI\nPlayground\nEcosystem\nAbout\nSponsor\nPartners\ngithub\ntwitter\ndiscord\nAPI Preference\nOptions\nComposition\n?\n\nAPI style now defaults to Composition API.\n\nSome pages contain different content based on the API style chosen. Use this switch to toggle between APIs styles.\n\nLearn moreGot it\n\nSidebar Navigation\nGetting Started\n\nIntroduction\n\nQuick Start\n\nEssentials\n\nCreating an Application\n\nTemplate Syntax\n\nReactivity Fundamentals\n\nComputed Properties\n\nClass and Style Bindings\n\nConditional Rendering\n\nList Rendering\n\nEvent Handling\n\nForm Input Bindings\n\nLifecycle Hooks\n\nWatchers\n\nTemplate Refs\n\nComponents Basics\n\nComponents In-Depth\n\nRegistration\n\nProps\n\nEvents\n\nComponent v-model\n\nFallthrough Attributes\n\nSlots\n\nProvide / inject\n\nAsync Components\n\nReusability\n\nComposables\n\nCustom Directives\n\nPlugins\n\nBuilt-in Components\n\nTransition\n\nTransitionGroup\n\nKeepAlive\n\nTeleport\n\nSuspense\n\nScaling Up\n\nSingle-File Components\n\nTooling\n\nRouting\n\nState Management\n\nTesting\n\nServer-Side Rendering (SSR)\n\nBest Practices\n\nProduction Deployment\n\nPerformance\n\nAccessibility\n\nSecurity\n\nTypeScript\n\nOverview\n\nTS with Composition API\n\nTS with Options API\n\nExtra Topics\n\nWays of Using Vue\n\nComposition API FAQ\n\nReactivity in Depth\n\nRendering Mechanism\n\nRender Functions & JSX\n\nVue and Web Components\n\nAnimation Techniques\n\nON THIS PAGE\nTable of Contents for current page\nDifferences from <Transition>\nEnter / Leave Transitions\nMove Transitions\nStaggering List Transitions\nSPONSORS\nBecome a Sponsor\nOnce, paying 50k for a web app security tool made sense. Not anymore. Start free with Aikido.\nADS VIA CARBON\nTransitionGroup\n​\n\n<TransitionGroup> is a built-in component designed for animating the insertion, removal, and order change of elements or components that are rendered in a list.\n\nDifferences from <Transition>\n​\n\n<TransitionGroup> supports the same props, CSS transition classes, and JavaScript hook listeners as <Transition>, with the following differences:\n\nBy default, it doesn't render a wrapper element. But you can specify an element to be rendered with the tag prop.\n\nTransition modes are not available, because we are no longer alternating between mutually exclusive elements.\n\nElements inside are always required to have a unique key attribute.\n\nCSS transition classes will be applied to individual elements in the list, not to the group / container itself.\n\nTIP\n\nWhen used in in-DOM templates, it should be referenced as <transition-group>.\n\nEnter / Leave Transitions\n​\n\nHere is an example of applying enter / leave transitions to a v-for list using <TransitionGroup>:\n\ntemplate\n<TransitionGroup name=\"list\" tag=\"ul\">\n  <li v-for=\"item in items\" :key=\"item\">\n    {{ item }}\n  </li>\n</TransitionGroup>\ncss\n.list-enter-active,\n.list-leave-active {\n  transition: all 0.5s ease;\n}\n.list-enter-from,\n.list-leave-to {\n  opacity: 0;\n  transform: translateX(30px);\n}\nAdd at random indexRemove at random index\n1\n2\n3\n4\n5\nMove Transitions\n​\n\nThe above demo has some obvious flaws: when an item is inserted or removed, its surrounding items instantly \"jump\" into place instead of moving smoothly. We can fix this by adding a few additional CSS rules:\n\ncss\n.list-move, /* apply transition to moving elements */\n.list-enter-active,\n.list-leave-active {\n  transition: all 0.5s ease;\n}\n\n.list-enter-from,\n.list-leave-to {\n  opacity: 0;\n  transform: translateX(30px);\n}\n\n/* ensure leaving items are taken out of layout flow so that moving\n   animations can be calculated correctly. */\n.list-leave-active {\n  position: absolute;\n}\n\nNow it looks much better - even animating smoothly when the whole list is shuffled:\n\nAddRemoveShuffle\n1\n2\n3\n4\n5\n\nFull Example\n\nStaggering List Transitions\n​\n\nBy communicating with JavaScript transitions through data attributes, it's also possible to stagger transitions in a list. First, we render the index of an item as a data attribute on the DOM element:\n\ntemplate\n<TransitionGroup\n  tag=\"ul\"\n  :css=\"false\"\n  @before-enter=\"onBeforeEnter\"\n  @enter=\"onEnter\"\n  @leave=\"onLeave\"\n>\n  <li\n    v-for=\"(item, index) in computedList\"\n    :key=\"item.msg\"\n    :data-index=\"index\"\n  >\n    {{ item.msg }}\n  </li>\n</TransitionGroup>\n\nThen, in JavaScript hooks, we animate the element with a delay based on the data attribute. This example is using the GSAP library to perform the animation:\n\njs\nfunction onEnter(el, done) {\n  gsap.to(el, {\n    opacity: 1,\n    height: '1.6em',\n    delay: el.dataset.index * 0.15,\n    onComplete: done\n  })\n}\nBruce Lee\nJackie Chan\nChuck Norris\nJet Li\nKung Fury\n\nFull Example in the Playground\n\nRelated\n\n<TransitionGroup> API reference\n\nEdit this page on GitHub\n\n Previous\nTransition\nNext \nKeepAlive\nTransitionGroup has loaded"
  },
  {
    "title": "KeepAlive | Vue.js",
    "url": "https://vuejs.org/guide/built-ins/keep-alive",
    "html": "Skip to content\nGet 60% off a year of Vue Mastery courses\nGET DISCOUNT\nVue.js\nSearch\nCtrl\nK\nMain Navigation\nDocs\nAPI\nPlayground\nEcosystem\nAbout\nSponsor\nPartners\ngithub\ntwitter\ndiscord\nAPI Preference\nOptions\nComposition\n?\n\nAPI style now defaults to Composition API.\n\nSome pages contain different content based on the API style chosen. Use this switch to toggle between APIs styles.\n\nLearn moreGot it\n\nSidebar Navigation\nGetting Started\n\nIntroduction\n\nQuick Start\n\nEssentials\n\nCreating an Application\n\nTemplate Syntax\n\nReactivity Fundamentals\n\nComputed Properties\n\nClass and Style Bindings\n\nConditional Rendering\n\nList Rendering\n\nEvent Handling\n\nForm Input Bindings\n\nLifecycle Hooks\n\nWatchers\n\nTemplate Refs\n\nComponents Basics\n\nComponents In-Depth\n\nRegistration\n\nProps\n\nEvents\n\nComponent v-model\n\nFallthrough Attributes\n\nSlots\n\nProvide / inject\n\nAsync Components\n\nReusability\n\nComposables\n\nCustom Directives\n\nPlugins\n\nBuilt-in Components\n\nTransition\n\nTransitionGroup\n\nKeepAlive\n\nTeleport\n\nSuspense\n\nScaling Up\n\nSingle-File Components\n\nTooling\n\nRouting\n\nState Management\n\nTesting\n\nServer-Side Rendering (SSR)\n\nBest Practices\n\nProduction Deployment\n\nPerformance\n\nAccessibility\n\nSecurity\n\nTypeScript\n\nOverview\n\nTS with Composition API\n\nTS with Options API\n\nExtra Topics\n\nWays of Using Vue\n\nComposition API FAQ\n\nReactivity in Depth\n\nRendering Mechanism\n\nRender Functions & JSX\n\nVue and Web Components\n\nAnimation Techniques\n\nON THIS PAGE\nTable of Contents for current page\nBasic Usage\nInclude / Exclude\nMax Cached Instances\nLifecycle of Cached Instance\nSPONSORS\nBecome a Sponsor\nAuth. Built for Devs, by Devs. Use our APIs & SDKs for all your authentication needs. Start free.\nADS VIA CARBON\nKeepAlive\n​\n\n<KeepAlive> is a built-in component that allows us to conditionally cache component instances when dynamically switching between multiple components.\n\nBasic Usage\n​\n\nIn the Component Basics chapter, we introduced the syntax for Dynamic Components, using the <component> special element:\n\ntemplate\n<component :is=\"activeComponent\" />\n\nBy default, an active component instance will be unmounted when switching away from it. This will cause any changed state it holds to be lost. When this component is displayed again, a new instance will be created with only the initial state.\n\nIn the example below, we have two stateful components - A contains a counter, while B contains a message synced with an input via v-model. Try updating the state of one of them, switch away, and then switch back to it:\n\n A B\n\nCurrent component: A\n\nCount: 0+\n\nYou'll notice that when switched back, the previous changed state would have been reset.\n\nCreating fresh component instance on switch is normally useful behavior, but in this case, we'd really like the two component instances to be preserved even when they are inactive. To solve this problem, we can wrap our dynamic component with the <KeepAlive> built-in component:\n\ntemplate\n<!-- Inactive components will be cached! -->\n<KeepAlive>\n  <component :is=\"activeComponent\" />\n</KeepAlive>\n\nNow, the state will be persisted across component switches:\n\n A B\n\nCurrent component: A\n\nCount: 0+\n\nTry it in the Playground\n\nTIP\n\nWhen used in in-DOM templates, it should be referenced as <keep-alive>.\n\nInclude / Exclude\n​\n\nBy default, <KeepAlive> will cache any component instance inside. We can customize this behavior via the include and exclude props. Both props can be a comma-delimited string, a RegExp, or an array containing either types:\n\ntemplate\n<!-- comma-delimited string -->\n<KeepAlive include=\"a,b\">\n  <component :is=\"view\" />\n</KeepAlive>\n\n<!-- regex (use `v-bind`) -->\n<KeepAlive :include=\"/a|b/\">\n  <component :is=\"view\" />\n</KeepAlive>\n\n<!-- Array (use `v-bind`) -->\n<KeepAlive :include=\"['a', 'b']\">\n  <component :is=\"view\" />\n</KeepAlive>\n\nThe match is checked against the component's name option, so components that need to be conditionally cached by KeepAlive must explicitly declare a name option.\n\nTIP\n\nSince version 3.2.34, a single-file component using <script setup> will automatically infer its name option based on the filename, removing the need to manually declare the name.\n\nMax Cached Instances\n​\n\nWe can limit the maximum number of component instances that can be cached via the max prop. When max is specified, <KeepAlive> behaves like an LRU cache: if the number of cached instances is about to exceed the specified max count, the least recently accessed cached instance will be destroyed to make room for the new one.\n\ntemplate\n<KeepAlive :max=\"10\">\n  <component :is=\"activeComponent\" />\n</KeepAlive>\nLifecycle of Cached Instance\n​\n\nWhen a component instance is removed from the DOM but is part of a component tree cached by <KeepAlive>, it goes into a deactivated state instead of being unmounted. When a component instance is inserted into the DOM as part of a cached tree, it is activated.\n\nA kept-alive component can register lifecycle hooks for these two states using onActivated() and onDeactivated():\n\nvue\n<script setup>\nimport { onActivated, onDeactivated } from 'vue'\n\nonActivated(() => {\n  // called on initial mount\n  // and every time it is re-inserted from the cache\n})\n\nonDeactivated(() => {\n  // called when removed from the DOM into the cache\n  // and also when unmounted\n})\n</script>\n\nNote that:\n\nonActivated is also called on mount, and onDeactivated on unmount.\n\nBoth hooks work for not only the root component cached by <KeepAlive>, but also the descendant components in the cached tree.\n\nRelated\n\n<KeepAlive> API reference\n\nEdit this page on GitHub\n\n Previous\nTransitionGroup\nNext \nTeleport\nKeepAlive has loaded"
  },
  {
    "title": "Transition | Vue.js",
    "url": "https://vuejs.org/guide/built-ins/transition",
    "html": "Skip to content\nGet 60% off a year of Vue Mastery courses\nGET DISCOUNT\nVue.js\nSearch\nCtrl\nK\nMain Navigation\nDocs\nAPI\nPlayground\nEcosystem\nAbout\nSponsor\nPartners\ngithub\ntwitter\ndiscord\nAPI Preference\nOptions\nComposition\n?\n\nAPI style now defaults to Composition API.\n\nSome pages contain different content based on the API style chosen. Use this switch to toggle between APIs styles.\n\nLearn moreGot it\n\nSidebar Navigation\nGetting Started\n\nIntroduction\n\nQuick Start\n\nEssentials\n\nCreating an Application\n\nTemplate Syntax\n\nReactivity Fundamentals\n\nComputed Properties\n\nClass and Style Bindings\n\nConditional Rendering\n\nList Rendering\n\nEvent Handling\n\nForm Input Bindings\n\nLifecycle Hooks\n\nWatchers\n\nTemplate Refs\n\nComponents Basics\n\nComponents In-Depth\n\nRegistration\n\nProps\n\nEvents\n\nComponent v-model\n\nFallthrough Attributes\n\nSlots\n\nProvide / inject\n\nAsync Components\n\nReusability\n\nComposables\n\nCustom Directives\n\nPlugins\n\nBuilt-in Components\n\nTransition\n\nTransitionGroup\n\nKeepAlive\n\nTeleport\n\nSuspense\n\nScaling Up\n\nSingle-File Components\n\nTooling\n\nRouting\n\nState Management\n\nTesting\n\nServer-Side Rendering (SSR)\n\nBest Practices\n\nProduction Deployment\n\nPerformance\n\nAccessibility\n\nSecurity\n\nTypeScript\n\nOverview\n\nTS with Composition API\n\nTS with Options API\n\nExtra Topics\n\nWays of Using Vue\n\nComposition API FAQ\n\nReactivity in Depth\n\nRendering Mechanism\n\nRender Functions & JSX\n\nVue and Web Components\n\nAnimation Techniques\n\nON THIS PAGE\nTable of Contents for current page\nThe <Transition> Component\nCSS-Based Transitions\nJavaScript Hooks\nReusable Transitions\nTransition on Appear\nTransition Between Elements\nTransition Modes\nTransition Between Components\nDynamic Transitions\nTransitions with the Key Attribute\nSPONSORS\nBecome a Sponsor\nYour Baremetal Lifeline: Online Guides if you get stuck. Let's Dive In, Shall We?\nADS VIA CARBON\nTransition\n​\n\nVue offers two built-in components that can help work with transitions and animations in response to changing state:\n\n<Transition> for applying animations when an element or component is entering and leaving the DOM. This is covered on this page.\n\n<TransitionGroup> for applying animations when an element or component is inserted into, removed from, or moved within a v-for list. This is covered in the next chapter.\n\nAside from these two components, we can also apply animations in Vue using other techniques such as toggling CSS classes or state-driven animations via style bindings. These additional techniques are covered in the Animation Techniques chapter.\n\nThe <Transition> Component\n​\n\n<Transition> is a built-in component: this means it is available in any component's template without having to register it. It can be used to apply enter and leave animations on elements or components passed to it via its default slot. The enter or leave can be triggered by one of the following:\n\nConditional rendering via v-if\nConditional display via v-show\nDynamic components toggling via the <component> special element\nChanging the special key attribute\n\nThis is an example of the most basic usage:\n\ntemplate\n<button @click=\"show = !show\">Toggle</button>\n<Transition>\n  <p v-if=\"show\">hello</p>\n</Transition>\ncss\n/* we will explain what these classes do next! */\n.v-enter-active,\n.v-leave-active {\n  transition: opacity 0.5s ease;\n}\n\n.v-enter-from,\n.v-leave-to {\n  opacity: 0;\n}\nToggle Fade\n\nhello\n\nTry it in the Playground\n\nTIP\n\n<Transition> only supports a single element or component as its slot content. If the content is a component, the component must also have only one single root element.\n\nWhen an element in a <Transition> component is inserted or removed, this is what happens:\n\nVue will automatically sniff whether the target element has CSS transitions or animations applied. If it does, a number of CSS transition classes will be added / removed at appropriate timings.\n\nIf there are listeners for JavaScript hooks, these hooks will be called at appropriate timings.\n\nIf no CSS transitions / animations are detected and no JavaScript hooks are provided, the DOM operations for insertion and/or removal will be executed on the browser's next animation frame.\n\nCSS-Based Transitions\n​\nTransition Classes\n​\n\nThere are six classes applied for enter / leave transitions.\n\nv-enter-from: Starting state for enter. Added before the element is inserted, removed one frame after the element is inserted.\n\nv-enter-active: Active state for enter. Applied during the entire entering phase. Added before the element is inserted, removed when the transition/animation finishes. This class can be used to define the duration, delay and easing curve for the entering transition.\n\nv-enter-to: Ending state for enter. Added one frame after the element is inserted (at the same time v-enter-from is removed), removed when the transition/animation finishes.\n\nv-leave-from: Starting state for leave. Added immediately when a leaving transition is triggered, removed after one frame.\n\nv-leave-active: Active state for leave. Applied during the entire leaving phase. Added immediately when a leaving transition is triggered, removed when the transition/animation finishes. This class can be used to define the duration, delay and easing curve for the leaving transition.\n\nv-leave-to: Ending state for leave. Added one frame after a leaving transition is triggered (at the same time v-leave-from is removed), removed when the transition/animation finishes.\n\nv-enter-active and v-leave-active give us the ability to specify different easing curves for enter / leave transitions, which we'll see an example of in the following sections.\n\nNamed Transitions\n​\n\nA transition can be named via the name prop:\n\ntemplate\n<Transition name=\"fade\">\n  ...\n</Transition>\n\nFor a named transition, its transition classes will be prefixed with its name instead of v. For example, the applied class for the above transition will be fade-enter-active instead of v-enter-active. The CSS for the fade transition should look like this:\n\ncss\n.fade-enter-active,\n.fade-leave-active {\n  transition: opacity 0.5s ease;\n}\n\n.fade-enter-from,\n.fade-leave-to {\n  opacity: 0;\n}\nCSS Transitions\n​\n\n<Transition> is most commonly used in combination with native CSS transitions, as seen in the basic example above. The transition CSS property is a shorthand that allows us to specify multiple aspects of a transition, including properties that should be animated, duration of the transition, and easing curves.\n\nHere is a more advanced example that transitions multiple properties, with different durations and easing curves for enter and leave:\n\ntemplate\n<Transition name=\"slide-fade\">\n  <p v-if=\"show\">hello</p>\n</Transition>\ncss\n/*\n  Enter and leave animations can use different\n  durations and timing functions.\n*/\n.slide-fade-enter-active {\n  transition: all 0.3s ease-out;\n}\n\n.slide-fade-leave-active {\n  transition: all 0.8s cubic-bezier(1, 0.5, 0.8, 1);\n}\n\n.slide-fade-enter-from,\n.slide-fade-leave-to {\n  transform: translateX(20px);\n  opacity: 0;\n}\nToggle Slide + Fade\n\nhello\n\nTry it in the Playground\n\nCSS Animations\n​\n\nNative CSS animations are applied in the same way as CSS transitions, with the difference being that *-enter-from is not removed immediately after the element is inserted, but on an animationend event.\n\nFor most CSS animations, we can simply declare them under the *-enter-active and *-leave-active classes. Here's an example:\n\ntemplate\n<Transition name=\"bounce\">\n  <p v-if=\"show\" style=\"text-align: center;\">\n    Hello here is some bouncy text!\n  </p>\n</Transition>\ncss\n.bounce-enter-active {\n  animation: bounce-in 0.5s;\n}\n.bounce-leave-active {\n  animation: bounce-in 0.5s reverse;\n}\n@keyframes bounce-in {\n  0% {\n    transform: scale(0);\n  }\n  50% {\n    transform: scale(1.25);\n  }\n  100% {\n    transform: scale(1);\n  }\n}\nToggle\n\nHello here is some bouncy text!\n\nTry it in the Playground\n\nCustom Transition Classes\n​\n\nYou can also specify custom transition classes by passing the following props to <Transition>:\n\nenter-from-class\nenter-active-class\nenter-to-class\nleave-from-class\nleave-active-class\nleave-to-class\n\nThese will override the conventional class names. This is especially useful when you want to combine Vue's transition system with an existing CSS animation library, such as Animate.css:\n\ntemplate\n<!-- assuming Animate.css is included on the page -->\n<Transition\n  name=\"custom-classes\"\n  enter-active-class=\"animate__animated animate__tada\"\n  leave-active-class=\"animate__animated animate__bounceOutRight\"\n>\n  <p v-if=\"show\">hello</p>\n</Transition>\n\nTry it in the Playground\n\nUsing Transitions and Animations Together\n​\n\nVue needs to attach event listeners in order to know when a transition has ended. It can either be transitionend or animationend, depending on the type of CSS rules applied. If you are only using one or the other, Vue can automatically detect the correct type.\n\nHowever, in some cases you may want to have both on the same element, for example having a CSS animation triggered by Vue, along with a CSS transition effect on hover. In these cases, you will have to explicitly declare the type you want Vue to care about by passing the type prop, with a value of either animation or transition:\n\ntemplate\n<Transition type=\"animation\">...</Transition>\nNested Transitions and Explicit Transition Durations\n​\n\nAlthough the transition classes are only applied to the direct child element in <Transition>, we can transition nested elements using nested CSS selectors:\n\ntemplate\n<Transition name=\"nested\">\n  <div v-if=\"show\" class=\"outer\">\n    <div class=\"inner\">\n      Hello\n    </div>\n  </div>\n</Transition>\ncss\n/* rules that target nested elements */\n.nested-enter-active .inner,\n.nested-leave-active .inner {\n  transition: all 0.3s ease-in-out;\n}\n\n.nested-enter-from .inner,\n.nested-leave-to .inner {\n  transform: translateX(30px);\n  opacity: 0;\n}\n\n/* ... other necessary CSS omitted */\n\nWe can even add a transition delay to the nested element on enter, which creates a staggered enter animation sequence:\n\ncss\n/* delay enter of nested element for staggered effect */\n.nested-enter-active .inner {\n  transition-delay: 0.25s;\n}\n\nHowever, this creates a small issue. By default, the <Transition> component attempts to automatically figure out when the transition has finished by listening to the first transitionend or animationend event on the root transition element. With a nested transition, the desired behavior should be waiting until the transitions of all inner elements have finished.\n\nIn such cases you can specify an explicit transition duration (in milliseconds) using the duration prop on the <transition> component. The total duration should match the delay plus transition duration of the inner element:\n\ntemplate\n<Transition :duration=\"550\">...</Transition>\nToggle\nHello\n\nTry it in the Playground\n\nIf necessary, you can also specify separate values for enter and leave durations using an object:\n\ntemplate\n<Transition :duration=\"{ enter: 500, leave: 800 }\">...</Transition>\nPerformance Considerations\n​\n\nYou may notice that the animations shown above are mostly using properties like transform and opacity. These properties are efficient to animate because:\n\nThey do not affect the document layout during the animation, so they do not trigger expensive CSS layout calculation on every animation frame.\n\nMost modern browsers can leverage GPU hardware acceleration when animating transform.\n\nIn comparison, properties like height or margin will trigger CSS layout, so they are much more expensive to animate, and should be used with caution.\n\nJavaScript Hooks\n​\n\nYou can hook into the transition process with JavaScript by listening to events on the <Transition> component:\n\nhtml\n<Transition\n  @before-enter=\"onBeforeEnter\"\n  @enter=\"onEnter\"\n  @after-enter=\"onAfterEnter\"\n  @enter-cancelled=\"onEnterCancelled\"\n  @before-leave=\"onBeforeLeave\"\n  @leave=\"onLeave\"\n  @after-leave=\"onAfterLeave\"\n  @leave-cancelled=\"onLeaveCancelled\"\n>\n  <!-- ... -->\n</Transition>\njs\n// called before the element is inserted into the DOM.\n// use this to set the \"enter-from\" state of the element\nfunction onBeforeEnter(el) {}\n\n// called one frame after the element is inserted.\n// use this to start the entering animation.\nfunction onEnter(el, done) {\n  // call the done callback to indicate transition end\n  // optional if used in combination with CSS\n  done()\n}\n\n// called when the enter transition has finished.\nfunction onAfterEnter(el) {}\n\n// called when the enter transition is cancelled before completion.\nfunction onEnterCancelled(el) {}\n\n// called before the leave hook.\n// Most of the time, you should just use the leave hook\nfunction onBeforeLeave(el) {}\n\n// called when the leave transition starts.\n// use this to start the leaving animation.\nfunction onLeave(el, done) {\n  // call the done callback to indicate transition end\n  // optional if used in combination with CSS\n  done()\n}\n\n// called when the leave transition has finished and the\n// element has been removed from the DOM.\nfunction onAfterLeave(el) {}\n\n// only available with v-show transitions\nfunction onLeaveCancelled(el) {}\n\nThese hooks can be used in combination with CSS transitions / animations or on their own.\n\nWhen using JavaScript-only transitions, it is usually a good idea to add the :css=\"false\" prop. This explicitly tells Vue to skip auto CSS transition detection. Aside from being slightly more performant, this also prevents CSS rules from accidentally interfering with the transition:\n\ntemplate\n<Transition\n  ...\n  :css=\"false\"\n>\n  ...\n</Transition>\n\nWith :css=\"false\", we are also fully responsible for controlling when the transition ends. In this case, the done callbacks are required for the @enter and @leave hooks. Otherwise, the hooks will be called synchronously and the transition will finish immediately.\n\nHere's a demo using the GSAP library to perform the animations. You can, of course, use any other animation library you want, for example Anime.js or Motion One:\n\nToggle\n\nTry it in the Playground\n\nReusable Transitions\n​\n\nTransitions can be reused through Vue's component system. To create a reusable transition, we can create a component that wraps the <Transition> component and passes down the slot content:\n\nvue\n<!-- MyTransition.vue -->\n<script>\n// JavaScript hooks logic...\n</script>\n\n<template>\n  <!-- wrap the built-in Transition component -->\n  <Transition\n    name=\"my-transition\"\n    @enter=\"onEnter\"\n    @leave=\"onLeave\">\n    <slot></slot> <!-- pass down slot content -->\n  </Transition>\n</template>\n\n<style>\n/*\n  Necessary CSS...\n  Note: avoid using <style scoped> here since it\n  does not apply to slot content.\n*/\n</style>\n\nNow MyTransition can be imported and used just like the built-in version:\n\ntemplate\n<MyTransition>\n  <div v-if=\"show\">Hello</div>\n</MyTransition>\nTransition on Appear\n​\n\nIf you also want to apply a transition on the initial render of a node, you can add the appear prop:\n\ntemplate\n<Transition appear>\n  ...\n</Transition>\nTransition Between Elements\n​\n\nIn addition to toggling an element with v-if / v-show, we can also transition between two elements using v-if / v-else / v-else-if, as long as we make sure that there is only one element being shown at any given moment:\n\ntemplate\n<Transition>\n  <button v-if=\"docState === 'saved'\">Edit</button>\n  <button v-else-if=\"docState === 'edited'\">Save</button>\n  <button v-else-if=\"docState === 'editing'\">Cancel</button>\n</Transition>\nClick to cycle through states:\nEdit\n\nTry it in the Playground\n\nTransition Modes\n​\n\nIn the previous example, the entering and leaving elements are animated at the same time, and we had to make them position: absolute to avoid the layout issue when both elements are present in the DOM.\n\nHowever, in some cases this isn't an option, or simply isn't the desired behavior. We may want the leaving element to be animated out first, and for the entering element to only be inserted after the leaving animation has finished. Orchestrating such animations manually would be very complicated - luckily, we can enable this behavior by passing <Transition> a mode prop:\n\ntemplate\n<Transition mode=\"out-in\">\n  ...\n</Transition>\n\nHere's the previous demo with mode=\"out-in\":\n\nClick to cycle through states:\nEdit\n\n<Transition> also supports mode=\"in-out\", although it's much less frequently used.\n\nTransition Between Components\n​\n\n<Transition> can also be used around dynamic components:\n\ntemplate\n<Transition name=\"fade\" mode=\"out-in\">\n  <component :is=\"activeComponent\"></component>\n</Transition>\n A  B\nComponent A\n\nTry it in the Playground\n\nDynamic Transitions\n​\n\n<Transition> props like name can also be dynamic! It allows us to dynamically apply different transitions based on state change:\n\ntemplate\n<Transition :name=\"transitionName\">\n  <!-- ... -->\n</Transition>\n\nThis can be useful when you've defined CSS transitions / animations using Vue's transition class conventions and want to switch between them.\n\nYou can also apply different behavior in JavaScript transition hooks based on the current state of your component. Finally, the ultimate way of creating dynamic transitions is through reusable transition components that accept props to change the nature of the transition(s) to be used. It may sound cheesy, but the only limit really is your imagination.\n\nTransitions with the Key Attribute\n​\n\nSometimes you need to force the re-render of a DOM element in order for a transition to occur.\n\nTake this counter component for example:\n\nvue\n<script setup>\nimport { ref } from 'vue';\nconst count = ref(0);\n\nsetInterval(() => count.value++, 1000);\n</script>\n\n<template>\n  <Transition>\n    <span :key=\"count\">{{ count }}</span>\n  </Transition>\n</template>\n\nIf we had excluded the key attribute, only the text node would be updated and thus no transition would occur. However, with the key attribute in place, Vue knows to create a new span element whenever count changes and thus the Transition component has 2 different elements to transition between.\n\nTry it in the Playground\n\nRelated\n\n<Transition> API reference\n\nEdit this page on GitHub\n\n Previous\nPlugins\nNext \nTransitionGroup\nTransition has loaded"
  },
  {
    "title": "Plugins | Vue.js",
    "url": "https://vuejs.org/guide/reusability/plugins",
    "html": "Skip to content\nGet 60% off a year of Vue Mastery courses\nGET DISCOUNT\nVue.js\nSearch\nCtrl\nK\nMain Navigation\nDocs\nAPI\nPlayground\nEcosystem\nAbout\nSponsor\nPartners\ngithub\ntwitter\ndiscord\nAPI Preference\nOptions\nComposition\n?\n\nAPI style now defaults to Composition API.\n\nSome pages contain different content based on the API style chosen. Use this switch to toggle between APIs styles.\n\nLearn moreGot it\n\nSidebar Navigation\nGetting Started\n\nIntroduction\n\nQuick Start\n\nEssentials\n\nCreating an Application\n\nTemplate Syntax\n\nReactivity Fundamentals\n\nComputed Properties\n\nClass and Style Bindings\n\nConditional Rendering\n\nList Rendering\n\nEvent Handling\n\nForm Input Bindings\n\nLifecycle Hooks\n\nWatchers\n\nTemplate Refs\n\nComponents Basics\n\nComponents In-Depth\n\nRegistration\n\nProps\n\nEvents\n\nComponent v-model\n\nFallthrough Attributes\n\nSlots\n\nProvide / inject\n\nAsync Components\n\nReusability\n\nComposables\n\nCustom Directives\n\nPlugins\n\nBuilt-in Components\n\nTransition\n\nTransitionGroup\n\nKeepAlive\n\nTeleport\n\nSuspense\n\nScaling Up\n\nSingle-File Components\n\nTooling\n\nRouting\n\nState Management\n\nTesting\n\nServer-Side Rendering (SSR)\n\nBest Practices\n\nProduction Deployment\n\nPerformance\n\nAccessibility\n\nSecurity\n\nTypeScript\n\nOverview\n\nTS with Composition API\n\nTS with Options API\n\nExtra Topics\n\nWays of Using Vue\n\nComposition API FAQ\n\nReactivity in Depth\n\nRendering Mechanism\n\nRender Functions & JSX\n\nVue and Web Components\n\nAnimation Techniques\n\nON THIS PAGE\nTable of Contents for current page\nIntroduction\nWriting a Plugin\nSPONSORS\nBecome a Sponsor\nPlugins\n​\nIntroduction\n​\n\nPlugins are self-contained code that usually add app-level functionality to Vue. This is how we install a plugin:\n\njs\nimport { createApp } from 'vue'\n\nconst app = createApp({})\n\napp.use(myPlugin, {\n  /* optional options */\n})\n\nA plugin is defined as either an object that exposes an install() method, or simply a function that acts as the install function itself. The install function receives the app instance along with additional options passed to app.use(), if any:\n\njs\nconst myPlugin = {\n  install(app, options) {\n    // configure the app\n  }\n}\n\nThere is no strictly defined scope for a plugin, but common scenarios where plugins are useful include:\n\nRegister one or more global components or custom directives with app.component() and app.directive().\n\nMake a resource injectable throughout the app by calling app.provide().\n\nAdd some global instance properties or methods by attaching them to app.config.globalProperties.\n\nA library that needs to perform some combination of the above (e.g. vue-router).\n\nWriting a Plugin\n​\n\nIn order to better understand how to create your own Vue.js plugins, we will create a very simplified version of a plugin that displays i18n (short for Internationalization) strings.\n\nLet's begin by setting up the plugin object. It is recommended to create it in a separate file and export it, as shown below to keep the logic contained and separate.\n\njs\n// plugins/i18n.js\nexport default {\n  install: (app, options) => {\n    // Plugin code goes here\n  }\n}\n\nWe want to create a translation function. This function will receive a dot-delimited key string, which we will use to look up the translated string in the user-provided options. This is the intended usage in templates:\n\ntemplate\n<h1>{{ $translate('greetings.hello') }}</h1>\n\nSince this function should be globally available in all templates, we will make it so by attaching it to app.config.globalProperties in our plugin:\n\njs\n// plugins/i18n.js\nexport default {\n  install: (app, options) => {\n    // inject a globally available $translate() method\n    app.config.globalProperties.$translate = (key) => {\n      // retrieve a nested property in `options`\n      // using `key` as the path\n      return key.split('.').reduce((o, i) => {\n        if (o) return o[i]\n      }, options)\n    }\n  }\n}\n\nOur $translate function will take a string such as greetings.hello, look inside the user provided configuration and return the translated value.\n\nThe object containing the translated keys should be passed to the plugin during installation via additional parameters to app.use():\n\njs\nimport i18nPlugin from './plugins/i18n'\n\napp.use(i18nPlugin, {\n  greetings: {\n    hello: 'Bonjour!'\n  }\n})\n\nNow, our initial expression $translate('greetings.hello') will be replaced by Bonjour! at runtime.\n\nSee also: Augmenting Global Properties \n\nTIP\n\nUse global properties scarcely, since it can quickly become confusing if too many global properties injected by different plugins are used throughout an app.\n\nProvide / Inject with Plugins\n​\n\nPlugins also allow us to use inject to provide a function or attribute to the plugin's users. For example, we can allow the application to have access to the options parameter to be able to use the translations object.\n\njs\n// plugins/i18n.js\nexport default {\n  install: (app, options) => {\n    app.provide('i18n', options)\n  }\n}\n\nPlugin users will now be able to inject the plugin options into their components using the i18n key:\n\nvue\n<script setup>\nimport { inject } from 'vue'\n\nconst i18n = inject('i18n')\n\nconsole.log(i18n.greetings.hello)\n</script>\n\nEdit this page on GitHub\n\n Previous\nCustom Directives\nNext \nTransition\nPlugins has loaded"
  },
  {
    "title": "Custom Directives | Vue.js",
    "url": "https://vuejs.org/guide/reusability/custom-directives",
    "html": "Skip to content\nGet 60% off a year of Vue Mastery courses\nGET DISCOUNT\nVue.js\nSearch\nCtrl\nK\nMain Navigation\nDocs\nAPI\nPlayground\nEcosystem\nAbout\nSponsor\nPartners\ngithub\ntwitter\ndiscord\nAPI Preference\nOptions\nComposition\n?\n\nAPI style now defaults to Composition API.\n\nSome pages contain different content based on the API style chosen. Use this switch to toggle between APIs styles.\n\nLearn moreGot it\n\nSidebar Navigation\nGetting Started\n\nIntroduction\n\nQuick Start\n\nEssentials\n\nCreating an Application\n\nTemplate Syntax\n\nReactivity Fundamentals\n\nComputed Properties\n\nClass and Style Bindings\n\nConditional Rendering\n\nList Rendering\n\nEvent Handling\n\nForm Input Bindings\n\nLifecycle Hooks\n\nWatchers\n\nTemplate Refs\n\nComponents Basics\n\nComponents In-Depth\n\nRegistration\n\nProps\n\nEvents\n\nComponent v-model\n\nFallthrough Attributes\n\nSlots\n\nProvide / inject\n\nAsync Components\n\nReusability\n\nComposables\n\nCustom Directives\n\nPlugins\n\nBuilt-in Components\n\nTransition\n\nTransitionGroup\n\nKeepAlive\n\nTeleport\n\nSuspense\n\nScaling Up\n\nSingle-File Components\n\nTooling\n\nRouting\n\nState Management\n\nTesting\n\nServer-Side Rendering (SSR)\n\nBest Practices\n\nProduction Deployment\n\nPerformance\n\nAccessibility\n\nSecurity\n\nTypeScript\n\nOverview\n\nTS with Composition API\n\nTS with Options API\n\nExtra Topics\n\nWays of Using Vue\n\nComposition API FAQ\n\nReactivity in Depth\n\nRendering Mechanism\n\nRender Functions & JSX\n\nVue and Web Components\n\nAnimation Techniques\n\nON THIS PAGE\nTable of Contents for current page\nIntroduction\nDirective Hooks\nFunction Shorthand\nObject Literals\nUsage on Components\nSPONSORS\nBecome a Sponsor\nCustom Directives\n​\nIntroduction\n​\n\nIn addition to the default set of directives shipped in core (like v-model or v-show), Vue also allows you to register your own custom directives.\n\nWe have introduced two forms of code reuse in Vue: components and composables. Components are the main building blocks, while composables are focused on reusing stateful logic. Custom directives, on the other hand, are mainly intended for reusing logic that involves low-level DOM access on plain elements.\n\nA custom directive is defined as an object containing lifecycle hooks similar to those of a component. The hooks receive the element the directive is bound to. Here is an example of a directive that focuses an input when the element is inserted into the DOM by Vue:\n\nvue\n<script setup>\n// enables v-focus in templates\nconst vFocus = {\n  mounted: (el) => el.focus()\n}\n</script>\n\n<template>\n  <input v-focus />\n</template>\n\nAssuming you haven't clicked elsewhere on the page, the input above should be auto-focused. This directive is more useful than the autofocus attribute because it works not just on page load - it also works when the element is dynamically inserted by Vue.\n\nIn <script setup>, any camelCase variable that starts with the v prefix can be used as a custom directive. In the example above, vFocus can be used in the template as v-focus.\n\nIf not using <script setup>, custom directives can be registered using the directives option:\n\njs\nexport default {\n  setup() {\n    /*...*/\n  },\n  directives: {\n    // enables v-focus in template\n    focus: {\n      /* ... */\n    }\n  }\n}\n\nIt is also common to globally register custom directives at the app level:\n\njs\nconst app = createApp({})\n\n// make v-focus usable in all components\napp.directive('focus', {\n  /* ... */\n})\n\nTIP\n\nCustom directives should only be used when the desired functionality can only be achieved via direct DOM manipulation. Prefer declarative templating using built-in directives such as v-bind when possible because they are more efficient and server-rendering friendly.\n\nDirective Hooks\n​\n\nA directive definition object can provide several hook functions (all optional):\n\njs\nconst myDirective = {\n  // called before bound element's attributes\n  // or event listeners are applied\n  created(el, binding, vnode, prevVnode) {\n    // see below for details on arguments\n  },\n  // called right before the element is inserted into the DOM.\n  beforeMount(el, binding, vnode, prevVnode) {},\n  // called when the bound element's parent component\n  // and all its children are mounted.\n  mounted(el, binding, vnode, prevVnode) {},\n  // called before the parent component is updated\n  beforeUpdate(el, binding, vnode, prevVnode) {},\n  // called after the parent component and\n  // all of its children have updated\n  updated(el, binding, vnode, prevVnode) {},\n  // called before the parent component is unmounted\n  beforeUnmount(el, binding, vnode, prevVnode) {},\n  // called when the parent component is unmounted\n  unmounted(el, binding, vnode, prevVnode) {}\n}\nHook Arguments\n​\n\nDirective hooks are passed these arguments:\n\nel: the element the directive is bound to. This can be used to directly manipulate the DOM.\n\nbinding: an object containing the following properties.\n\nvalue: The value passed to the directive. For example in v-my-directive=\"1 + 1\", the value would be 2.\noldValue: The previous value, only available in beforeUpdate and updated. It is available whether or not the value has changed.\narg: The argument passed to the directive, if any. For example in v-my-directive:foo, the arg would be \"foo\".\nmodifiers: An object containing modifiers, if any. For example in v-my-directive.foo.bar, the modifiers object would be { foo: true, bar: true }.\ninstance: The instance of the component where the directive is used.\ndir: the directive definition object.\n\nvnode: the underlying VNode representing the bound element.\n\nprevVnode: the VNode representing the bound element from the previous render. Only available in the beforeUpdate and updated hooks.\n\nAs an example, consider the following directive usage:\n\ntemplate\n<div v-example:foo.bar=\"baz\">\n\nThe binding argument would be an object in the shape of:\n\njs\n{\n  arg: 'foo',\n  modifiers: { bar: true },\n  value: /* value of `baz` */,\n  oldValue: /* value of `baz` from previous update */\n}\n\nSimilar to built-in directives, custom directive arguments can be dynamic. For example:\n\ntemplate\n<div v-example:[arg]=\"value\"></div>\n\nHere the directive argument will be reactively updated based on arg property in our component state.\n\nNote\n\nApart from el, you should treat these arguments as read-only and never modify them. If you need to share information across hooks, it is recommended to do so through element's dataset.\n\nFunction Shorthand\n​\n\nIt's common for a custom directive to have the same behavior for mounted and updated, with no need for the other hooks. In such cases we can define the directive as a function:\n\ntemplate\n<div v-color=\"color\"></div>\njs\napp.directive('color', (el, binding) => {\n  // this will be called for both `mounted` and `updated`\n  el.style.color = binding.value\n})\nObject Literals\n​\n\nIf your directive needs multiple values, you can also pass in a JavaScript object literal. Remember, directives can take any valid JavaScript expression.\n\ntemplate\n<div v-demo=\"{ color: 'white', text: 'hello!' }\"></div>\njs\napp.directive('demo', (el, binding) => {\n  console.log(binding.value.color) // => \"white\"\n  console.log(binding.value.text) // => \"hello!\"\n})\nUsage on Components\n​\n\nNot recommended\n\nUsing custom directives on components is not recommended. Unexpected behaviour may occur when a component has multiple root nodes.\n\nWhen used on components, custom directives will always apply to a component's root node, similar to Fallthrough Attributes.\n\ntemplate\n<MyComponent v-demo=\"test\" />\ntemplate\n<!-- template of MyComponent -->\n\n<div> <!-- v-demo directive will be applied here -->\n  <span>My component content</span>\n</div>\n\nNote that components can potentially have more than one root node. When applied to a multi-root component, a directive will be ignored and a warning will be thrown. Unlike attributes, directives can't be passed to a different element with v-bind=\"$attrs\".\n\nEdit this page on GitHub\n\n Previous\nComposables\nNext \nPlugins\nCustom Directives has loaded"
  },
  {
    "title": "Composables | Vue.js",
    "url": "https://vuejs.org/guide/reusability/composables",
    "html": "Skip to content\nGet 60% off a year of Vue Mastery courses\nGET DISCOUNT\nVue.js\nSearch\nCtrl\nK\nMain Navigation\nDocs\nAPI\nPlayground\nEcosystem\nAbout\nSponsor\nPartners\ngithub\ntwitter\ndiscord\nAPI Preference\nOptions\nComposition\n?\n\nAPI style now defaults to Composition API.\n\nSome pages contain different content based on the API style chosen. Use this switch to toggle between APIs styles.\n\nLearn moreGot it\n\nSidebar Navigation\nGetting Started\n\nIntroduction\n\nQuick Start\n\nEssentials\n\nCreating an Application\n\nTemplate Syntax\n\nReactivity Fundamentals\n\nComputed Properties\n\nClass and Style Bindings\n\nConditional Rendering\n\nList Rendering\n\nEvent Handling\n\nForm Input Bindings\n\nLifecycle Hooks\n\nWatchers\n\nTemplate Refs\n\nComponents Basics\n\nComponents In-Depth\n\nRegistration\n\nProps\n\nEvents\n\nComponent v-model\n\nFallthrough Attributes\n\nSlots\n\nProvide / inject\n\nAsync Components\n\nReusability\n\nComposables\n\nCustom Directives\n\nPlugins\n\nBuilt-in Components\n\nTransition\n\nTransitionGroup\n\nKeepAlive\n\nTeleport\n\nSuspense\n\nScaling Up\n\nSingle-File Components\n\nTooling\n\nRouting\n\nState Management\n\nTesting\n\nServer-Side Rendering (SSR)\n\nBest Practices\n\nProduction Deployment\n\nPerformance\n\nAccessibility\n\nSecurity\n\nTypeScript\n\nOverview\n\nTS with Composition API\n\nTS with Options API\n\nExtra Topics\n\nWays of Using Vue\n\nComposition API FAQ\n\nReactivity in Depth\n\nRendering Mechanism\n\nRender Functions & JSX\n\nVue and Web Components\n\nAnimation Techniques\n\nON THIS PAGE\nTable of Contents for current page\nWhat is a \"Composable\"?\nMouse Tracker Example\nAsync State Example\nConventions and Best Practices\nExtracting Composables for Code Organization\nUsing Composables in Options API\nComparisons with Other Techniques\nFurther Reading\nSPONSORS\nBecome a Sponsor\nComposables\n​\n\nTIP\n\nThis section assumes basic knowledge of Composition API. If you have been learning Vue with Options API only, you can set the API Preference to Composition API (using the toggle at the top of the left sidebar) and re-read the Reactivity Fundamentals and Lifecycle Hooks chapters.\n\nWhat is a \"Composable\"?\n​\n\nIn the context of Vue applications, a \"composable\" is a function that leverages Vue's Composition API to encapsulate and reuse stateful logic.\n\nWhen building frontend applications, we often need to reuse logic for common tasks. For example, we may need to format dates in many places, so we extract a reusable function for that. This formatter function encapsulates stateless logic: it takes some input and immediately returns expected output. There are many libraries out there for reusing stateless logic - for example lodash and date-fns, which you may have heard of.\n\nBy contrast, stateful logic involves managing state that changes over time. A simple example would be tracking the current position of the mouse on a page. In real-world scenarios, it could also be more complex logic such as touch gestures or connection status to a database.\n\nMouse Tracker Example\n​\n\nIf we were to implement the mouse tracking functionality using the Composition API directly inside a component, it would look like this:\n\nvue\n<script setup>\nimport { ref, onMounted, onUnmounted } from 'vue'\n\nconst x = ref(0)\nconst y = ref(0)\n\nfunction update(event) {\n  x.value = event.pageX\n  y.value = event.pageY\n}\n\nonMounted(() => window.addEventListener('mousemove', update))\nonUnmounted(() => window.removeEventListener('mousemove', update))\n</script>\n\n<template>Mouse position is at: {{ x }}, {{ y }}</template>\n\nBut what if we want to reuse the same logic in multiple components? We can extract the logic into an external file, as a composable function:\n\njs\n// mouse.js\nimport { ref, onMounted, onUnmounted } from 'vue'\n\n// by convention, composable function names start with \"use\"\nexport function useMouse() {\n  // state encapsulated and managed by the composable\n  const x = ref(0)\n  const y = ref(0)\n\n  // a composable can update its managed state over time.\n  function update(event) {\n    x.value = event.pageX\n    y.value = event.pageY\n  }\n\n  // a composable can also hook into its owner component's\n  // lifecycle to setup and teardown side effects.\n  onMounted(() => window.addEventListener('mousemove', update))\n  onUnmounted(() => window.removeEventListener('mousemove', update))\n\n  // expose managed state as return value\n  return { x, y }\n}\n\nAnd this is how it can be used in components:\n\nvue\n<script setup>\nimport { useMouse } from './mouse.js'\n\nconst { x, y } = useMouse()\n</script>\n\n<template>Mouse position is at: {{ x }}, {{ y }}</template>\nMouse position is at: 0, 0\n\nTry it in the Playground\n\nAs we can see, the core logic remains identical - all we had to do was move it into an external function and return the state that should be exposed. Just like inside a component, you can use the full range of Composition API functions in composables. The same useMouse() functionality can now be used in any component.\n\nThe cooler part about composables though, is that you can also nest them: one composable function can call one or more other composable functions. This enables us to compose complex logic using small, isolated units, similar to how we compose an entire application using components. In fact, this is why we decided to call the collection of APIs that make this pattern possible Composition API.\n\nFor example, we can extract the logic of adding and removing a DOM event listener into its own composable:\n\njs\n// event.js\nimport { onMounted, onUnmounted } from 'vue'\n\nexport function useEventListener(target, event, callback) {\n  // if you want, you can also make this\n  // support selector strings as target\n  onMounted(() => target.addEventListener(event, callback))\n  onUnmounted(() => target.removeEventListener(event, callback))\n}\n\nAnd now our useMouse() composable can be simplified to:\n\njs\n// mouse.js\nimport { ref } from 'vue'\nimport { useEventListener } from './event'\n\nexport function useMouse() {\n  const x = ref(0)\n  const y = ref(0)\n\n  useEventListener(window, 'mousemove', (event) => {\n    x.value = event.pageX\n    y.value = event.pageY\n  })\n\n  return { x, y }\n}\n\nTIP\n\nEach component instance calling useMouse() will create its own copies of x and y state so they won't interfere with one another. If you want to manage shared state between components, read the State Management chapter.\n\nAsync State Example\n​\n\nThe useMouse() composable doesn't take any arguments, so let's take a look at another example that makes use of one. When doing async data fetching, we often need to handle different states: loading, success, and error:\n\nvue\n<script setup>\nimport { ref } from 'vue'\n\nconst data = ref(null)\nconst error = ref(null)\n\nfetch('...')\n  .then((res) => res.json())\n  .then((json) => (data.value = json))\n  .catch((err) => (error.value = err))\n</script>\n\n<template>\n  <div v-if=\"error\">Oops! Error encountered: {{ error.message }}</div>\n  <div v-else-if=\"data\">\n    Data loaded:\n    <pre>{{ data }}</pre>\n  </div>\n  <div v-else>Loading...</div>\n</template>\n\nIt would be tedious to have to repeat this pattern in every component that needs to fetch data. Let's extract it into a composable:\n\njs\n// fetch.js\nimport { ref } from 'vue'\n\nexport function useFetch(url) {\n  const data = ref(null)\n  const error = ref(null)\n\n  fetch(url)\n    .then((res) => res.json())\n    .then((json) => (data.value = json))\n    .catch((err) => (error.value = err))\n\n  return { data, error }\n}\n\nNow in our component we can just do:\n\nvue\n<script setup>\nimport { useFetch } from './fetch.js'\n\nconst { data, error } = useFetch('...')\n</script>\nAccepting Reactive State\n​\n\nuseFetch() takes a static URL string as input - so it performs the fetch only once and is then done. What if we want it to re-fetch whenever the URL changes? In order to achieve this, we need to pass reactive state into the composable function, and let the composable create watchers that perform actions using the passed state.\n\nFor example, useFetch() should be able to accept a ref:\n\njs\nconst url = ref('/initial-url')\n\nconst { data, error } = useFetch(url)\n\n// this should trigger a re-fetch\nurl.value = '/new-url'\n\nOr, accept a getter function:\n\njs\n// re-fetch when props.id changes\nconst { data, error } = useFetch(() => `/posts/${props.id}`)\n\nWe can refactor our existing implementation with the watchEffect() and toValue() APIs:\n\njs\n// fetch.js\nimport { ref, watchEffect, toValue } from 'vue'\n\nexport function useFetch(url) {\n  const data = ref(null)\n  const error = ref(null)\n\n  const fetchData = () => {\n    // reset state before fetching..\n    data.value = null\n    error.value = null\n\n    fetch(toValue(url))\n      .then((res) => res.json())\n      .then((json) => (data.value = json))\n      .catch((err) => (error.value = err))\n  }\n\n  watchEffect(() => {\n    fetchData()\n  })\n\n  return { data, error }\n}\n\ntoValue() is an API added in 3.3. It is designed to normalize refs or getters into values. If the argument is a ref, it returns the ref's value; if the argument is a function, it will call the function and return its return value. Otherwise, it returns the argument as-is. It works similarly to unref(), but with special treatment for functions.\n\nNotice that toValue(url) is called inside the watchEffect callback. This ensures that any reactive dependencies accessed during the toValue() normalization are tracked by the watcher.\n\nThis version of useFetch() now accepts static URL strings, refs, and getters, making it much more flexible. The watch effect will run immediately, and will track any dependencies accessed during toValue(url). If no dependencies are tracked (e.g. url is already a string), the effect runs only once; otherwise, it will re-run whenever a tracked dependency changes.\n\nHere's the updated version of useFetch(), with an artificial delay and randomized error for demo purposes.\n\nConventions and Best Practices\n​\nNaming\n​\n\nIt is a convention to name composable functions with camelCase names that start with \"use\".\n\nInput Arguments\n​\n\nA composable can accept ref or getter arguments even if it doesn't rely on them for reactivity. If you are writing a composable that may be used by other developers, it's a good idea to handle the case of input arguments being refs or getters instead of raw values. The toValue() utility function will come in handy for this purpose:\n\njs\nimport { toValue } from 'vue'\n\nfunction useFeature(maybeRefOrGetter) {\n  // If maybeRefOrGetter is a ref or a getter,\n  // its normalized value will be returned.\n  // Otherwise, it is returned as-is.\n  const value = toValue(maybeRefOrGetter)\n}\n\nIf your composable creates reactive effects when the input is a ref or a getter, make sure to either explicitly watch the ref / getter with watch(), or call toValue() inside a watchEffect() so that it is properly tracked.\n\nThe useFetch() implementation discussed earlier provides a concrete example of a composable that accepts refs, getters and plain values as input argument.\n\nReturn Values\n​\n\nYou have probably noticed that we have been exclusively using ref() instead of reactive() in composables. The recommended convention is for composables to always return a plain, non-reactive object containing multiple refs. This allows it to be destructured in components while retaining reactivity:\n\njs\n// x and y are refs\nconst { x, y } = useMouse()\n\nReturning a reactive object from a composable will cause such destructures to lose the reactivity connection to the state inside the composable, while the refs will retain that connection.\n\nIf you prefer to use returned state from composables as object properties, you can wrap the returned object with reactive() so that the refs are unwrapped. For example:\n\njs\nconst mouse = reactive(useMouse())\n// mouse.x is linked to original ref\nconsole.log(mouse.x)\ntemplate\nMouse position is at: {{ mouse.x }}, {{ mouse.y }}\nSide Effects\n​\n\nIt is OK to perform side effects (e.g. adding DOM event listeners or fetching data) in composables, but pay attention to the following rules:\n\nIf you are working on an application that uses Server-Side Rendering (SSR), make sure to perform DOM-specific side effects in post-mount lifecycle hooks, e.g. onMounted(). These hooks are only called in the browser, so you can be sure that code inside them has access to the DOM.\n\nRemember to clean up side effects in onUnmounted(). For example, if a composable sets up a DOM event listener, it should remove that listener in onUnmounted() as we have seen in the useMouse() example. It can be a good idea to use a composable that automatically does this for you, like the useEventListener() example.\n\nUsage Restrictions\n​\n\nComposables should only be called in <script setup> or the setup() hook. They should also be called synchronously in these contexts. In some cases, you can also call them in lifecycle hooks like onMounted().\n\nThese restrictions are important because these are the contexts where Vue is able to determine the current active component instance. Access to an active component instance is necessary so that:\n\nLifecycle hooks can be registered to it.\n\nComputed properties and watchers can be linked to it, so that they can be disposed when the instance is unmounted to prevent memory leaks.\n\nTIP\n\n<script setup> is the only place where you can call composables after using await. The compiler automatically restores the active instance context for you after the async operation.\n\nExtracting Composables for Code Organization\n​\n\nComposables can be extracted not only for reuse, but also for code organization. As the complexity of your components grow, you may end up with components that are too large to navigate and reason about. Composition API gives you the full flexibility to organize your component code into smaller functions based on logical concerns:\n\nvue\n<script setup>\nimport { useFeatureA } from './featureA.js'\nimport { useFeatureB } from './featureB.js'\nimport { useFeatureC } from './featureC.js'\n\nconst { foo, bar } = useFeatureA()\nconst { baz } = useFeatureB(foo)\nconst { qux } = useFeatureC(baz)\n</script>\n\nTo some extent, you can think of these extracted composables as component-scoped services that can talk to one another.\n\nUsing Composables in Options API\n​\n\nIf you are using Options API, composables must be called inside setup(), and the returned bindings must be returned from setup() so that they are exposed to this and the template:\n\njs\nimport { useMouse } from './mouse.js'\nimport { useFetch } from './fetch.js'\n\nexport default {\n  setup() {\n    const { x, y } = useMouse()\n    const { data, error } = useFetch('...')\n    return { x, y, data, error }\n  },\n  mounted() {\n    // setup() exposed properties can be accessed on `this`\n    console.log(this.x)\n  }\n  // ...other options\n}\nComparisons with Other Techniques\n​\nvs. Mixins\n​\n\nUsers coming from Vue 2 may be familiar with the mixins option, which also allows us to extract component logic into reusable units. There are three primary drawbacks to mixins:\n\nUnclear source of properties: when using many mixins, it becomes unclear which instance property is injected by which mixin, making it difficult to trace the implementation and understand the component's behavior. This is also why we recommend using the refs + destructure pattern for composables: it makes the property source clear in consuming components.\n\nNamespace collisions: multiple mixins from different authors can potentially register the same property keys, causing namespace collisions. With composables, you can rename the destructured variables if there are conflicting keys from different composables.\n\nImplicit cross-mixin communication: multiple mixins that need to interact with one another have to rely on shared property keys, making them implicitly coupled. With composables, values returned from one composable can be passed into another as arguments, just like normal functions.\n\nFor the above reasons, we no longer recommend using mixins in Vue 3. The feature is kept only for migration and familiarity reasons.\n\nvs. Renderless Components\n​\n\nIn the component slots chapter, we discussed the Renderless Component pattern based on scoped slots. We even implemented the same mouse tracking demo using renderless components.\n\nThe main advantage of composables over renderless components is that composables do not incur the extra component instance overhead. When used across an entire application, the amount of extra component instances created by the renderless component pattern can become a noticeable performance overhead.\n\nThe recommendation is to use composables when reusing pure logic, and use components when reusing both logic and visual layout.\n\nvs. React Hooks\n​\n\nIf you have experience with React, you may notice that this looks very similar to custom React hooks. Composition API was in part inspired by React hooks, and Vue composables are indeed similar to React hooks in terms of logic composition capabilities. However, Vue composables are based on Vue's fine-grained reactivity system, which is fundamentally different from React hooks' execution model. This is discussed in more detail in the Composition API FAQ.\n\nFurther Reading\n​\nReactivity In Depth: for a low-level understanding of how Vue's reactivity system works.\nState Management: for patterns of managing state shared by multiple components.\nTesting Composables: tips on unit testing composables.\nVueUse: an ever-growing collection of Vue composables. The source code is also a great learning resource.\n\nEdit this page on GitHub\n\n Previous\nAsync Components\nNext \nCustom Directives\nComposables has loaded"
  },
  {
    "title": "Async Components | Vue.js",
    "url": "https://vuejs.org/guide/components/async",
    "html": "Skip to content\nGet 60% off a year of Vue Mastery courses\nGET DISCOUNT\nVue.js\nSearch\nCtrl\nK\nMain Navigation\nDocs\nAPI\nPlayground\nEcosystem\nAbout\nSponsor\nPartners\ngithub\ntwitter\ndiscord\nAPI Preference\nOptions\nComposition\n?\n\nAPI style now defaults to Composition API.\n\nSome pages contain different content based on the API style chosen. Use this switch to toggle between APIs styles.\n\nLearn moreGot it\n\nSidebar Navigation\nGetting Started\n\nIntroduction\n\nQuick Start\n\nEssentials\n\nCreating an Application\n\nTemplate Syntax\n\nReactivity Fundamentals\n\nComputed Properties\n\nClass and Style Bindings\n\nConditional Rendering\n\nList Rendering\n\nEvent Handling\n\nForm Input Bindings\n\nLifecycle Hooks\n\nWatchers\n\nTemplate Refs\n\nComponents Basics\n\nComponents In-Depth\n\nRegistration\n\nProps\n\nEvents\n\nComponent v-model\n\nFallthrough Attributes\n\nSlots\n\nProvide / inject\n\nAsync Components\n\nReusability\n\nComposables\n\nCustom Directives\n\nPlugins\n\nBuilt-in Components\n\nTransition\n\nTransitionGroup\n\nKeepAlive\n\nTeleport\n\nSuspense\n\nScaling Up\n\nSingle-File Components\n\nTooling\n\nRouting\n\nState Management\n\nTesting\n\nServer-Side Rendering (SSR)\n\nBest Practices\n\nProduction Deployment\n\nPerformance\n\nAccessibility\n\nSecurity\n\nTypeScript\n\nOverview\n\nTS with Composition API\n\nTS with Options API\n\nExtra Topics\n\nWays of Using Vue\n\nComposition API FAQ\n\nReactivity in Depth\n\nRendering Mechanism\n\nRender Functions & JSX\n\nVue and Web Components\n\nAnimation Techniques\n\nON THIS PAGE\nTable of Contents for current page\nBasic Usage\nLoading and Error States\nUsing with Suspense\nSPONSORS\nBecome a Sponsor\nAsync Components\n​\nBasic Usage\n​\n\nIn large applications, we may need to divide the app into smaller chunks and only load a component from the server when it's needed. To make that possible, Vue has a defineAsyncComponent function:\n\njs\nimport { defineAsyncComponent } from 'vue'\n\nconst AsyncComp = defineAsyncComponent(() => {\n  return new Promise((resolve, reject) => {\n    // ...load component from server\n    resolve(/* loaded component */)\n  })\n})\n// ... use `AsyncComp` like a normal component\n\nAs you can see, defineAsyncComponent accepts a loader function that returns a Promise. The Promise's resolve callback should be called when you have retrieved your component definition from the server. You can also call reject(reason) to indicate the load has failed.\n\nES module dynamic import also returns a Promise, so most of the time we will use it in combination with defineAsyncComponent. Bundlers like Vite and webpack also support the syntax (and will use it as bundle split points), so we can use it to import Vue SFCs:\n\njs\nimport { defineAsyncComponent } from 'vue'\n\nconst AsyncComp = defineAsyncComponent(() =>\n  import('./components/MyComponent.vue')\n)\n\nThe resulting AsyncComp is a wrapper component that only calls the loader function when it is actually rendered on the page. In addition, it will pass along any props and slots to the inner component, so you can use the async wrapper to seamlessly replace the original component while achieving lazy loading.\n\nAs with normal components, async components can be registered globally using app.component():\n\njs\napp.component('MyComponent', defineAsyncComponent(() =>\n  import('./components/MyComponent.vue')\n))\n\nThey can also be defined directly inside their parent component:\n\nvue\n<script setup>\nimport { defineAsyncComponent } from 'vue'\n\nconst AdminPage = defineAsyncComponent(() =>\n  import('./components/AdminPageComponent.vue')\n)\n</script>\n\n<template>\n  <AdminPage />\n</template>\nLoading and Error States\n​\n\nAsynchronous operations inevitably involve loading and error states - defineAsyncComponent() supports handling these states via advanced options:\n\njs\nconst AsyncComp = defineAsyncComponent({\n  // the loader function\n  loader: () => import('./Foo.vue'),\n\n  // A component to use while the async component is loading\n  loadingComponent: LoadingComponent,\n  // Delay before showing the loading component. Default: 200ms.\n  delay: 200,\n\n  // A component to use if the load fails\n  errorComponent: ErrorComponent,\n  // The error component will be displayed if a timeout is\n  // provided and exceeded. Default: Infinity.\n  timeout: 3000\n})\n\nIf a loading component is provided, it will be displayed first while the inner component is being loaded. There is a default 200ms delay before the loading component is shown - this is because on fast networks, an instant loading state may get replaced too fast and end up looking like a flicker.\n\nIf an error component is provided, it will be displayed when the Promise returned by the loader function is rejected. You can also specify a timeout to show the error component when the request is taking too long.\n\nUsing with Suspense\n​\n\nAsync components can be used with the <Suspense> built-in component. The interaction between <Suspense> and async components is documented in the dedicated chapter for <Suspense>.\n\nEdit this page on GitHub\n\n Previous\nProvide / inject\nNext \nComposables\nAsync Components has loaded"
  },
  {
    "title": "Provide / Inject | Vue.js",
    "url": "https://vuejs.org/guide/components/provide-inject",
    "html": "Skip to content\nGet 60% off a year of Vue Mastery courses\nGET DISCOUNT\nVue.js\nSearch\nCtrl\nK\nMain Navigation\nDocs\nAPI\nPlayground\nEcosystem\nAbout\nSponsor\nPartners\ngithub\ntwitter\ndiscord\nAPI Preference\nOptions\nComposition\n?\n\nAPI style now defaults to Composition API.\n\nSome pages contain different content based on the API style chosen. Use this switch to toggle between APIs styles.\n\nLearn moreGot it\n\nSidebar Navigation\nGetting Started\n\nIntroduction\n\nQuick Start\n\nEssentials\n\nCreating an Application\n\nTemplate Syntax\n\nReactivity Fundamentals\n\nComputed Properties\n\nClass and Style Bindings\n\nConditional Rendering\n\nList Rendering\n\nEvent Handling\n\nForm Input Bindings\n\nLifecycle Hooks\n\nWatchers\n\nTemplate Refs\n\nComponents Basics\n\nComponents In-Depth\n\nRegistration\n\nProps\n\nEvents\n\nComponent v-model\n\nFallthrough Attributes\n\nSlots\n\nProvide / inject\n\nAsync Components\n\nReusability\n\nComposables\n\nCustom Directives\n\nPlugins\n\nBuilt-in Components\n\nTransition\n\nTransitionGroup\n\nKeepAlive\n\nTeleport\n\nSuspense\n\nScaling Up\n\nSingle-File Components\n\nTooling\n\nRouting\n\nState Management\n\nTesting\n\nServer-Side Rendering (SSR)\n\nBest Practices\n\nProduction Deployment\n\nPerformance\n\nAccessibility\n\nSecurity\n\nTypeScript\n\nOverview\n\nTS with Composition API\n\nTS with Options API\n\nExtra Topics\n\nWays of Using Vue\n\nComposition API FAQ\n\nReactivity in Depth\n\nRendering Mechanism\n\nRender Functions & JSX\n\nVue and Web Components\n\nAnimation Techniques\n\nON THIS PAGE\nTable of Contents for current page\nProp Drilling\nProvide\nApp-level Provide\nInject\nWorking with Reactivity\nWorking with Symbol Keys\nSPONSORS\nBecome a Sponsor\nGet an instant overview of all your code & cloud security issues with Aikido Security. Start free.\nADS VIA CARBON\nProvide / Inject\n​\n\nThis page assumes you've already read the Components Basics. Read that first if you are new to components.\n\nProp Drilling\n​\n\nUsually, when we need to pass data from the parent to a child component, we use props. However, imagine the case where we have a large component tree, and a deeply nested component needs something from a distant ancestor component. With only props, we would have to pass the same prop across the entire parent chain:\n\nNotice although the <Footer> component may not care about these props at all, it still needs to declare and pass them along just so <DeepChild> can access them. If there is a longer parent chain, more components would be affected along the way. This is called \"props drilling\" and definitely isn't fun to deal with.\n\nWe can solve props drilling with provide and inject. A parent component can serve as a dependency provider for all its descendants. Any component in the descendant tree, regardless of how deep it is, can inject dependencies provided by components up in its parent chain.\n\nProvide\n​\n\nTo provide data to a component's descendants, use the provide() function:\n\nvue\n<script setup>\nimport { provide } from 'vue'\n\nprovide(/* key */ 'message', /* value */ 'hello!')\n</script>\n\nIf not using <script setup>, make sure provide() is called synchronously inside setup():\n\njs\nimport { provide } from 'vue'\n\nexport default {\n  setup() {\n    provide(/* key */ 'message', /* value */ 'hello!')\n  }\n}\n\nThe provide() function accepts two arguments. The first argument is called the injection key, which can be a string or a Symbol. The injection key is used by descendant components to lookup the desired value to inject. A single component can call provide() multiple times with different injection keys to provide different values.\n\nThe second argument is the provided value. The value can be of any type, including reactive state such as refs:\n\njs\nimport { ref, provide } from 'vue'\n\nconst count = ref(0)\nprovide('key', count)\n\nProviding reactive values allows the descendant components using the provided value to establish a reactive connection to the provider component.\n\nApp-level Provide\n​\n\nIn addition to providing data in a component, we can also provide at the app level:\n\njs\nimport { createApp } from 'vue'\n\nconst app = createApp({})\n\napp.provide(/* key */ 'message', /* value */ 'hello!')\n\nApp-level provides are available to all components rendered in the app. This is especially useful when writing plugins, as plugins typically wouldn't be able to provide values using components.\n\nInject\n​\n\nTo inject data provided by an ancestor component, use the inject() function:\n\nvue\n<script setup>\nimport { inject } from 'vue'\n\nconst message = inject('message')\n</script>\n\nIf the provided value is a ref, it will be injected as-is and will not be automatically unwrapped. This allows the injector component to retain the reactivity connection to the provider component.\n\nFull provide + inject Example with Reactivity\n\nAgain, if not using <script setup>, inject() should only be called synchronously inside setup():\n\njs\nimport { inject } from 'vue'\n\nexport default {\n  setup() {\n    const message = inject('message')\n    return { message }\n  }\n}\nInjection Default Values\n​\n\nBy default, inject assumes that the injected key is provided somewhere in the parent chain. In the case where the key is not provided, there will be a runtime warning.\n\nIf we want to make an injected property work with optional providers, we need to declare a default value, similar to props:\n\njs\n// `value` will be \"default value\"\n// if no data matching \"message\" was provided\nconst value = inject('message', 'default value')\n\nIn some cases, the default value may need to be created by calling a function or instantiating a new class. To avoid unnecessary computation or side effects in case the optional value is not used, we can use a factory function for creating the default value:\n\njs\nconst value = inject('key', () => new ExpensiveClass(), true)\n\nThe third parameter indicates the default value should be treated as a factory function.\n\nWorking with Reactivity\n​\n\nWhen using reactive provide / inject values, it is recommended to keep any mutations to reactive state inside of the provider whenever possible. This ensures that the provided state and its possible mutations are co-located in the same component, making it easier to maintain in the future.\n\nThere may be times when we need to update the data from an injector component. In such cases, we recommend providing a function that is responsible for mutating the state:\n\nvue\n<!-- inside provider component -->\n<script setup>\nimport { provide, ref } from 'vue'\n\nconst location = ref('North Pole')\n\nfunction updateLocation() {\n  location.value = 'South Pole'\n}\n\nprovide('location', {\n  location,\n  updateLocation\n})\n</script>\nvue\n<!-- in injector component -->\n<script setup>\nimport { inject } from 'vue'\n\nconst { location, updateLocation } = inject('location')\n</script>\n\n<template>\n  <button @click=\"updateLocation\">{{ location }}</button>\n</template>\n\nFinally, you can wrap the provided value with readonly() if you want to ensure that the data passed through provide cannot be mutated by the injector component.\n\nvue\n<script setup>\nimport { ref, provide, readonly } from 'vue'\n\nconst count = ref(0)\nprovide('read-only-count', readonly(count))\n</script>\nWorking with Symbol Keys\n​\n\nSo far, we have been using string injection keys in the examples. If you are working in a large application with many dependency providers, or you are authoring components that are going to be used by other developers, it is best to use Symbol injection keys to avoid potential collisions.\n\nIt's recommended to export the Symbols in a dedicated file:\n\njs\n// keys.js\nexport const myInjectionKey = Symbol()\njs\n// in provider component\nimport { provide } from 'vue'\nimport { myInjectionKey } from './keys.js'\n\nprovide(myInjectionKey, {\n  /* data to provide */\n})\njs\n// in injector component\nimport { inject } from 'vue'\nimport { myInjectionKey } from './keys.js'\n\nconst injected = inject(myInjectionKey)\n\nSee also: Typing Provide / Inject \n\nEdit this page on GitHub\n\n Previous\nSlots\nNext \nAsync Components\nProvide / Inject has loaded"
  },
  {
    "title": "Slots | Vue.js",
    "url": "https://vuejs.org/guide/components/slots",
    "html": "Skip to content\nGet 60% off a year of Vue Mastery courses\nGET DISCOUNT\nVue.js\nSearch\nCtrl\nK\nMain Navigation\nDocs\nAPI\nPlayground\nEcosystem\nAbout\nSponsor\nPartners\ngithub\ntwitter\ndiscord\nAPI Preference\nOptions\nComposition\n?\n\nAPI style now defaults to Composition API.\n\nSome pages contain different content based on the API style chosen. Use this switch to toggle between APIs styles.\n\nLearn moreGot it\n\nSidebar Navigation\nGetting Started\n\nIntroduction\n\nQuick Start\n\nEssentials\n\nCreating an Application\n\nTemplate Syntax\n\nReactivity Fundamentals\n\nComputed Properties\n\nClass and Style Bindings\n\nConditional Rendering\n\nList Rendering\n\nEvent Handling\n\nForm Input Bindings\n\nLifecycle Hooks\n\nWatchers\n\nTemplate Refs\n\nComponents Basics\n\nComponents In-Depth\n\nRegistration\n\nProps\n\nEvents\n\nComponent v-model\n\nFallthrough Attributes\n\nSlots\n\nProvide / inject\n\nAsync Components\n\nReusability\n\nComposables\n\nCustom Directives\n\nPlugins\n\nBuilt-in Components\n\nTransition\n\nTransitionGroup\n\nKeepAlive\n\nTeleport\n\nSuspense\n\nScaling Up\n\nSingle-File Components\n\nTooling\n\nRouting\n\nState Management\n\nTesting\n\nServer-Side Rendering (SSR)\n\nBest Practices\n\nProduction Deployment\n\nPerformance\n\nAccessibility\n\nSecurity\n\nTypeScript\n\nOverview\n\nTS with Composition API\n\nTS with Options API\n\nExtra Topics\n\nWays of Using Vue\n\nComposition API FAQ\n\nReactivity in Depth\n\nRendering Mechanism\n\nRender Functions & JSX\n\nVue and Web Components\n\nAnimation Techniques\n\nON THIS PAGE\nTable of Contents for current page\nSlot Content and Outlet\nRender Scope\nFallback Content\nNamed Slots\nConditional Slots\nDynamic Slot Names\nScoped Slots\nSPONSORS\nBecome a Sponsor\nShip Code. Not Containers. Render, the modern cloud for software teams.\nADS VIA CARBON\nSlots\n​\n\nThis page assumes you've already read the Components Basics. Read that first if you are new to components.\n\nWatch a free video lesson on Vue School\nSlot Content and Outlet\n​\n\nWe have learned that components can accept props, which can be JavaScript values of any type. But how about template content? In some cases, we may want to pass a template fragment to a child component, and let the child component render the fragment within its own template.\n\nFor example, we may have a <FancyButton> component that supports usage like this:\n\ntemplate\n<FancyButton>\n  Click me! <!-- slot content -->\n</FancyButton>\n\nThe template of <FancyButton> looks like this:\n\ntemplate\n<button class=\"fancy-btn\">\n  <slot></slot> <!-- slot outlet -->\n</button>\n\nThe <slot> element is a slot outlet that indicates where the parent-provided slot content should be rendered.\n\nAnd the final rendered DOM:\n\nhtml\n<button class=\"fancy-btn\">Click me!</button>\n\nTry it in the Playground\n\nWith slots, the <FancyButton> is responsible for rendering the outer <button> (and its fancy styling), while the inner content is provided by the parent component.\n\nAnother way to understand slots is by comparing them to JavaScript functions:\n\njs\n// parent component passing slot content\nFancyButton('Click me!')\n\n// FancyButton renders slot content in its own template\nfunction FancyButton(slotContent) {\n  return `<button class=\"fancy-btn\">\n      ${slotContent}\n    </button>`\n}\n\nSlot content is not just limited to text. It can be any valid template content. For example, we can pass in multiple elements, or even other components:\n\ntemplate\n<FancyButton>\n  <span style=\"color:red\">Click me!</span>\n  <AwesomeIcon name=\"plus\" />\n</FancyButton>\n\nTry it in the Playground\n\nBy using slots, our <FancyButton> is more flexible and reusable. We can now use it in different places with different inner content, but all with the same fancy styling.\n\nVue components' slot mechanism is inspired by the native Web Component <slot> element, but with additional capabilities that we will see later.\n\nRender Scope\n​\n\nSlot content has access to the data scope of the parent component, because it is defined in the parent. For example:\n\ntemplate\n<span>{{ message }}</span>\n<FancyButton>{{ message }}</FancyButton>\n\nHere both {{ message }} interpolations will render the same content.\n\nSlot content does not have access to the child component's data. Expressions in Vue templates can only access the scope it is defined in, consistent with JavaScript's lexical scoping. In other words:\n\nExpressions in the parent template only have access to the parent scope; expressions in the child template only have access to the child scope.\n\nFallback Content\n​\n\nThere are cases when it's useful to specify fallback (i.e. default) content for a slot, to be rendered only when no content is provided. For example, in a <SubmitButton> component:\n\ntemplate\n<button type=\"submit\">\n  <slot></slot>\n</button>\n\nWe might want the text \"Submit\" to be rendered inside the <button> if the parent didn't provide any slot content. To make \"Submit\" the fallback content, we can place it in between the <slot> tags:\n\ntemplate\n<button type=\"submit\">\n  <slot>\n    Submit <!-- fallback content -->\n  </slot>\n</button>\n\nNow when we use <SubmitButton> in a parent component, providing no content for the slot:\n\ntemplate\n<SubmitButton />\n\nThis will render the fallback content, \"Submit\":\n\nhtml\n<button type=\"submit\">Submit</button>\n\nBut if we provide content:\n\ntemplate\n<SubmitButton>Save</SubmitButton>\n\nThen the provided content will be rendered instead:\n\nhtml\n<button type=\"submit\">Save</button>\n\nTry it in the Playground\n\nNamed Slots\n​\n\nThere are times when it's useful to have multiple slot outlets in a single component. For example, in a <BaseLayout> component with the following template:\n\ntemplate\n<div class=\"container\">\n  <header>\n    <!-- We want header content here -->\n  </header>\n  <main>\n    <!-- We want main content here -->\n  </main>\n  <footer>\n    <!-- We want footer content here -->\n  </footer>\n</div>\n\nFor these cases, the <slot> element has a special attribute, name, which can be used to assign a unique ID to different slots so you can determine where content should be rendered:\n\ntemplate\n<div class=\"container\">\n  <header>\n    <slot name=\"header\"></slot>\n  </header>\n  <main>\n    <slot></slot>\n  </main>\n  <footer>\n    <slot name=\"footer\"></slot>\n  </footer>\n</div>\n\nA <slot> outlet without name implicitly has the name \"default\".\n\nIn a parent component using <BaseLayout>, we need a way to pass multiple slot content fragments, each targeting a different slot outlet. This is where named slots come in.\n\nTo pass a named slot, we need to use a <template> element with the v-slot directive, and then pass the name of the slot as an argument to v-slot:\n\ntemplate\n<BaseLayout>\n  <template v-slot:header>\n    <!-- content for the header slot -->\n  </template>\n</BaseLayout>\n\nv-slot has a dedicated shorthand #, so <template v-slot:header> can be shortened to just <template #header>. Think of it as \"render this template fragment in the child component's 'header' slot\".\n\nHere's the code passing content for all three slots to <BaseLayout> using the shorthand syntax:\n\ntemplate\n<BaseLayout>\n  <template #header>\n    <h1>Here might be a page title</h1>\n  </template>\n\n  <template #default>\n    <p>A paragraph for the main content.</p>\n    <p>And another one.</p>\n  </template>\n\n  <template #footer>\n    <p>Here's some contact info</p>\n  </template>\n</BaseLayout>\n\nWhen a component accepts both a default slot and named slots, all top-level non-<template> nodes are implicitly treated as content for the default slot. So the above can also be written as:\n\ntemplate\n<BaseLayout>\n  <template #header>\n    <h1>Here might be a page title</h1>\n  </template>\n\n  <!-- implicit default slot -->\n  <p>A paragraph for the main content.</p>\n  <p>And another one.</p>\n\n  <template #footer>\n    <p>Here's some contact info</p>\n  </template>\n</BaseLayout>\n\nNow everything inside the <template> elements will be passed to the corresponding slots. The final rendered HTML will be:\n\nhtml\n<div class=\"container\">\n  <header>\n    <h1>Here might be a page title</h1>\n  </header>\n  <main>\n    <p>A paragraph for the main content.</p>\n    <p>And another one.</p>\n  </main>\n  <footer>\n    <p>Here's some contact info</p>\n  </footer>\n</div>\n\nTry it in the Playground\n\nAgain, it may help you understand named slots better using the JavaScript function analogy:\n\njs\n// passing multiple slot fragments with different names\nBaseLayout({\n  header: `...`,\n  default: `...`,\n  footer: `...`\n})\n\n// <BaseLayout> renders them in different places\nfunction BaseLayout(slots) {\n  return `<div class=\"container\">\n      <header>${slots.header}</header>\n      <main>${slots.default}</main>\n      <footer>${slots.footer}</footer>\n    </div>`\n}\nConditional Slots\n​\n\nSometimes you want to render something based on whether or not a slot is present.\n\nYou can use the $slots property in combination with a v-if to achieve this.\n\nIn the example below we define a Card component with three conditional slots: header, footer and the default one. When the header / footer / default is present we want to wrap them to provide additional styling:\n\ntemplate\n<template>\n  <div class=\"card\">\n    <div v-if=\"$slots.header\" class=\"card-header\">\n      <slot name=\"header\" />\n    </div>\n    \n    <div v-if=\"$slots.default\" class=\"card-content\">\n      <slot />\n    </div>\n    \n    <div v-if=\"$slots.footer\" class=\"card-footer\">\n      <slot name=\"footer\" />\n    </div>\n  </div>\n</template>\n\nTry it in the Playground\n\nDynamic Slot Names\n​\n\nDynamic directive arguments also work on v-slot, allowing the definition of dynamic slot names:\n\ntemplate\n<base-layout>\n  <template v-slot:[dynamicSlotName]>\n    ...\n  </template>\n\n  <!-- with shorthand -->\n  <template #[dynamicSlotName]>\n    ...\n  </template>\n</base-layout>\n\nDo note the expression is subject to the syntax constraints of dynamic directive arguments.\n\nScoped Slots\n​\n\nAs discussed in Render Scope, slot content does not have access to state in the child component.\n\nHowever, there are cases where it could be useful if a slot's content can make use of data from both the parent scope and the child scope. To achieve that, we need a way for the child to pass data to a slot when rendering it.\n\nIn fact, we can do exactly that - we can pass attributes to a slot outlet just like passing props to a component:\n\ntemplate\n<!-- <MyComponent> template -->\n<div>\n  <slot :text=\"greetingMessage\" :count=\"1\"></slot>\n</div>\n\nReceiving the slot props is a bit different when using a single default slot vs. using named slots. We are going to show how to receive props using a single default slot first, by using v-slot directly on the child component tag:\n\ntemplate\n<MyComponent v-slot=\"slotProps\">\n  {{ slotProps.text }} {{ slotProps.count }}\n</MyComponent>\n\nTry it in the Playground\n\nThe props passed to the slot by the child are available as the value of the corresponding v-slot directive, which can be accessed by expressions inside the slot.\n\nYou can think of a scoped slot as a function being passed into the child component. The child component then calls it, passing props as arguments:\n\njs\nMyComponent({\n  // passing the default slot, but as a function\n  default: (slotProps) => {\n    return `${slotProps.text} ${slotProps.count}`\n  }\n})\n\nfunction MyComponent(slots) {\n  const greetingMessage = 'hello'\n  return `<div>${\n    // call the slot function with props!\n    slots.default({ text: greetingMessage, count: 1 })\n  }</div>`\n}\n\nIn fact, this is very close to how scoped slots are compiled, and how you would use scoped slots in manual render functions.\n\nNotice how v-slot=\"slotProps\" matches the slot function signature. Just like with function arguments, we can use destructuring in v-slot:\n\ntemplate\n<MyComponent v-slot=\"{ text, count }\">\n  {{ text }} {{ count }}\n</MyComponent>\nNamed Scoped Slots\n​\n\nNamed scoped slots work similarly - slot props are accessible as the value of the v-slot directive: v-slot:name=\"slotProps\". When using the shorthand, it looks like this:\n\ntemplate\n<MyComponent>\n  <template #header=\"headerProps\">\n    {{ headerProps }}\n  </template>\n\n  <template #default=\"defaultProps\">\n    {{ defaultProps }}\n  </template>\n\n  <template #footer=\"footerProps\">\n    {{ footerProps }}\n  </template>\n</MyComponent>\n\nPassing props to a named slot:\n\ntemplate\n<slot name=\"header\" message=\"hello\"></slot>\n\nNote the name of a slot won't be included in the props because it is reserved - so the resulting headerProps would be { message: 'hello' }.\n\nIf you are mixing named slots with the default scoped slot, you need to use an explicit <template> tag for the default slot. Attempting to place the v-slot directive directly on the component will result in a compilation error. This is to avoid any ambiguity about the scope of the props of the default slot. For example:\n\ntemplate\n<!-- <MyComponent> template -->\n<div>\n  <slot :message=\"hello\"></slot>\n  <slot name=\"footer\" />\n</div>\ntemplate\n<!-- This template won't compile -->\n<MyComponent v-slot=\"{ message }\">\n  <p>{{ message }}</p>\n  <template #footer>\n    <!-- message belongs to the default slot, and is not available here -->\n    <p>{{ message }}</p>\n  </template>\n</MyComponent>\n\nUsing an explicit <template> tag for the default slot helps to make it clear that the message prop is not available inside the other slot:\n\ntemplate\n<MyComponent>\n  <!-- Use explicit default slot -->\n  <template #default=\"{ message }\">\n    <p>{{ message }}</p>\n  </template>\n\n  <template #footer>\n    <p>Here's some contact info</p>\n  </template>\n</MyComponent>\nFancy List Example\n​\n\nYou may be wondering what would be a good use case for scoped slots. Here's an example: imagine a <FancyList> component that renders a list of items - it may encapsulate the logic for loading remote data, using the data to display a list, or even advanced features like pagination or infinite scrolling. However, we want it to be flexible with how each item looks and leave the styling of each item to the parent component consuming it. So the desired usage may look like this:\n\ntemplate\n<FancyList :api-url=\"url\" :per-page=\"10\">\n  <template #item=\"{ body, username, likes }\">\n    <div class=\"item\">\n      <p>{{ body }}</p>\n      <p>by {{ username }} | {{ likes }} likes</p>\n    </div>\n  </template>\n</FancyList>\n\nInside <FancyList>, we can render the same <slot> multiple times with different item data (notice we are using v-bind to pass an object as slot props):\n\ntemplate\n<ul>\n  <li v-for=\"item in items\">\n    <slot name=\"item\" v-bind=\"item\"></slot>\n  </li>\n</ul>\n\nTry it in the Playground\n\nRenderless Components\n​\n\nThe <FancyList> use case we discussed above encapsulates both reusable logic (data fetching, pagination etc.) and visual output, while delegating part of the visual output to the consumer component via scoped slots.\n\nIf we push this concept a bit further, we can come up with components that only encapsulate logic and do not render anything by themselves - visual output is fully delegated to the consumer component with scoped slots. We call this type of component a Renderless Component.\n\nAn example renderless component could be one that encapsulates the logic of tracking the current mouse position:\n\ntemplate\n<MouseTracker v-slot=\"{ x, y }\">\n  Mouse is at: {{ x }}, {{ y }}\n</MouseTracker>\n\nTry it in the Playground\n\nWhile an interesting pattern, most of what can be achieved with Renderless Components can be achieved in a more efficient fashion with Composition API, without incurring the overhead of extra component nesting. Later, we will see how we can implement the same mouse tracking functionality as a Composable.\n\nThat said, scoped slots are still useful in cases where we need to both encapsulate logic and compose visual output, like in the <FancyList> example.\n\nEdit this page on GitHub\n\n Previous\nFallthrough Attributes\nNext \nProvide / inject\nSlots has loaded"
  },
  {
    "title": "Fallthrough Attributes | Vue.js",
    "url": "https://vuejs.org/guide/components/attrs",
    "html": "Skip to content\nGet 60% off a year of Vue Mastery courses\nGET DISCOUNT\nVue.js\nSearch\nCtrl\nK\nMain Navigation\nDocs\nAPI\nPlayground\nEcosystem\nAbout\nSponsor\nPartners\ngithub\ntwitter\ndiscord\nAPI Preference\nOptions\nComposition\n?\n\nAPI style now defaults to Composition API.\n\nSome pages contain different content based on the API style chosen. Use this switch to toggle between APIs styles.\n\nLearn moreGot it\n\nSidebar Navigation\nGetting Started\n\nIntroduction\n\nQuick Start\n\nEssentials\n\nCreating an Application\n\nTemplate Syntax\n\nReactivity Fundamentals\n\nComputed Properties\n\nClass and Style Bindings\n\nConditional Rendering\n\nList Rendering\n\nEvent Handling\n\nForm Input Bindings\n\nLifecycle Hooks\n\nWatchers\n\nTemplate Refs\n\nComponents Basics\n\nComponents In-Depth\n\nRegistration\n\nProps\n\nEvents\n\nComponent v-model\n\nFallthrough Attributes\n\nSlots\n\nProvide / inject\n\nAsync Components\n\nReusability\n\nComposables\n\nCustom Directives\n\nPlugins\n\nBuilt-in Components\n\nTransition\n\nTransitionGroup\n\nKeepAlive\n\nTeleport\n\nSuspense\n\nScaling Up\n\nSingle-File Components\n\nTooling\n\nRouting\n\nState Management\n\nTesting\n\nServer-Side Rendering (SSR)\n\nBest Practices\n\nProduction Deployment\n\nPerformance\n\nAccessibility\n\nSecurity\n\nTypeScript\n\nOverview\n\nTS with Composition API\n\nTS with Options API\n\nExtra Topics\n\nWays of Using Vue\n\nComposition API FAQ\n\nReactivity in Depth\n\nRendering Mechanism\n\nRender Functions & JSX\n\nVue and Web Components\n\nAnimation Techniques\n\nON THIS PAGE\nTable of Contents for current page\nAttribute Inheritance\nclass and style Merging\nv-on Listener Inheritance\nNested Component Inheritance\nDisabling Attribute Inheritance\nAttribute Inheritance on Multiple Root Nodes\nAccessing Fallthrough Attributes in JavaScript\nSPONSORS\nBecome a Sponsor\nDowntime is expensive. Cloud Native keeps your business running\nADS VIA CARBON\nFallthrough Attributes\n​\n\nThis page assumes you've already read the Components Basics. Read that first if you are new to components.\n\nAttribute Inheritance\n​\n\nA \"fallthrough attribute\" is an attribute or v-on event listener that is passed to a component, but is not explicitly declared in the receiving component's props or emits. Common examples of this include class, style, and id attributes.\n\nWhen a component renders a single root element, fallthrough attributes will be automatically added to the root element's attributes. For example, given a <MyButton> component with the following template:\n\ntemplate\n<!-- template of <MyButton> -->\n<button>Click Me</button>\n\nAnd a parent using this component with:\n\ntemplate\n<MyButton class=\"large\" />\n\nThe final rendered DOM would be:\n\nhtml\n<button class=\"large\">Click Me</button>\n\nHere, <MyButton> did not declare class as an accepted prop. Therefore, class is treated as a fallthrough attribute and automatically added to <MyButton>'s root element.\n\nclass and style Merging\n​\n\nIf the child component's root element already has existing class or style attributes, it will be merged with the class and style values that are inherited from the parent. Suppose we change the template of <MyButton> in the previous example to:\n\ntemplate\n<!-- template of <MyButton> -->\n<button class=\"btn\">Click Me</button>\n\nThen the final rendered DOM would now become:\n\nhtml\n<button class=\"btn large\">Click Me</button>\nv-on Listener Inheritance\n​\n\nThe same rule applies to v-on event listeners:\n\ntemplate\n<MyButton @click=\"onClick\" />\n\nThe click listener will be added to the root element of <MyButton>, i.e. the native <button> element. When the native <button> is clicked, it will trigger the onClick method of the parent component. If the native <button> already has a click listener bound with v-on, then both listeners will trigger.\n\nNested Component Inheritance\n​\n\nIf a component renders another component as its root node, for example, we refactored <MyButton> to render a <BaseButton> as its root:\n\ntemplate\n<!-- template of <MyButton/> that simply renders another component -->\n<BaseButton />\n\nThen the fallthrough attributes received by <MyButton> will be automatically forwarded to <BaseButton>.\n\nNote that:\n\nForwarded attributes do not include any attributes that are declared as props, or v-on listeners of declared events by <MyButton> - in other words, the declared props and listeners have been \"consumed\" by <MyButton>.\n\nForwarded attributes may be accepted as props by <BaseButton>, if declared by it.\n\nDisabling Attribute Inheritance\n​\n\nIf you do not want a component to automatically inherit attributes, you can set inheritAttrs: false in the component's options.\n\nSince 3.3 you can also use defineOptions directly in <script setup>:\n\nvue\n<script setup>\ndefineOptions({\n  inheritAttrs: false\n})\n// ...setup logic\n</script>\n\nThe common scenario for disabling attribute inheritance is when attributes need to be applied to other elements besides the root node. By setting the inheritAttrs option to false, you can take full control over where the fallthrough attributes should be applied.\n\nThese fallthrough attributes can be accessed directly in template expressions as $attrs:\n\ntemplate\n<span>Fallthrough attributes: {{ $attrs }}</span>\n\nThe $attrs object includes all attributes that are not declared by the component's props or emits options (e.g., class, style, v-on listeners, etc.).\n\nSome notes:\n\nUnlike props, fallthrough attributes preserve their original casing in JavaScript, so an attribute like foo-bar needs to be accessed as $attrs['foo-bar'].\n\nA v-on event listener like @click will be exposed on the object as a function under $attrs.onClick.\n\nUsing our <MyButton> component example from the previous section - sometimes we may need to wrap the actual <button> element with an extra <div> for styling purposes:\n\ntemplate\n<div class=\"btn-wrapper\">\n  <button class=\"btn\">Click Me</button>\n</div>\n\nWe want all fallthrough attributes like class and v-on listeners to be applied to the inner <button>, not the outer <div>. We can achieve this with inheritAttrs: false and v-bind=\"$attrs\":\n\ntemplate\n<div class=\"btn-wrapper\">\n  <button class=\"btn\" v-bind=\"$attrs\">Click Me</button>\n</div>\n\nRemember that v-bind without an argument binds all the properties of an object as attributes of the target element.\n\nAttribute Inheritance on Multiple Root Nodes\n​\n\nUnlike components with a single root node, components with multiple root nodes do not have an automatic attribute fallthrough behavior. If $attrs are not bound explicitly, a runtime warning will be issued.\n\ntemplate\n<CustomLayout id=\"custom-layout\" @click=\"changeValue\" />\n\nIf <CustomLayout> has the following multi-root template, there will be a warning because Vue cannot be sure where to apply the fallthrough attributes:\n\ntemplate\n<header>...</header>\n<main>...</main>\n<footer>...</footer>\n\nThe warning will be suppressed if $attrs is explicitly bound:\n\ntemplate\n<header>...</header>\n<main v-bind=\"$attrs\">...</main>\n<footer>...</footer>\nAccessing Fallthrough Attributes in JavaScript\n​\n\nIf needed, you can access a component's fallthrough attributes in <script setup> using the useAttrs() API:\n\nvue\n<script setup>\nimport { useAttrs } from 'vue'\n\nconst attrs = useAttrs()\n</script>\n\nIf not using <script setup>, attrs will be exposed as a property of the setup() context:\n\njs\nexport default {\n  setup(props, ctx) {\n    // fallthrough attributes are exposed as ctx.attrs\n    console.log(ctx.attrs)\n  }\n}\n\nNote that although the attrs object here always reflects the latest fallthrough attributes, it isn't reactive (for performance reasons). You cannot use watchers to observe its changes. If you need reactivity, use a prop. Alternatively, you can use onUpdated() to perform side effects with the latest attrs on each update.\n\nEdit this page on GitHub\n\n Previous\nComponent v-model\nNext \nSlots\nFallthrough Attributes has loaded"
  },
  {
    "title": "Component v-model | Vue.js",
    "url": "https://vuejs.org/guide/components/v-model",
    "html": "Skip to content\nGet 60% off a year of Vue Mastery courses\nGET DISCOUNT\nVue.js\nSearch\nCtrl\nK\nMain Navigation\nDocs\nAPI\nPlayground\nEcosystem\nAbout\nSponsor\nPartners\ngithub\ntwitter\ndiscord\nAPI Preference\nOptions\nComposition\n?\n\nAPI style now defaults to Composition API.\n\nSome pages contain different content based on the API style chosen. Use this switch to toggle between APIs styles.\n\nLearn moreGot it\n\nSidebar Navigation\nGetting Started\n\nIntroduction\n\nQuick Start\n\nEssentials\n\nCreating an Application\n\nTemplate Syntax\n\nReactivity Fundamentals\n\nComputed Properties\n\nClass and Style Bindings\n\nConditional Rendering\n\nList Rendering\n\nEvent Handling\n\nForm Input Bindings\n\nLifecycle Hooks\n\nWatchers\n\nTemplate Refs\n\nComponents Basics\n\nComponents In-Depth\n\nRegistration\n\nProps\n\nEvents\n\nComponent v-model\n\nFallthrough Attributes\n\nSlots\n\nProvide / inject\n\nAsync Components\n\nReusability\n\nComposables\n\nCustom Directives\n\nPlugins\n\nBuilt-in Components\n\nTransition\n\nTransitionGroup\n\nKeepAlive\n\nTeleport\n\nSuspense\n\nScaling Up\n\nSingle-File Components\n\nTooling\n\nRouting\n\nState Management\n\nTesting\n\nServer-Side Rendering (SSR)\n\nBest Practices\n\nProduction Deployment\n\nPerformance\n\nAccessibility\n\nSecurity\n\nTypeScript\n\nOverview\n\nTS with Composition API\n\nTS with Options API\n\nExtra Topics\n\nWays of Using Vue\n\nComposition API FAQ\n\nReactivity in Depth\n\nRendering Mechanism\n\nRender Functions & JSX\n\nVue and Web Components\n\nAnimation Techniques\n\nON THIS PAGE\nTable of Contents for current page\nBasic Usage\nv-model arguments\nMultiple v-model bindings\nHandling v-model modifiers\nSPONSORS\nBecome a Sponsor\nDesign and Development tips in your inbox. Every weekday.\nADS VIA CARBON\nComponent v-model\n​\nBasic Usage\n​\n\nv-model can be used on a component to implement a two-way binding.\n\nStarting in Vue 3.4, the recommended approach to achieve this is using the defineModel() macro:\n\nvue\n<!-- Child.vue -->\n<script setup>\nconst model = defineModel()\n\nfunction update() {\n  model.value++\n}\n</script>\n\n<template>\n  <div>Parent bound v-model is: {{ model }}</div>\n</template>\n\nThe parent can then bind a value with v-model:\n\ntemplate\n<!-- Parent.vue -->\n<Child v-model=\"countModel\" />\n\nThe value returned by defineModel() is a ref. It can be accessed and mutated like any other ref, except that it acts as a two-way binding between a parent value and a local one:\n\nIts .value is synced with the value bound by the parent v-model;\nWhen it is mutated by the child, it causes the parent bound value to be updated as well.\n\nThis means you can also bind this ref to a native input element with v-model, making it straightforward to wrap native input elements while providing the same v-model usage:\n\nvue\n<script setup>\nconst model = defineModel()\n</script>\n\n<template>\n  <input v-model=\"model\" />\n</template>\n\nTry it in the playground\n\nUnder the Hood\n​\n\ndefineModel is a convenience macro. The compiler expands it to the following:\n\nA prop named modelValue, which the local ref's value is synced with;\nAn event named update:modelValue, which is emitted when the local ref's value is mutated.\n\nThis is how you would implement the same child component shown above prior to 3.4:\n\nvue\n<!-- Child.vue -->\n<script setup>\nconst props = defineProps(['modelValue'])\nconst emit = defineEmits(['update:modelValue'])\n</script>\n\n<template>\n  <input\n    :value=\"props.modelValue\"\n    @input=\"emit('update:modelValue', $event.target.value)\"\n  />\n</template>\n\nThen, v-model=\"modelValue\" in the parent component will be compiled to:\n\ntemplate\n<!-- Parent.vue -->\n<Child\n  :modelValue=\"foo\"\n  @update:modelValue=\"$event => (foo = $event)\"\n/>\n\nAs you can see, it is quite a bit more verbose. However, it is helpful to understand what is happening under the hood.\n\nBecause defineModel declares a prop, you can therefore declare the underlying prop's options by passing it to defineModel:\n\njs\n// making the v-model required\nconst model = defineModel({ required: true })\n\n// providing a default value\nconst model = defineModel({ default: 0 })\n\nWARNING\n\nIf you have a default value for defineModel prop and you don't provide any value for this prop from the parent component, it can cause a de-synchronization between parent and child components. In the example below, the parent's myRef is undefined, but the child's model is 1:\n\njs\n// child component:\nconst model = defineModel({ default: 1 })\n\n// parent component:\nconst myRef = ref()\nhtml\n<Child v-model=\"myRef\"></Child>\nv-model arguments\n​\n\nv-model on a component can also accept an argument:\n\ntemplate\n<MyComponent v-model:title=\"bookTitle\" />\n\nIn the child component, we can support the corresponding argument by passing a string to defineModel() as its first argument:\n\nvue\n<!-- MyComponent.vue -->\n<script setup>\nconst title = defineModel('title')\n</script>\n\n<template>\n  <input type=\"text\" v-model=\"title\" />\n</template>\n\nTry it in the Playground\n\nIf prop options are also needed, they should be passed after the model name:\n\njs\nconst title = defineModel('title', { required: true })\nPre 3.4 Usage\nMultiple v-model bindings\n​\n\nBy leveraging the ability to target a particular prop and event as we learned before with v-model arguments, we can now create multiple v-model bindings on a single component instance.\n\nEach v-model will sync to a different prop, without the need for extra options in the component:\n\ntemplate\n<UserName\n  v-model:first-name=\"first\"\n  v-model:last-name=\"last\"\n/>\nvue\n<script setup>\nconst firstName = defineModel('firstName')\nconst lastName = defineModel('lastName')\n</script>\n\n<template>\n  <input type=\"text\" v-model=\"firstName\" />\n  <input type=\"text\" v-model=\"lastName\" />\n</template>\n\nTry it in the Playground\n\nPre 3.4 Usage\nHandling v-model modifiers\n​\n\nWhen we were learning about form input bindings, we saw that v-model has built-in modifiers - .trim, .number and .lazy. In some cases, you might also want the v-model on your custom input component to support custom modifiers.\n\nLet's create an example custom modifier, capitalize, that capitalizes the first letter of the string provided by the v-model binding:\n\ntemplate\n<MyComponent v-model.capitalize=\"myText\" />\n\nModifiers added to a component v-model can be accessed in the child component by destructuring the defineModel() return value like this:\n\nvue\n<script setup>\nconst [model, modifiers] = defineModel()\n\nconsole.log(modifiers) // { capitalize: true }\n</script>\n\n<template>\n  <input type=\"text\" v-model=\"model\" />\n</template>\n\nTo conditionally adjust how the value should be read / written based on modifiers, we can pass get and set options to defineModel(). These two options receive the value on get / set of the model ref and should return a transformed value. This is how we can use the set option to implement the capitalize modifier:\n\nvue\n<script setup>\nconst [model, modifiers] = defineModel({\n  set(value) {\n    if (modifiers.capitalize) {\n      return value.charAt(0).toUpperCase() + value.slice(1)\n    }\n    return value\n  }\n})\n</script>\n\n<template>\n  <input type=\"text\" v-model=\"model\" />\n</template>\n\nTry it in the Playground\n\nPre 3.4 Usage\nModifiers for v-model with arguments\n​\n\nHere's another example of using modifiers with multiple v-model with different arguments:\n\ntemplate\n<UserName\n  v-model:first-name.capitalize=\"first\"\n  v-model:last-name.uppercase=\"last\"\n/>\nvue\n<script setup>\nconst [firstName, firstNameModifiers] = defineModel('firstName')\nconst [lastName, lastNameModifiers] = defineModel('lastName')\n\nconsole.log(firstNameModifiers) // { capitalize: true }\nconsole.log(lastNameModifiers) // { uppercase: true }\n</script>\nPre 3.4 Usage\n\nEdit this page on GitHub\n\n Previous\nEvents\nNext \nFallthrough Attributes\nComponent v-model has loaded"
  },
  {
    "title": "Component Events | Vue.js",
    "url": "https://vuejs.org/guide/components/events",
    "html": "Skip to content\nGet 60% off a year of Vue Mastery courses\nGET DISCOUNT\nVue.js\nSearch\nCtrl\nK\nMain Navigation\nDocs\nAPI\nPlayground\nEcosystem\nAbout\nSponsor\nPartners\ngithub\ntwitter\ndiscord\nAPI Preference\nOptions\nComposition\n?\n\nAPI style now defaults to Composition API.\n\nSome pages contain different content based on the API style chosen. Use this switch to toggle between APIs styles.\n\nLearn moreGot it\n\nSidebar Navigation\nGetting Started\n\nIntroduction\n\nQuick Start\n\nEssentials\n\nCreating an Application\n\nTemplate Syntax\n\nReactivity Fundamentals\n\nComputed Properties\n\nClass and Style Bindings\n\nConditional Rendering\n\nList Rendering\n\nEvent Handling\n\nForm Input Bindings\n\nLifecycle Hooks\n\nWatchers\n\nTemplate Refs\n\nComponents Basics\n\nComponents In-Depth\n\nRegistration\n\nProps\n\nEvents\n\nComponent v-model\n\nFallthrough Attributes\n\nSlots\n\nProvide / inject\n\nAsync Components\n\nReusability\n\nComposables\n\nCustom Directives\n\nPlugins\n\nBuilt-in Components\n\nTransition\n\nTransitionGroup\n\nKeepAlive\n\nTeleport\n\nSuspense\n\nScaling Up\n\nSingle-File Components\n\nTooling\n\nRouting\n\nState Management\n\nTesting\n\nServer-Side Rendering (SSR)\n\nBest Practices\n\nProduction Deployment\n\nPerformance\n\nAccessibility\n\nSecurity\n\nTypeScript\n\nOverview\n\nTS with Composition API\n\nTS with Options API\n\nExtra Topics\n\nWays of Using Vue\n\nComposition API FAQ\n\nReactivity in Depth\n\nRendering Mechanism\n\nRender Functions & JSX\n\nVue and Web Components\n\nAnimation Techniques\n\nON THIS PAGE\nTable of Contents for current page\nEmitting and Listening to Events\nEvent Arguments\nDeclaring Emitted Events\nEvents Validation\nSPONSORS\nBecome a Sponsor\nScale effortlessly with Intel® Xeon® based servers while staying in control of your data\nADS VIA CARBON\nComponent Events\n​\n\nThis page assumes you've already read the Components Basics. Read that first if you are new to components.\n\nEmitting and Listening to Events\n​\n\nA component can emit custom events directly in template expressions (e.g. in a v-on handler) using the built-in $emit method:\n\ntemplate\n<!-- MyComponent -->\n<button @click=\"$emit('someEvent')\">Click Me</button>\n\nThe parent can then listen to it using v-on:\n\ntemplate\n<MyComponent @some-event=\"callback\" />\n\nThe .once modifier is also supported on component event listeners:\n\ntemplate\n<MyComponent @some-event.once=\"callback\" />\n\nLike components and props, event names provide an automatic case transformation. Notice we emitted a camelCase event, but can listen for it using a kebab-cased listener in the parent. As with props casing, we recommend using kebab-cased event listeners in templates.\n\nTIP\n\nUnlike native DOM events, component emitted events do not bubble. You can only listen to the events emitted by a direct child component. If there is a need to communicate between sibling or deeply nested components, use an external event bus or a global state management solution.\n\nEvent Arguments\n​\n\nIt's sometimes useful to emit a specific value with an event. For example, we may want the <BlogPost> component to be in charge of how much to enlarge the text by. In those cases, we can pass extra arguments to $emit to provide this value:\n\ntemplate\n<button @click=\"$emit('increaseBy', 1)\">\n  Increase by 1\n</button>\n\nThen, when we listen to the event in the parent, we can use an inline arrow function as the listener, which allows us to access the event argument:\n\ntemplate\n<MyButton @increase-by=\"(n) => count += n\" />\n\nOr, if the event handler is a method:\n\ntemplate\n<MyButton @increase-by=\"increaseCount\" />\n\nThen the value will be passed as the first parameter of that method:\n\njs\nfunction increaseCount(n) {\n  count.value += n\n}\n\nTIP\n\nAll extra arguments passed to $emit() after the event name will be forwarded to the listener. For example, with $emit('foo', 1, 2, 3) the listener function will receive three arguments.\n\nDeclaring Emitted Events\n​\n\nA component can explicitly declare the events it will emit using the defineEmits() macro:\n\nvue\n<script setup>\ndefineEmits(['inFocus', 'submit'])\n</script>\n\nThe $emit method that we used in the <template> isn't accessible within the <script setup> section of a component, but defineEmits() returns an equivalent function that we can use instead:\n\nvue\n<script setup>\nconst emit = defineEmits(['inFocus', 'submit'])\n\nfunction buttonClick() {\n  emit('submit')\n}\n</script>\n\nThe defineEmits() macro cannot be used inside a function, it must be placed directly within <script setup>, as in the example above.\n\nIf you're using an explicit setup function instead of <script setup>, events should be declared using the emits option, and the emit function is exposed on the setup() context:\n\njs\nexport default {\n  emits: ['inFocus', 'submit'],\n  setup(props, ctx) {\n    ctx.emit('submit')\n  }\n}\n\nAs with other properties of the setup() context, emit can safely be destructured:\n\njs\nexport default {\n  emits: ['inFocus', 'submit'],\n  setup(props, { emit }) {\n    emit('submit')\n  }\n}\n\nThe emits option and defineEmits() macro also support an object syntax. If using TypeScript you can type arguments, which allows us to perform runtime validation of the payload of the emitted events:\n\nvue\n<script setup lang=\"ts\">\nconst emit = defineEmits({\n  submit(payload: { email: string, password: string }) {\n    // return `true` or `false` to indicate\n    // validation pass / fail\n  }\n})\n</script>\n\nIf you are using TypeScript with <script setup>, it's also possible to declare emitted events using pure type annotations:\n\nvue\n<script setup lang=\"ts\">\nconst emit = defineEmits<{\n  (e: 'change', id: number): void\n  (e: 'update', value: string): void\n}>()\n</script>\n\nMore details: Typing Component Emits \n\nAlthough optional, it is recommended to define all emitted events in order to better document how a component should work. It also allows Vue to exclude known listeners from fallthrough attributes, avoiding edge cases caused by DOM events manually dispatched by 3rd party code.\n\nTIP\n\nIf a native event (e.g., click) is defined in the emits option, the listener will now only listen to component-emitted click events and no longer respond to native click events.\n\nEvents Validation\n​\n\nSimilar to prop type validation, an emitted event can be validated if it is defined with the object syntax instead of the array syntax.\n\nTo add validation, the event is assigned a function that receives the arguments passed to the emit call and returns a boolean to indicate whether the event is valid or not.\n\nvue\n<script setup>\nconst emit = defineEmits({\n  // No validation\n  click: null,\n\n  // Validate submit event\n  submit: ({ email, password }) => {\n    if (email && password) {\n      return true\n    } else {\n      console.warn('Invalid submit event payload!')\n      return false\n    }\n  }\n})\n\nfunction submitForm(email, password) {\n  emit('submit', { email, password })\n}\n</script>\n\nEdit this page on GitHub\n\n Previous\nProps\nNext \nComponent v-model\nComponent Events has loaded"
  },
  {
    "title": "Props | Vue.js",
    "url": "https://vuejs.org/guide/components/props",
    "html": "Skip to content\nGet 60% off a year of Vue Mastery courses\nGET DISCOUNT\nVue.js\nSearch\nCtrl\nK\nMain Navigation\nDocs\nAPI\nPlayground\nEcosystem\nAbout\nSponsor\nPartners\ngithub\ntwitter\ndiscord\nAPI Preference\nOptions\nComposition\n?\n\nAPI style now defaults to Composition API.\n\nSome pages contain different content based on the API style chosen. Use this switch to toggle between APIs styles.\n\nLearn moreGot it\n\nSidebar Navigation\nGetting Started\n\nIntroduction\n\nQuick Start\n\nEssentials\n\nCreating an Application\n\nTemplate Syntax\n\nReactivity Fundamentals\n\nComputed Properties\n\nClass and Style Bindings\n\nConditional Rendering\n\nList Rendering\n\nEvent Handling\n\nForm Input Bindings\n\nLifecycle Hooks\n\nWatchers\n\nTemplate Refs\n\nComponents Basics\n\nComponents In-Depth\n\nRegistration\n\nProps\n\nEvents\n\nComponent v-model\n\nFallthrough Attributes\n\nSlots\n\nProvide / inject\n\nAsync Components\n\nReusability\n\nComposables\n\nCustom Directives\n\nPlugins\n\nBuilt-in Components\n\nTransition\n\nTransitionGroup\n\nKeepAlive\n\nTeleport\n\nSuspense\n\nScaling Up\n\nSingle-File Components\n\nTooling\n\nRouting\n\nState Management\n\nTesting\n\nServer-Side Rendering (SSR)\n\nBest Practices\n\nProduction Deployment\n\nPerformance\n\nAccessibility\n\nSecurity\n\nTypeScript\n\nOverview\n\nTS with Composition API\n\nTS with Options API\n\nExtra Topics\n\nWays of Using Vue\n\nComposition API FAQ\n\nReactivity in Depth\n\nRendering Mechanism\n\nRender Functions & JSX\n\nVue and Web Components\n\nAnimation Techniques\n\nON THIS PAGE\nTable of Contents for current page\nProps Declaration\nProp Passing Details\nOne-Way Data Flow\nProp Validation\nBoolean Casting\nSPONSORS\nBecome a Sponsor\nProps\n​\n\nThis page assumes you've already read the Components Basics. Read that first if you are new to components.\n\nProps Declaration\n​\n\nVue components require explicit props declaration so that Vue knows what external props passed to the component should be treated as fallthrough attributes (which will be discussed in its dedicated section).\n\nIn SFCs using <script setup>, props can be declared using the defineProps() macro:\n\nvue\n<script setup>\nconst props = defineProps(['foo'])\n\nconsole.log(props.foo)\n</script>\n\nIn non-<script setup> components, props are declared using the props option:\n\njs\nexport default {\n  props: ['foo'],\n  setup(props) {\n    // setup() receives props as the first argument.\n    console.log(props.foo)\n  }\n}\n\nNotice the argument passed to defineProps() is the same as the value provided to the props options: the same props options API is shared between the two declaration styles.\n\nIn addition to declaring props using an array of strings, we can also use the object syntax:\n\njs\n// in <script setup>\ndefineProps({\n  title: String,\n  likes: Number\n})\njs\n// in non-<script setup>\nexport default {\n  props: {\n    title: String,\n    likes: Number\n  }\n}\n\nFor each property in the object declaration syntax, the key is the name of the prop, while the value should be the constructor function of the expected type.\n\nThis not only documents your component, but will also warn other developers using your component in the browser console if they pass the wrong type. We will discuss more details about prop validation further down this page.\n\nIf you are using TypeScript with <script setup>, it's also possible to declare props using pure type annotations:\n\nvue\n<script setup lang=\"ts\">\ndefineProps<{\n  title?: string\n  likes?: number\n}>()\n</script>\n\nMore details: Typing Component Props \n\nProp Passing Details\n​\nProp Name Casing\n​\n\nWe declare long prop names using camelCase because this avoids having to use quotes when using them as property keys, and allows us to reference them directly in template expressions because they are valid JavaScript identifiers:\n\njs\ndefineProps({\n  greetingMessage: String\n})\ntemplate\n<span>{{ greetingMessage }}</span>\n\nTechnically, you can also use camelCase when passing props to a child component (except in in-DOM templates). However, the convention is using kebab-case in all cases to align with HTML attributes:\n\ntemplate\n<MyComponent greeting-message=\"hello\" />\n\nWe use PascalCase for component tags when possible because it improves template readability by differentiating Vue components from native elements. However, there isn't as much practical benefit in using camelCase when passing props, so we choose to follow each language's conventions.\n\nStatic vs. Dynamic Props\n​\n\nSo far, you've seen props passed as static values, like in:\n\ntemplate\n<BlogPost title=\"My journey with Vue\" />\n\nYou've also seen props assigned dynamically with v-bind or its : shortcut, such as in:\n\ntemplate\n<!-- Dynamically assign the value of a variable -->\n<BlogPost :title=\"post.title\" />\n\n<!-- Dynamically assign the value of a complex expression -->\n<BlogPost :title=\"post.title + ' by ' + post.author.name\" />\nPassing Different Value Types\n​\n\nIn the two examples above, we happen to pass string values, but any type of value can be passed to a prop.\n\nNumber\n​\ntemplate\n<!-- Even though `42` is static, we need v-bind to tell Vue that -->\n<!-- this is a JavaScript expression rather than a string.       -->\n<BlogPost :likes=\"42\" />\n\n<!-- Dynamically assign to the value of a variable. -->\n<BlogPost :likes=\"post.likes\" />\nBoolean\n​\ntemplate\n<!-- Including the prop with no value will imply `true`. -->\n<BlogPost is-published />\n\n<!-- Even though `false` is static, we need v-bind to tell Vue that -->\n<!-- this is a JavaScript expression rather than a string.          -->\n<BlogPost :is-published=\"false\" />\n\n<!-- Dynamically assign to the value of a variable. -->\n<BlogPost :is-published=\"post.isPublished\" />\nArray\n​\ntemplate\n<!-- Even though the array is static, we need v-bind to tell Vue that -->\n<!-- this is a JavaScript expression rather than a string.            -->\n<BlogPost :comment-ids=\"[234, 266, 273]\" />\n\n<!-- Dynamically assign to the value of a variable. -->\n<BlogPost :comment-ids=\"post.commentIds\" />\nObject\n​\ntemplate\n<!-- Even though the object is static, we need v-bind to tell Vue that -->\n<!-- this is a JavaScript expression rather than a string.             -->\n<BlogPost\n  :author=\"{\n    name: 'Veronica',\n    company: 'Veridian Dynamics'\n  }\"\n />\n\n<!-- Dynamically assign to the value of a variable. -->\n<BlogPost :author=\"post.author\" />\nBinding Multiple Properties Using an Object\n​\n\nIf you want to pass all the properties of an object as props, you can use v-bind without an argument (v-bind instead of :prop-name). For example, given a post object:\n\njs\nconst post = {\n  id: 1,\n  title: 'My Journey with Vue'\n}\n\nThe following template:\n\ntemplate\n<BlogPost v-bind=\"post\" />\n\nWill be equivalent to:\n\ntemplate\n<BlogPost :id=\"post.id\" :title=\"post.title\" />\nOne-Way Data Flow\n​\n\nAll props form a one-way-down binding between the child property and the parent one: when the parent property updates, it will flow down to the child, but not the other way around. This prevents child components from accidentally mutating the parent's state, which can make your app's data flow harder to understand.\n\nIn addition, every time the parent component is updated, all props in the child component will be refreshed with the latest value. This means you should not attempt to mutate a prop inside a child component. If you do, Vue will warn you in the console:\n\njs\nconst props = defineProps(['foo'])\n\n// ❌ warning, props are readonly!\nprops.foo = 'bar'\n\nThere are usually two cases where it's tempting to mutate a prop:\n\nThe prop is used to pass in an initial value; the child component wants to use it as a local data property afterwards. In this case, it's best to define a local data property that uses the prop as its initial value:\n\njs\nconst props = defineProps(['initialCounter'])\n\n// counter only uses props.initialCounter as the initial value;\n// it is disconnected from future prop updates.\nconst counter = ref(props.initialCounter)\n\nThe prop is passed in as a raw value that needs to be transformed. In this case, it's best to define a computed property using the prop's value:\n\njs\nconst props = defineProps(['size'])\n\n// computed property that auto-updates when the prop changes\nconst normalizedSize = computed(() => props.size.trim().toLowerCase())\nMutating Object / Array Props\n​\n\nWhen objects and arrays are passed as props, while the child component cannot mutate the prop binding, it will be able to mutate the object or array's nested properties. This is because in JavaScript objects and arrays are passed by reference, and it is unreasonably expensive for Vue to prevent such mutations.\n\nThe main drawback of such mutations is that it allows the child component to affect parent state in a way that isn't obvious to the parent component, potentially making it more difficult to reason about the data flow in the future. As a best practice, you should avoid such mutations unless the parent and child are tightly coupled by design. In most cases, the child should emit an event to let the parent perform the mutation.\n\nProp Validation\n​\n\nComponents can specify requirements for their props, such as the types you've already seen. If a requirement is not met, Vue will warn you in the browser's JavaScript console. This is especially useful when developing a component that is intended to be used by others.\n\nTo specify prop validations, you can provide an object with validation requirements to the defineProps() macro, instead of an array of strings. For example:\n\njs\ndefineProps({\n  // Basic type check\n  //  (`null` and `undefined` values will allow any type)\n  propA: Number,\n  // Multiple possible types\n  propB: [String, Number],\n  // Required string\n  propC: {\n    type: String,\n    required: true\n  },\n  // Required but nullable string\n  propD: {\n    type: [String, null],\n    required: true\n  },\n  // Number with a default value\n  propE: {\n    type: Number,\n    default: 100\n  },\n  // Object with a default value\n  propF: {\n    type: Object,\n    // Object or array defaults must be returned from\n    // a factory function. The function receives the raw\n    // props received by the component as the argument.\n    default(rawProps) {\n      return { message: 'hello' }\n    }\n  },\n  // Custom validator function\n  // full props passed as 2nd argument in 3.4+\n  propG: {\n    validator(value, props) {\n      // The value must match one of these strings\n      return ['success', 'warning', 'danger'].includes(value)\n    }\n  },\n  // Function with a default value\n  propH: {\n    type: Function,\n    // Unlike object or array default, this is not a factory\n    // function - this is a function to serve as a default value\n    default() {\n      return 'Default function'\n    }\n  }\n})\n\nTIP\n\nCode inside the defineProps() argument cannot access other variables declared in <script setup>, because the entire expression is moved to an outer function scope when compiled.\n\nAdditional details:\n\nAll props are optional by default, unless required: true is specified.\n\nAn absent optional prop other than Boolean will have undefined value.\n\nThe Boolean absent props will be cast to false. You can change this by setting a default for it — i.e.: default: undefined to behave as a non-Boolean prop.\n\nIf a default value is specified, it will be used if the resolved prop value is undefined - this includes both when the prop is absent, or an explicit undefined value is passed.\n\nWhen prop validation fails, Vue will produce a console warning (if using the development build).\n\nIf using Type-based props declarations , Vue will try its best to compile the type annotations into equivalent runtime prop declarations. For example, defineProps<{ msg: string }> will be compiled into { msg: { type: String, required: true }}.\n\nRuntime Type Checks\n​\n\nThe type can be one of the following native constructors:\n\nString\nNumber\nBoolean\nArray\nObject\nDate\nFunction\nSymbol\nError\n\nIn addition, type can also be a custom class or constructor function and the assertion will be made with an instanceof check. For example, given the following class:\n\njs\nclass Person {\n  constructor(firstName, lastName) {\n    this.firstName = firstName\n    this.lastName = lastName\n  }\n}\n\nYou could use it as a prop's type:\n\njs\ndefineProps({\n  author: Person\n})\n\nVue will use instanceof Person to validate whether the value of the author prop is indeed an instance of the Person class.\n\nNullable Type\n​\n\nIf the type is required but nullable, you can use the array syntax that includes null:\n\njs\ndefineProps({\n  id: {\n    type: [String, null],\n    required: true\n  }\n})\n\nNote that if type is just null without using the array syntax, it will allow any type.\n\nBoolean Casting\n​\n\nProps with Boolean type have special casting rules to mimic the behavior of native boolean attributes. Given a <MyComponent> with the following declaration:\n\njs\ndefineProps({\n  disabled: Boolean\n})\n\nThe component can be used like this:\n\ntemplate\n<!-- equivalent of passing :disabled=\"true\" -->\n<MyComponent disabled />\n\n<!-- equivalent of passing :disabled=\"false\" -->\n<MyComponent />\n\nWhen a prop is declared to allow multiple types, the casting rules for Boolean will also be applied. However, there is an edge when both String and Boolean are allowed - the Boolean casting rule only applies if Boolean appears before String:\n\njs\n// disabled will be casted to true\ndefineProps({\n  disabled: [Boolean, Number]\n})\n\n// disabled will be casted to true\ndefineProps({\n  disabled: [Boolean, String]\n})\n\n// disabled will be casted to true\ndefineProps({\n  disabled: [Number, Boolean]\n})\n\n// disabled will be parsed as an empty string (disabled=\"\")\ndefineProps({\n  disabled: [String, Boolean]\n})\n\nEdit this page on GitHub\n\n Previous\nRegistration\nNext \nEvents\nProps has loaded"
  },
  {
    "title": "Component Registration | Vue.js",
    "url": "https://vuejs.org/guide/components/registration",
    "html": "Skip to content\nGet 60% off a year of Vue Mastery courses\nGET DISCOUNT\nVue.js\nSearch\nCtrl\nK\nMain Navigation\nDocs\nAPI\nPlayground\nEcosystem\nAbout\nSponsor\nPartners\ngithub\ntwitter\ndiscord\nAPI Preference\nOptions\nComposition\n?\n\nAPI style now defaults to Composition API.\n\nSome pages contain different content based on the API style chosen. Use this switch to toggle between APIs styles.\n\nLearn moreGot it\n\nSidebar Navigation\nGetting Started\n\nIntroduction\n\nQuick Start\n\nEssentials\n\nCreating an Application\n\nTemplate Syntax\n\nReactivity Fundamentals\n\nComputed Properties\n\nClass and Style Bindings\n\nConditional Rendering\n\nList Rendering\n\nEvent Handling\n\nForm Input Bindings\n\nLifecycle Hooks\n\nWatchers\n\nTemplate Refs\n\nComponents Basics\n\nComponents In-Depth\n\nRegistration\n\nProps\n\nEvents\n\nComponent v-model\n\nFallthrough Attributes\n\nSlots\n\nProvide / inject\n\nAsync Components\n\nReusability\n\nComposables\n\nCustom Directives\n\nPlugins\n\nBuilt-in Components\n\nTransition\n\nTransitionGroup\n\nKeepAlive\n\nTeleport\n\nSuspense\n\nScaling Up\n\nSingle-File Components\n\nTooling\n\nRouting\n\nState Management\n\nTesting\n\nServer-Side Rendering (SSR)\n\nBest Practices\n\nProduction Deployment\n\nPerformance\n\nAccessibility\n\nSecurity\n\nTypeScript\n\nOverview\n\nTS with Composition API\n\nTS with Options API\n\nExtra Topics\n\nWays of Using Vue\n\nComposition API FAQ\n\nReactivity in Depth\n\nRendering Mechanism\n\nRender Functions & JSX\n\nVue and Web Components\n\nAnimation Techniques\n\nON THIS PAGE\nTable of Contents for current page\nGlobal Registration\nLocal Registration\nComponent Name Casing\nSPONSORS\nBecome a Sponsor\nGitLab is the most comprehensive AI-powered DevSecOps Platform. Software. Faster.\nADS VIA CARBON\nComponent Registration\n​\n\nThis page assumes you've already read the Components Basics. Read that first if you are new to components.\n\nWatch a free video lesson on Vue School\n\nA Vue component needs to be \"registered\" so that Vue knows where to locate its implementation when it is encountered in a template. There are two ways to register components: global and local.\n\nGlobal Registration\n​\n\nWe can make components available globally in the current Vue application using the .component() method:\n\njs\nimport { createApp } from 'vue'\n\nconst app = createApp({})\n\napp.component(\n  // the registered name\n  'MyComponent',\n  // the implementation\n  {\n    /* ... */\n  }\n)\n\nIf using SFCs, you will be registering the imported .vue files:\n\njs\nimport MyComponent from './App.vue'\n\napp.component('MyComponent', MyComponent)\n\nThe .component() method can be chained:\n\njs\napp\n  .component('ComponentA', ComponentA)\n  .component('ComponentB', ComponentB)\n  .component('ComponentC', ComponentC)\n\nGlobally registered components can be used in the template of any component within this application:\n\ntemplate\n<!-- this will work in any component inside the app -->\n<ComponentA/>\n<ComponentB/>\n<ComponentC/>\n\nThis even applies to all subcomponents, meaning all three of these components will also be available inside each other.\n\nLocal Registration\n​\n\nWhile convenient, global registration has a few drawbacks:\n\nGlobal registration prevents build systems from removing unused components (a.k.a \"tree-shaking\"). If you globally register a component but end up not using it anywhere in your app, it will still be included in the final bundle.\n\nGlobal registration makes dependency relationships less explicit in large applications. It makes it difficult to locate a child component's implementation from a parent component using it. This can affect long-term maintainability similar to using too many global variables.\n\nLocal registration scopes the availability of the registered components to the current component only. It makes the dependency relationship more explicit, and is more tree-shaking friendly.\n\nWhen using SFC with <script setup>, imported components can be locally used without registration:\n\nvue\n<script setup>\nimport ComponentA from './ComponentA.vue'\n</script>\n\n<template>\n  <ComponentA />\n</template>\n\nIn non-<script setup>, you will need to use the components option:\n\njs\nimport ComponentA from './ComponentA.js'\n\nexport default {\n  components: {\n    ComponentA\n  },\n  setup() {\n    // ...\n  }\n}\n\nFor each property in the components object, the key will be the registered name of the component, while the value will contain the implementation of the component. The above example is using the ES2015 property shorthand and is equivalent to:\n\njs\nexport default {\n  components: {\n    ComponentA: ComponentA\n  }\n  // ...\n}\n\nNote that locally registered components are not also available in descendant components. In this case, ComponentA will be made available to the current component only, not any of its child or descendant components.\n\nComponent Name Casing\n​\n\nThroughout the guide, we are using PascalCase names when registering components. This is because:\n\nPascalCase names are valid JavaScript identifiers. This makes it easier to import and register components in JavaScript. It also helps IDEs with auto-completion.\n\n<PascalCase /> makes it more obvious that this is a Vue component instead of a native HTML element in templates. It also differentiates Vue components from custom elements (web components).\n\nThis is the recommended style when working with SFC or string templates. However, as discussed in in-DOM Template Parsing Caveats, PascalCase tags are not usable in in-DOM templates.\n\nLuckily, Vue supports resolving kebab-case tags to components registered using PascalCase. This means a component registered as MyComponent can be referenced in the template via both <MyComponent> and <my-component>. This allows us to use the same JavaScript component registration code regardless of template source.\n\nEdit this page on GitHub\n\n Previous\nComponents Basics\nNext \nProps\nComponent Registration has loaded"
  },
  {
    "title": "Components Basics | Vue.js",
    "url": "https://vuejs.org/guide/essentials/component-basics",
    "html": "Skip to content\nGet 60% off a year of Vue Mastery courses\nGET DISCOUNT\nVue.js\nSearch\nCtrl\nK\nMain Navigation\nDocs\nAPI\nPlayground\nEcosystem\nAbout\nSponsor\nPartners\ngithub\ntwitter\ndiscord\nAPI Preference\nOptions\nComposition\n?\n\nAPI style now defaults to Composition API.\n\nSome pages contain different content based on the API style chosen. Use this switch to toggle between APIs styles.\n\nLearn moreGot it\n\nSidebar Navigation\nGetting Started\n\nIntroduction\n\nQuick Start\n\nEssentials\n\nCreating an Application\n\nTemplate Syntax\n\nReactivity Fundamentals\n\nComputed Properties\n\nClass and Style Bindings\n\nConditional Rendering\n\nList Rendering\n\nEvent Handling\n\nForm Input Bindings\n\nLifecycle Hooks\n\nWatchers\n\nTemplate Refs\n\nComponents Basics\n\nComponents In-Depth\n\nRegistration\n\nProps\n\nEvents\n\nComponent v-model\n\nFallthrough Attributes\n\nSlots\n\nProvide / inject\n\nAsync Components\n\nReusability\n\nComposables\n\nCustom Directives\n\nPlugins\n\nBuilt-in Components\n\nTransition\n\nTransitionGroup\n\nKeepAlive\n\nTeleport\n\nSuspense\n\nScaling Up\n\nSingle-File Components\n\nTooling\n\nRouting\n\nState Management\n\nTesting\n\nServer-Side Rendering (SSR)\n\nBest Practices\n\nProduction Deployment\n\nPerformance\n\nAccessibility\n\nSecurity\n\nTypeScript\n\nOverview\n\nTS with Composition API\n\nTS with Options API\n\nExtra Topics\n\nWays of Using Vue\n\nComposition API FAQ\n\nReactivity in Depth\n\nRendering Mechanism\n\nRender Functions & JSX\n\nVue and Web Components\n\nAnimation Techniques\n\nON THIS PAGE\nTable of Contents for current page\nDefining a Component\nUsing a Component\nPassing Props\nListening to Events\nContent Distribution with Slots\nDynamic Components\nin-DOM Template Parsing Caveats\nSPONSORS\nBecome a Sponsor\nComponents Basics\n​\n\nComponents allow us to split the UI into independent and reusable pieces, and think about each piece in isolation. It's common for an app to be organized into a tree of nested components:\n\nThis is very similar to how we nest native HTML elements, but Vue implements its own component model that allows us to encapsulate custom content and logic in each component. Vue also plays nicely with native Web Components. If you are curious about the relationship between Vue Components and native Web Components, read more here.\n\nDefining a Component\n​\n\nWhen using a build step, we typically define each Vue component in a dedicated file using the .vue extension - known as a Single-File Component (SFC for short):\n\nvue\n<script setup>\nimport { ref } from 'vue'\n\nconst count = ref(0)\n</script>\n\n<template>\n  <button @click=\"count++\">You clicked me {{ count }} times.</button>\n</template>\n\nWhen not using a build step, a Vue component can be defined as a plain JavaScript object containing Vue-specific options:\n\njs\nimport { ref } from 'vue'\n\nexport default {\n  setup() {\n    const count = ref(0)\n    return { count }\n  },\n  template: `\n    <button @click=\"count++\">\n      You clicked me {{ count }} times.\n    </button>`\n  // Can also target an in-DOM template:\n  // template: '#my-template-element'\n}\n\nThe template is inlined as a JavaScript string here, which Vue will compile on the fly. You can also use an ID selector pointing to an element (usually native <template> elements) - Vue will use its content as the template source.\n\nThe example above defines a single component and exports it as the default export of a .js file, but you can use named exports to export multiple components from the same file.\n\nUsing a Component\n​\n\nTIP\n\nWe will be using SFC syntax for the rest of this guide - the concepts around components are the same regardless of whether you are using a build step or not. The Examples section shows component usage in both scenarios.\n\nTo use a child component, we need to import it in the parent component. Assuming we placed our counter component inside a file called ButtonCounter.vue, the component will be exposed as the file's default export:\n\nvue\n<script setup>\nimport ButtonCounter from './ButtonCounter.vue'\n</script>\n\n<template>\n  <h1>Here is a child component!</h1>\n  <ButtonCounter />\n</template>\n\nWith <script setup>, imported components are automatically made available to the template.\n\nIt's also possible to globally register a component, making it available to all components in a given app without having to import it. The pros and cons of global vs. local registration is discussed in the dedicated Component Registration section.\n\nComponents can be reused as many times as you want:\n\ntemplate\n<h1>Here are many child components!</h1>\n<ButtonCounter />\n<ButtonCounter />\n<ButtonCounter />\n\nTry it in the Playground\n\nNotice that when clicking on the buttons, each one maintains its own, separate count. That's because each time you use a component, a new instance of it is created.\n\nIn SFCs, it's recommended to use PascalCase tag names for child components to differentiate from native HTML elements. Although native HTML tag names are case-insensitive, Vue SFC is a compiled format so we are able to use case-sensitive tag names in it. We are also able to use /> to close a tag.\n\nIf you are authoring your templates directly in a DOM (e.g. as the content of a native <template> element), the template will be subject to the browser's native HTML parsing behavior. In such cases, you will need to use kebab-case and explicit closing tags for components:\n\ntemplate\n<!-- if this template is written in the DOM -->\n<button-counter></button-counter>\n<button-counter></button-counter>\n<button-counter></button-counter>\n\nSee in-DOM template parsing caveats for more details.\n\nPassing Props\n​\n\nIf we are building a blog, we will likely need a component representing a blog post. We want all the blog posts to share the same visual layout, but with different content. Such a component won't be useful unless you can pass data to it, such as the title and content of the specific post we want to display. That's where props come in.\n\nProps are custom attributes you can register on a component. To pass a title to our blog post component, we must declare it in the list of props this component accepts, using the defineProps macro:\n\nvue\n<!-- BlogPost.vue -->\n<script setup>\ndefineProps(['title'])\n</script>\n\n<template>\n  <h4>{{ title }}</h4>\n</template>\n\ndefineProps is a compile-time macro that is only available inside <script setup> and does not need to be explicitly imported. Declared props are automatically exposed to the template. defineProps also returns an object that contains all the props passed to the component, so that we can access them in JavaScript if needed:\n\njs\nconst props = defineProps(['title'])\nconsole.log(props.title)\n\nSee also: Typing Component Props \n\nIf you are not using <script setup>, props should be declared using the props option, and the props object will be passed to setup() as the first argument:\n\njs\nexport default {\n  props: ['title'],\n  setup(props) {\n    console.log(props.title)\n  }\n}\n\nA component can have as many props as you like and, by default, any value can be passed to any prop.\n\nOnce a prop is registered, you can pass data to it as a custom attribute, like this:\n\ntemplate\n<BlogPost title=\"My journey with Vue\" />\n<BlogPost title=\"Blogging with Vue\" />\n<BlogPost title=\"Why Vue is so fun\" />\n\nIn a typical app, however, you'll likely have an array of posts in your parent component:\n\njs\nconst posts = ref([\n  { id: 1, title: 'My journey with Vue' },\n  { id: 2, title: 'Blogging with Vue' },\n  { id: 3, title: 'Why Vue is so fun' }\n])\n\nThen want to render a component for each one, using v-for:\n\ntemplate\n<BlogPost\n  v-for=\"post in posts\"\n  :key=\"post.id\"\n  :title=\"post.title\"\n />\n\nTry it in the Playground\n\nNotice how v-bind syntax (:title=\"post.title\") is used to pass dynamic prop values. This is especially useful when you don't know the exact content you're going to render ahead of time.\n\nThat's all you need to know about props for now, but once you've finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on Props.\n\nListening to Events\n​\n\nAs we develop our <BlogPost> component, some features may require communicating back up to the parent. For example, we may decide to include an accessibility feature to enlarge the text of blog posts, while leaving the rest of the page at its default size.\n\nIn the parent, we can support this feature by adding a postFontSize ref:\n\njs\nconst posts = ref([\n  /* ... */\n])\n\nconst postFontSize = ref(1)\n\nWhich can be used in the template to control the font size of all blog posts:\n\ntemplate\n<div :style=\"{ fontSize: postFontSize + 'em' }\">\n  <BlogPost\n    v-for=\"post in posts\"\n    :key=\"post.id\"\n    :title=\"post.title\"\n   />\n</div>\n\nNow let's add a button to the <BlogPost> component's template:\n\nvue\n<!-- BlogPost.vue, omitting <script> -->\n<template>\n  <div class=\"blog-post\">\n    <h4>{{ title }}</h4>\n    <button>Enlarge text</button>\n  </div>\n</template>\n\nThe button doesn't do anything yet - we want clicking the button to communicate to the parent that it should enlarge the text of all posts. To solve this problem, components provide a custom events system. The parent can choose to listen to any event on the child component instance with v-on or @, just as we would with a native DOM event:\n\ntemplate\n<BlogPost\n  ...\n  @enlarge-text=\"postFontSize += 0.1\"\n />\n\nThen the child component can emit an event on itself by calling the built-in $emit method, passing the name of the event:\n\nvue\n<!-- BlogPost.vue, omitting <script> -->\n<template>\n  <div class=\"blog-post\">\n    <h4>{{ title }}</h4>\n    <button @click=\"$emit('enlarge-text')\">Enlarge text</button>\n  </div>\n</template>\n\nThanks to the @enlarge-text=\"postFontSize += 0.1\" listener, the parent will receive the event and update the value of postFontSize.\n\nTry it in the Playground\n\nWe can optionally declare emitted events using the defineEmits macro:\n\nvue\n<!-- BlogPost.vue -->\n<script setup>\ndefineProps(['title'])\ndefineEmits(['enlarge-text'])\n</script>\n\nThis documents all the events that a component emits and optionally validates them. It also allows Vue to avoid implicitly applying them as native listeners to the child component's root element.\n\nSimilar to defineProps, defineEmits is only usable in <script setup> and doesn't need to be imported. It returns an emit function that is equivalent to the $emit method. It can be used to emit events in the <script setup> section of a component, where $emit isn't directly accessible:\n\nvue\n<script setup>\nconst emit = defineEmits(['enlarge-text'])\n\nemit('enlarge-text')\n</script>\n\nSee also: Typing Component Emits \n\nIf you are not using <script setup>, you can declare emitted events using the emits option. You can access the emit function as a property of the setup context (passed to setup() as the second argument):\n\njs\nexport default {\n  emits: ['enlarge-text'],\n  setup(props, ctx) {\n    ctx.emit('enlarge-text')\n  }\n}\n\nThat's all you need to know about custom component events for now, but once you've finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on Custom Events.\n\nContent Distribution with Slots\n​\n\nJust like with HTML elements, it's often useful to be able to pass content to a component, like this:\n\ntemplate\n<AlertBox>\n  Something bad happened.\n</AlertBox>\n\nWhich might render something like:\n\nThis is an Error for Demo Purposes\n\nSomething bad happened.\n\nThis can be achieved using Vue's custom <slot> element:\n\nvue\n<!-- AlertBox.vue -->\n<template>\n  <div class=\"alert-box\">\n    <strong>This is an Error for Demo Purposes</strong>\n    <slot />\n  </div>\n</template>\n\n<style scoped>\n.alert-box {\n  /* ... */\n}\n</style>\n\nAs you'll see above, we use the <slot> as a placeholder where we want the content to go – and that's it. We're done!\n\nTry it in the Playground\n\nThat's all you need to know about slots for now, but once you've finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on Slots.\n\nDynamic Components\n​\n\nSometimes, it's useful to dynamically switch between components, like in a tabbed interface:\n\nOpen example in the Playground\n\nThe above is made possible by Vue's <component> element with the special is attribute:\n\ntemplate\n<!-- Component changes when currentTab changes -->\n<component :is=\"tabs[currentTab]\"></component>\n\nIn the example above, the value passed to :is can contain either:\n\nthe name string of a registered component, OR\nthe actual imported component object\n\nYou can also use the is attribute to create regular HTML elements.\n\nWhen switching between multiple components with <component :is=\"...\">, a component will be unmounted when it is switched away from. We can force the inactive components to stay \"alive\" with the built-in <KeepAlive> component.\n\nin-DOM Template Parsing Caveats\n​\n\nIf you are writing your Vue templates directly in the DOM, Vue will have to retrieve the template string from the DOM. This leads to some caveats due to browsers' native HTML parsing behavior.\n\nTIP\n\nIt should be noted that the limitations discussed below only apply if you are writing your templates directly in the DOM. They do NOT apply if you are using string templates from the following sources:\n\nSingle-File Components\nInlined template strings (e.g. template: '...')\n<script type=\"text/x-template\">\nCase Insensitivity\n​\n\nHTML tags and attribute names are case-insensitive, so browsers will interpret any uppercase characters as lowercase. That means when you’re using in-DOM templates, PascalCase component names and camelCased prop names or v-on event names all need to use their kebab-cased (hyphen-delimited) equivalents:\n\njs\n// camelCase in JavaScript\nconst BlogPost = {\n  props: ['postTitle'],\n  emits: ['updatePost'],\n  template: `\n    <h3>{{ postTitle }}</h3>\n  `\n}\ntemplate\n<!-- kebab-case in HTML -->\n<blog-post post-title=\"hello!\" @update-post=\"onUpdatePost\"></blog-post>\nSelf Closing Tags\n​\n\nWe have been using self-closing tags for components in previous code samples:\n\ntemplate\n<MyComponent />\n\nThis is because Vue's template parser respects /> as an indication to end any tag, regardless of its type.\n\nIn in-DOM templates, however, we must always include explicit closing tags:\n\ntemplate\n<my-component></my-component>\n\nThis is because the HTML spec only allows a few specific elements to omit closing tags, the most common being <input> and <img>. For all other elements, if you omit the closing tag, the native HTML parser will think you never terminated the opening tag. For example, the following snippet:\n\ntemplate\n<my-component /> <!-- we intend to close the tag here... -->\n<span>hello</span>\n\nwill be parsed as:\n\ntemplate\n<my-component>\n  <span>hello</span>\n</my-component> <!-- but the browser will close it here. -->\nElement Placement Restrictions\n​\n\nSome HTML elements, such as <ul>, <ol>, <table> and <select> have restrictions on what elements can appear inside them, and some elements such as <li>, <tr>, and <option> can only appear inside certain other elements.\n\nThis will lead to issues when using components with elements that have such restrictions. For example:\n\ntemplate\n<table>\n  <blog-post-row></blog-post-row>\n</table>\n\nThe custom component <blog-post-row> will be hoisted out as invalid content, causing errors in the eventual rendered output. We can use the special is attribute as a workaround:\n\ntemplate\n<table>\n  <tr is=\"vue:blog-post-row\"></tr>\n</table>\n\nTIP\n\nWhen used on native HTML elements, the value of is must be prefixed with vue: in order to be interpreted as a Vue component. This is required to avoid confusion with native customized built-in elements.\n\nThat's all you need to know about in-DOM template parsing caveats for now - and actually, the end of Vue's Essentials. Congratulations! There's still more to learn, but first, we recommend taking a break to play with Vue yourself - build something fun, or check out some of the Examples if you haven't already.\n\nOnce you feel comfortable with the knowledge you've just digested, move on with the guide to learn more about components in depth.\n\nEdit this page on GitHub\n\n Previous\nTemplate Refs\nNext \nRegistration\nComponents Basics has loaded"
  },
  {
    "title": "Template Refs | Vue.js",
    "url": "https://vuejs.org/guide/essentials/template-refs",
    "html": "Skip to content\nGet 60% off a year of Vue Mastery courses\nGET DISCOUNT\nVue.js\nSearch\nCtrl\nK\nMain Navigation\nDocs\nAPI\nPlayground\nEcosystem\nAbout\nSponsor\nPartners\ngithub\ntwitter\ndiscord\nAPI Preference\nOptions\nComposition\n?\n\nAPI style now defaults to Composition API.\n\nSome pages contain different content based on the API style chosen. Use this switch to toggle between APIs styles.\n\nLearn moreGot it\n\nSidebar Navigation\nGetting Started\n\nIntroduction\n\nQuick Start\n\nEssentials\n\nCreating an Application\n\nTemplate Syntax\n\nReactivity Fundamentals\n\nComputed Properties\n\nClass and Style Bindings\n\nConditional Rendering\n\nList Rendering\n\nEvent Handling\n\nForm Input Bindings\n\nLifecycle Hooks\n\nWatchers\n\nTemplate Refs\n\nComponents Basics\n\nComponents In-Depth\n\nRegistration\n\nProps\n\nEvents\n\nComponent v-model\n\nFallthrough Attributes\n\nSlots\n\nProvide / inject\n\nAsync Components\n\nReusability\n\nComposables\n\nCustom Directives\n\nPlugins\n\nBuilt-in Components\n\nTransition\n\nTransitionGroup\n\nKeepAlive\n\nTeleport\n\nSuspense\n\nScaling Up\n\nSingle-File Components\n\nTooling\n\nRouting\n\nState Management\n\nTesting\n\nServer-Side Rendering (SSR)\n\nBest Practices\n\nProduction Deployment\n\nPerformance\n\nAccessibility\n\nSecurity\n\nTypeScript\n\nOverview\n\nTS with Composition API\n\nTS with Options API\n\nExtra Topics\n\nWays of Using Vue\n\nComposition API FAQ\n\nReactivity in Depth\n\nRendering Mechanism\n\nRender Functions & JSX\n\nVue and Web Components\n\nAnimation Techniques\n\nON THIS PAGE\nTable of Contents for current page\nAccessing the Refs\nRefs inside v-for\nFunction Refs\nRef on Component\nSPONSORS\nBecome a Sponsor\nBoost efficiency with Cloud Native. Prioritise your apps & customers\nADS VIA CARBON\nTemplate Refs\n​\n\nWhile Vue's declarative rendering model abstracts away most of the direct DOM operations for you, there may still be cases where we need direct access to the underlying DOM elements. To achieve this, we can use the special ref attribute:\n\ntemplate\n<input ref=\"input\">\n\nref is a special attribute, similar to the key attribute discussed in the v-for chapter. It allows us to obtain a direct reference to a specific DOM element or child component instance after it's mounted. This may be useful when you want to, for example, programmatically focus an input on component mount, or initialize a 3rd party library on an element.\n\nAccessing the Refs\n​\n\nTo obtain the reference with Composition API, we need to declare a ref with a name that matches the template ref attribute's value:\n\nvue\n<script setup>\nimport { ref, onMounted } from 'vue'\n\n// declare a ref to hold the element reference\n// the name must match template ref value\nconst input = ref(null)\n\nonMounted(() => {\n  input.value.focus()\n})\n</script>\n\n<template>\n  <input ref=\"input\" />\n</template>\n\nIf not using <script setup>, make sure to also return the ref from setup():\n\njs\nexport default {\n  setup() {\n    const input = ref(null)\n    // ...\n    return {\n      input\n    }\n  }\n}\n\nNote that you can only access the ref after the component is mounted. If you try to access input in a template expression, it will be null on the first render. This is because the element doesn't exist until after the first render!\n\nIf you are trying to watch the changes of a template ref, make sure to account for the case where the ref has null value:\n\njs\nwatchEffect(() => {\n  if (input.value) {\n    input.value.focus()\n  } else {\n    // not mounted yet, or the element was unmounted (e.g. by v-if)\n  }\n})\n\nSee also: Typing Template Refs \n\nRefs inside v-for\n​\n\nRequires v3.2.25 or above\n\nWhen ref is used inside v-for, the corresponding ref should contain an Array value, which will be populated with the elements after mount:\n\nvue\n<script setup>\nimport { ref, onMounted } from 'vue'\n\nconst list = ref([\n  /* ... */\n])\n\nconst itemRefs = ref([])\n\nonMounted(() => console.log(itemRefs.value))\n</script>\n\n<template>\n  <ul>\n    <li v-for=\"item in list\" ref=\"itemRefs\">\n      {{ item }}\n    </li>\n  </ul>\n</template>\n\nTry it in the Playground\n\nIt should be noted that the ref array does not guarantee the same order as the source array.\n\nFunction Refs\n​\n\nInstead of a string key, the ref attribute can also be bound to a function, which will be called on each component update and gives you full flexibility on where to store the element reference. The function receives the element reference as the first argument:\n\ntemplate\n<input :ref=\"(el) => { /* assign el to a property or ref */ }\">\n\nNote we are using a dynamic :ref binding so we can pass it a function instead of a ref name string. When the element is unmounted, the argument will be null. You can, of course, use a method instead of an inline function.\n\nRef on Component\n​\n\nThis section assumes knowledge of Components. Feel free to skip it and come back later.\n\nref can also be used on a child component. In this case the reference will be that of a component instance:\n\nvue\n<script setup>\nimport { ref, onMounted } from 'vue'\nimport Child from './Child.vue'\n\nconst child = ref(null)\n\nonMounted(() => {\n  // child.value will hold an instance of <Child />\n})\n</script>\n\n<template>\n  <Child ref=\"child\" />\n</template>\n\nIf the child component is using Options API or not using <script setup>, the referenced instance will be identical to the child component's this, which means the parent component will have full access to every property and method of the child component. This makes it easy to create tightly coupled implementation details between the parent and the child, so component refs should be only used when absolutely needed - in most cases, you should try to implement parent / child interactions using the standard props and emit interfaces first.\n\nAn exception here is that components using <script setup> are private by default: a parent component referencing a child component using <script setup> won't be able to access anything unless the child component chooses to expose a public interface using the defineExpose macro:\n\nvue\n<script setup>\nimport { ref } from 'vue'\n\nconst a = 1\nconst b = ref(2)\n\n// Compiler macros, such as defineExpose, don't need to be imported\ndefineExpose({\n  a,\n  b\n})\n</script>\n\nWhen a parent gets an instance of this component via template refs, the retrieved instance will be of the shape { a: number, b: number } (refs are automatically unwrapped just like on normal instances).\n\nSee also: Typing Component Template Refs \n\nEdit this page on GitHub\n\n Previous\nWatchers\nNext \nComponents Basics\nTemplate Refs has loaded"
  },
  {
    "title": "Watchers | Vue.js",
    "url": "https://vuejs.org/guide/essentials/watchers",
    "html": "Skip to content\nGet 60% off a year of Vue Mastery courses\nGET DISCOUNT\nVue.js\nSearch\nCtrl\nK\nMain Navigation\nDocs\nAPI\nPlayground\nEcosystem\nAbout\nSponsor\nPartners\ngithub\ntwitter\ndiscord\nAPI Preference\nOptions\nComposition\n?\n\nAPI style now defaults to Composition API.\n\nSome pages contain different content based on the API style chosen. Use this switch to toggle between APIs styles.\n\nLearn moreGot it\n\nSidebar Navigation\nGetting Started\n\nIntroduction\n\nQuick Start\n\nEssentials\n\nCreating an Application\n\nTemplate Syntax\n\nReactivity Fundamentals\n\nComputed Properties\n\nClass and Style Bindings\n\nConditional Rendering\n\nList Rendering\n\nEvent Handling\n\nForm Input Bindings\n\nLifecycle Hooks\n\nWatchers\n\nTemplate Refs\n\nComponents Basics\n\nComponents In-Depth\n\nRegistration\n\nProps\n\nEvents\n\nComponent v-model\n\nFallthrough Attributes\n\nSlots\n\nProvide / inject\n\nAsync Components\n\nReusability\n\nComposables\n\nCustom Directives\n\nPlugins\n\nBuilt-in Components\n\nTransition\n\nTransitionGroup\n\nKeepAlive\n\nTeleport\n\nSuspense\n\nScaling Up\n\nSingle-File Components\n\nTooling\n\nRouting\n\nState Management\n\nTesting\n\nServer-Side Rendering (SSR)\n\nBest Practices\n\nProduction Deployment\n\nPerformance\n\nAccessibility\n\nSecurity\n\nTypeScript\n\nOverview\n\nTS with Composition API\n\nTS with Options API\n\nExtra Topics\n\nWays of Using Vue\n\nComposition API FAQ\n\nReactivity in Depth\n\nRendering Mechanism\n\nRender Functions & JSX\n\nVue and Web Components\n\nAnimation Techniques\n\nON THIS PAGE\nTable of Contents for current page\nBasic Example\nDeep Watchers\nEager Watchers\nOnce Watchers\nwatchEffect()\nCallback Flush Timing\nStopping a Watcher\nSPONSORS\nBecome a Sponsor\nWatchers\n​\nBasic Example\n​\n\nComputed properties allow us to declaratively compute derived values. However, there are cases where we need to perform \"side effects\" in reaction to state changes - for example, mutating the DOM, or changing another piece of state based on the result of an async operation.\n\nWith Composition API, we can use the watch function to trigger a callback whenever a piece of reactive state changes:\n\nvue\n<script setup>\nimport { ref, watch } from 'vue'\n\nconst question = ref('')\nconst answer = ref('Questions usually contain a question mark. ;-)')\nconst loading = ref(false)\n\n// watch works directly on a ref\nwatch(question, async (newQuestion, oldQuestion) => {\n  if (newQuestion.includes('?')) {\n    loading.value = true\n    answer.value = 'Thinking...'\n    try {\n      const res = await fetch('https://yesno.wtf/api')\n      answer.value = (await res.json()).answer\n    } catch (error) {\n      answer.value = 'Error! Could not reach the API. ' + error\n    } finally {\n      loading.value = false\n    }\n  }\n})\n</script>\n\n<template>\n  <p>\n    Ask a yes/no question:\n    <input v-model=\"question\" :disabled=\"loading\" />\n  </p>\n  <p>{{ answer }}</p>\n</template>\n\nTry it in the Playground\n\nWatch Source Types\n​\n\nwatch's first argument can be different types of reactive \"sources\": it can be a ref (including computed refs), a reactive object, a getter function, or an array of multiple sources:\n\njs\nconst x = ref(0)\nconst y = ref(0)\n\n// single ref\nwatch(x, (newX) => {\n  console.log(`x is ${newX}`)\n})\n\n// getter\nwatch(\n  () => x.value + y.value,\n  (sum) => {\n    console.log(`sum of x + y is: ${sum}`)\n  }\n)\n\n// array of multiple sources\nwatch([x, () => y.value], ([newX, newY]) => {\n  console.log(`x is ${newX} and y is ${newY}`)\n})\n\nDo note that you can't watch a property of a reactive object like this:\n\njs\nconst obj = reactive({ count: 0 })\n\n// this won't work because we are passing a number to watch()\nwatch(obj.count, (count) => {\n  console.log(`Count is: ${count}`)\n})\n\nInstead, use a getter:\n\njs\n// instead, use a getter:\nwatch(\n  () => obj.count,\n  (count) => {\n    console.log(`Count is: ${count}`)\n  }\n)\nDeep Watchers\n​\n\nWhen you call watch() directly on a reactive object, it will implicitly create a deep watcher - the callback will be triggered on all nested mutations:\n\njs\nconst obj = reactive({ count: 0 })\n\nwatch(obj, (newValue, oldValue) => {\n  // fires on nested property mutations\n  // Note: `newValue` will be equal to `oldValue` here\n  // because they both point to the same object!\n})\n\nobj.count++\n\nThis should be differentiated with a getter that returns a reactive object - in the latter case, the callback will only fire if the getter returns a different object:\n\njs\nwatch(\n  () => state.someObject,\n  () => {\n    // fires only when state.someObject is replaced\n  }\n)\n\nYou can, however, force the second case into a deep watcher by explicitly using the deep option:\n\njs\nwatch(\n  () => state.someObject,\n  (newValue, oldValue) => {\n    // Note: `newValue` will be equal to `oldValue` here\n    // *unless* state.someObject has been replaced\n  },\n  { deep: true }\n)\n\nUse with Caution\n\nDeep watch requires traversing all nested properties in the watched object, and can be expensive when used on large data structures. Use it only when necessary and beware of the performance implications.\n\nEager Watchers\n​\n\nwatch is lazy by default: the callback won't be called until the watched source has changed. But in some cases we may want the same callback logic to be run eagerly - for example, we may want to fetch some initial data, and then re-fetch the data whenever relevant state changes.\n\nWe can force a watcher's callback to be executed immediately by passing the immediate: true option:\n\njs\nwatch(\n  source,\n  (newValue, oldValue) => {\n    // executed immediately, then again when `source` changes\n  },\n  { immediate: true }\n)\nOnce Watchers \n​\n\nWatcher's callback will execute whenever the watched source changes. If you want the callback to trigger only once when the source changes, use the once: true option.\n\njs\nwatch(\n  source,\n  (newValue, oldValue) => {\n    // when `source` changes, triggers only once\n  },\n  { once: true }\n)\nwatchEffect()\n​\n\nIt is common for the watcher callback to use exactly the same reactive state as the source. For example, consider the following code, which uses a watcher to load a remote resource whenever the todoId ref changes:\n\njs\nconst todoId = ref(1)\nconst data = ref(null)\n\nwatch(\n  todoId,\n  async () => {\n    const response = await fetch(\n      `https://jsonplaceholder.typicode.com/todos/${todoId.value}`\n    )\n    data.value = await response.json()\n  },\n  { immediate: true }\n)\n\nIn particular, notice how the watcher uses todoId twice, once as the source and then again inside the callback.\n\nThis can be simplified with watchEffect(). watchEffect() allows us to track the callback's reactive dependencies automatically. The watcher above can be rewritten as:\n\njs\nwatchEffect(async () => {\n  const response = await fetch(\n    `https://jsonplaceholder.typicode.com/todos/${todoId.value}`\n  )\n  data.value = await response.json()\n})\n\nHere, the callback will run immediately, there's no need to specify immediate: true. During its execution, it will automatically track todoId.value as a dependency (similar to computed properties). Whenever todoId.value changes, the callback will be run again. With watchEffect(), we no longer need to pass todoId explicitly as the source value.\n\nYou can check out this example of watchEffect() and reactive data-fetching in action.\n\nFor examples like these, with only one dependency, the benefit of watchEffect() is relatively small. But for watchers that have multiple dependencies, using watchEffect() removes the burden of having to maintain the list of dependencies manually. In addition, if you need to watch several properties in a nested data structure, watchEffect() may prove more efficient than a deep watcher, as it will only track the properties that are used in the callback, rather than recursively tracking all of them.\n\nTIP\n\nwatchEffect only tracks dependencies during its synchronous execution. When using it with an async callback, only properties accessed before the first await tick will be tracked.\n\nwatch vs. watchEffect\n​\n\nwatch and watchEffect both allow us to reactively perform side effects. Their main difference is the way they track their reactive dependencies:\n\nwatch only tracks the explicitly watched source. It won't track anything accessed inside the callback. In addition, the callback only triggers when the source has actually changed. watch separates dependency tracking from the side effect, giving us more precise control over when the callback should fire.\n\nwatchEffect, on the other hand, combines dependency tracking and side effect into one phase. It automatically tracks every reactive property accessed during its synchronous execution. This is more convenient and typically results in terser code, but makes its reactive dependencies less explicit.\n\nCallback Flush Timing\n​\n\nWhen you mutate reactive state, it may trigger both Vue component updates and watcher callbacks created by you.\n\nSimilar to component updates, user-created watcher callbacks are batched to avoid duplicate invocations. For example, we probably don't want a watcher to fire a thousand times if we synchronously push a thousand items into an array being watched.\n\nBy default, a watcher's callback is called after parent component updates (if any), and before the owner component's DOM updates. This means if you attempt to access the owner component's own DOM inside a watcher callback, the DOM will be in a pre-update state.\n\nPost Watchers\n​\n\nIf you want to access the owner component's DOM in a watcher callback after Vue has updated it, you need to specify the flush: 'post' option:\n\njs\nwatch(source, callback, {\n  flush: 'post'\n})\n\nwatchEffect(callback, {\n  flush: 'post'\n})\n\nPost-flush watchEffect() also has a convenience alias, watchPostEffect():\n\njs\nimport { watchPostEffect } from 'vue'\n\nwatchPostEffect(() => {\n  /* executed after Vue updates */\n})\nSync Watchers\n​\n\nIt's also possible to create a watcher that fires synchronously, before any Vue-managed updates:\n\njs\nwatch(source, callback, {\n  flush: 'sync'\n})\n\nwatchEffect(callback, {\n  flush: 'sync'\n})\n\nSync watchEffect() also has a convenience alias, watchSyncEffect():\n\njs\nimport { watchSyncEffect } from 'vue'\n\nwatchSyncEffect(() => {\n  /* executed synchronously upon reactive data change */\n})\n\nUse with Caution\n\nSync watchers do not have batching and triggers every time a reactive mutation is detected. It's ok to use them to watch simple boolean values, but avoid using them on data sources that might be synchronously mutated many times, e.g. arrays.\n\nStopping a Watcher\n​\n\nWatchers declared synchronously inside setup() or <script setup> are bound to the owner component instance, and will be automatically stopped when the owner component is unmounted. In most cases, you don't need to worry about stopping the watcher yourself.\n\nThe key here is that the watcher must be created synchronously: if the watcher is created in an async callback, it won't be bound to the owner component and must be stopped manually to avoid memory leaks. Here's an example:\n\nvue\n<script setup>\nimport { watchEffect } from 'vue'\n\n// this one will be automatically stopped\nwatchEffect(() => {})\n\n// ...this one will not!\nsetTimeout(() => {\n  watchEffect(() => {})\n}, 100)\n</script>\n\nTo manually stop a watcher, use the returned handle function. This works for both watch and watchEffect:\n\njs\nconst unwatch = watchEffect(() => {})\n\n// ...later, when no longer needed\nunwatch()\n\nNote that there should be very few cases where you need to create watchers asynchronously, and synchronous creation should be preferred whenever possible. If you need to wait for some async data, you can make your watch logic conditional instead:\n\njs\n// data to be loaded asynchronously\nconst data = ref(null)\n\nwatchEffect(() => {\n  if (data.value) {\n    // do something when data is loaded\n  }\n})\n\nEdit this page on GitHub\n\n Previous\nLifecycle Hooks\nNext \nTemplate Refs\nWatchers has loaded"
  },
  {
    "title": "Lifecycle Hooks | Vue.js",
    "url": "https://vuejs.org/guide/essentials/lifecycle",
    "html": "Skip to content\nGet 60% off a year of Vue Mastery courses\nGET DISCOUNT\nVue.js\nSearch\nCtrl\nK\nMain Navigation\nDocs\nAPI\nPlayground\nEcosystem\nAbout\nSponsor\nPartners\ngithub\ntwitter\ndiscord\nAPI Preference\nOptions\nComposition\n?\n\nAPI style now defaults to Composition API.\n\nSome pages contain different content based on the API style chosen. Use this switch to toggle between APIs styles.\n\nLearn moreGot it\n\nSidebar Navigation\nGetting Started\n\nIntroduction\n\nQuick Start\n\nEssentials\n\nCreating an Application\n\nTemplate Syntax\n\nReactivity Fundamentals\n\nComputed Properties\n\nClass and Style Bindings\n\nConditional Rendering\n\nList Rendering\n\nEvent Handling\n\nForm Input Bindings\n\nLifecycle Hooks\n\nWatchers\n\nTemplate Refs\n\nComponents Basics\n\nComponents In-Depth\n\nRegistration\n\nProps\n\nEvents\n\nComponent v-model\n\nFallthrough Attributes\n\nSlots\n\nProvide / inject\n\nAsync Components\n\nReusability\n\nComposables\n\nCustom Directives\n\nPlugins\n\nBuilt-in Components\n\nTransition\n\nTransitionGroup\n\nKeepAlive\n\nTeleport\n\nSuspense\n\nScaling Up\n\nSingle-File Components\n\nTooling\n\nRouting\n\nState Management\n\nTesting\n\nServer-Side Rendering (SSR)\n\nBest Practices\n\nProduction Deployment\n\nPerformance\n\nAccessibility\n\nSecurity\n\nTypeScript\n\nOverview\n\nTS with Composition API\n\nTS with Options API\n\nExtra Topics\n\nWays of Using Vue\n\nComposition API FAQ\n\nReactivity in Depth\n\nRendering Mechanism\n\nRender Functions & JSX\n\nVue and Web Components\n\nAnimation Techniques\n\nON THIS PAGE\nTable of Contents for current page\nRegistering Lifecycle Hooks\nLifecycle Diagram\nSPONSORS\nBecome a Sponsor\nShip Code. Not Containers. Render, the modern cloud for software teams.\nADS VIA CARBON\nLifecycle Hooks\n​\n\nEach Vue component instance goes through a series of initialization steps when it's created - for example, it needs to set up data observation, compile the template, mount the instance to the DOM, and update the DOM when data changes. Along the way, it also runs functions called lifecycle hooks, giving users the opportunity to add their own code at specific stages.\n\nRegistering Lifecycle Hooks\n​\n\nFor example, the onMounted hook can be used to run code after the component has finished the initial rendering and created the DOM nodes:\n\nvue\n<script setup>\nimport { onMounted } from 'vue'\n\nonMounted(() => {\n  console.log(`the component is now mounted.`)\n})\n</script>\n\nThere are also other hooks which will be called at different stages of the instance's lifecycle, with the most commonly used being onMounted, onUpdated, and onUnmounted.\n\nWhen calling onMounted, Vue automatically associates the registered callback function with the current active component instance. This requires these hooks to be registered synchronously during component setup. For example, do not do this:\n\njs\nsetTimeout(() => {\n  onMounted(() => {\n    // this won't work.\n  })\n}, 100)\n\nDo note this doesn't mean that the call must be placed lexically inside setup() or <script setup>. onMounted() can be called in an external function as long as the call stack is synchronous and originates from within setup().\n\nLifecycle Diagram\n​\n\nBelow is a diagram for the instance lifecycle. You don't need to fully understand everything going on right now, but as you learn and build more, it will be a useful reference.\n\nConsult the Lifecycle Hooks API reference for details on all lifecycle hooks and their respective use cases.\n\nEdit this page on GitHub\n\n Previous\nForm Input Bindings\nNext \nWatchers\nLifecycle Hooks has loaded"
  },
  {
    "title": "Form Input Bindings | Vue.js",
    "url": "https://vuejs.org/guide/essentials/forms",
    "html": "Skip to content\nGet 60% off a year of Vue Mastery courses\nGET DISCOUNT\nVue.js\nSearch\nCtrl\nK\nMain Navigation\nDocs\nAPI\nPlayground\nEcosystem\nAbout\nSponsor\nPartners\ngithub\ntwitter\ndiscord\nAPI Preference\nOptions\nComposition\n?\n\nAPI style now defaults to Composition API.\n\nSome pages contain different content based on the API style chosen. Use this switch to toggle between APIs styles.\n\nLearn moreGot it\n\nSidebar Navigation\nGetting Started\n\nIntroduction\n\nQuick Start\n\nEssentials\n\nCreating an Application\n\nTemplate Syntax\n\nReactivity Fundamentals\n\nComputed Properties\n\nClass and Style Bindings\n\nConditional Rendering\n\nList Rendering\n\nEvent Handling\n\nForm Input Bindings\n\nLifecycle Hooks\n\nWatchers\n\nTemplate Refs\n\nComponents Basics\n\nComponents In-Depth\n\nRegistration\n\nProps\n\nEvents\n\nComponent v-model\n\nFallthrough Attributes\n\nSlots\n\nProvide / inject\n\nAsync Components\n\nReusability\n\nComposables\n\nCustom Directives\n\nPlugins\n\nBuilt-in Components\n\nTransition\n\nTransitionGroup\n\nKeepAlive\n\nTeleport\n\nSuspense\n\nScaling Up\n\nSingle-File Components\n\nTooling\n\nRouting\n\nState Management\n\nTesting\n\nServer-Side Rendering (SSR)\n\nBest Practices\n\nProduction Deployment\n\nPerformance\n\nAccessibility\n\nSecurity\n\nTypeScript\n\nOverview\n\nTS with Composition API\n\nTS with Options API\n\nExtra Topics\n\nWays of Using Vue\n\nComposition API FAQ\n\nReactivity in Depth\n\nRendering Mechanism\n\nRender Functions & JSX\n\nVue and Web Components\n\nAnimation Techniques\n\nON THIS PAGE\nTable of Contents for current page\nBasic Usage\nText\nMultiline text\nCheckbox\nRadio\nSelect\nValue Bindings\nCheckbox\nRadio\nSelect Options\nModifiers\n.lazy\n.number\n.trim\nv-model with Components\nSPONSORS\nBecome a Sponsor\nForm Input Bindings\n​\nWatch a free video lesson on Vue School\n\nWhen dealing with forms on the frontend, we often need to sync the state of form input elements with corresponding state in JavaScript. It can be cumbersome to manually wire up value bindings and change event listeners:\n\ntemplate\n<input\n  :value=\"text\"\n  @input=\"event => text = event.target.value\">\n\nThe v-model directive helps us simplify the above to:\n\ntemplate\n<input v-model=\"text\">\n\nIn addition, v-model can be used on inputs of different types, <textarea>, and <select> elements. It automatically expands to different DOM property and event pairs based on the element it is used on:\n\n<input> with text types and <textarea> elements use value property and input event;\n<input type=\"checkbox\"> and <input type=\"radio\"> use checked property and change event;\n<select> uses value as a prop and change as an event.\n\nNote\n\nv-model will ignore the initial value, checked or selected attributes found on any form elements. It will always treat the current bound JavaScript state as the source of truth. You should declare the initial value on the JavaScript side, using reactivity APIs.\n\nBasic Usage\n​\nText\n​\ntemplate\n<p>Message is: {{ message }}</p>\n<input v-model=\"message\" placeholder=\"edit me\" />\n\nMessage is:\n\nTry it in the Playground\n\nNote\n\nFor languages that require an IME (Chinese, Japanese, Korean etc.), you'll notice that v-model doesn't get updated during IME composition. If you want to respond to these updates as well, use your own input event listener and value binding instead of using v-model.\n\nMultiline text\n​\ntemplate\n<span>Multiline message is:</span>\n<p style=\"white-space: pre-line;\">{{ message }}</p>\n<textarea v-model=\"message\" placeholder=\"add multiple lines\"></textarea>\nMultiline message is:\n\nTry it in the Playground\n\nNote that interpolation inside <textarea> won't work. Use v-model instead.\n\ntemplate\n<!-- bad -->\n<textarea>{{ text }}</textarea>\n\n<!-- good -->\n<textarea v-model=\"text\"></textarea>\nCheckbox\n​\n\nSingle checkbox, boolean value:\n\ntemplate\n<input type=\"checkbox\" id=\"checkbox\" v-model=\"checked\" />\n<label for=\"checkbox\">{{ checked }}</label>\nfalse\n\nTry it in the Playground\n\nWe can also bind multiple checkboxes to the same array or Set value:\n\njs\nconst checkedNames = ref([])\ntemplate\n<div>Checked names: {{ checkedNames }}</div>\n\n<input type=\"checkbox\" id=\"jack\" value=\"Jack\" v-model=\"checkedNames\">\n<label for=\"jack\">Jack</label>\n\n<input type=\"checkbox\" id=\"john\" value=\"John\" v-model=\"checkedNames\">\n<label for=\"john\">John</label>\n\n<input type=\"checkbox\" id=\"mike\" value=\"Mike\" v-model=\"checkedNames\">\n<label for=\"mike\">Mike</label>\nChecked names: []\nJackJohnMike\n\nIn this case, the checkedNames array will always contain the values from the currently checked boxes.\n\nTry it in the Playground\n\nRadio\n​\ntemplate\n<div>Picked: {{ picked }}</div>\n\n<input type=\"radio\" id=\"one\" value=\"One\" v-model=\"picked\" />\n<label for=\"one\">One</label>\n\n<input type=\"radio\" id=\"two\" value=\"Two\" v-model=\"picked\" />\n<label for=\"two\">Two</label>\nPicked:\nOneTwo\n\nTry it in the Playground\n\nSelect\n​\n\nSingle select:\n\ntemplate\n<div>Selected: {{ selected }}</div>\n\n<select v-model=\"selected\">\n  <option disabled value=\"\">Please select one</option>\n  <option>A</option>\n  <option>B</option>\n  <option>C</option>\n</select>\nSelected:\nPlease select one\nA\nB\nC\n\nTry it in the Playground\n\nNote\n\nIf the initial value of your v-model expression does not match any of the options, the <select> element will render in an \"unselected\" state. On iOS this will cause the user not being able to select the first item because iOS does not fire a change event in this case. It is therefore recommended to provide a disabled option with an empty value, as demonstrated in the example above.\n\nMultiple select (bound to array):\n\ntemplate\n<div>Selected: {{ selected }}</div>\n\n<select v-model=\"selected\" multiple>\n  <option>A</option>\n  <option>B</option>\n  <option>C</option>\n</select>\nSelected: []\nA\nB\nC\n\nTry it in the Playground\n\nSelect options can be dynamically rendered with v-for:\n\njs\nconst selected = ref('A')\n\nconst options = ref([\n  { text: 'One', value: 'A' },\n  { text: 'Two', value: 'B' },\n  { text: 'Three', value: 'C' }\n])\ntemplate\n<select v-model=\"selected\">\n  <option v-for=\"option in options\" :value=\"option.value\">\n    {{ option.text }}\n  </option>\n</select>\n\n<div>Selected: {{ selected }}</div>\n\nTry it in the Playground\n\nValue Bindings\n​\n\nFor radio, checkbox and select options, the v-model binding values are usually static strings (or booleans for checkbox):\n\ntemplate\n<!-- `picked` is a string \"a\" when checked -->\n<input type=\"radio\" v-model=\"picked\" value=\"a\" />\n\n<!-- `toggle` is either true or false -->\n<input type=\"checkbox\" v-model=\"toggle\" />\n\n<!-- `selected` is a string \"abc\" when the first option is selected -->\n<select v-model=\"selected\">\n  <option value=\"abc\">ABC</option>\n</select>\n\nBut sometimes we may want to bind the value to a dynamic property on the current active instance. We can use v-bind to achieve that. In addition, using v-bind allows us to bind the input value to non-string values.\n\nCheckbox\n​\ntemplate\n<input\n  type=\"checkbox\"\n  v-model=\"toggle\"\n  true-value=\"yes\"\n  false-value=\"no\" />\n\ntrue-value and false-value are Vue-specific attributes that only work with v-model. Here the toggle property's value will be set to 'yes' when the box is checked, and set to 'no' when unchecked. You can also bind them to dynamic values using v-bind:\n\ntemplate\n<input\n  type=\"checkbox\"\n  v-model=\"toggle\"\n  :true-value=\"dynamicTrueValue\"\n  :false-value=\"dynamicFalseValue\" />\n\nTip\n\nThe true-value and false-value attributes don't affect the input's value attribute, because browsers don't include unchecked boxes in form submissions. To guarantee that one of two values is submitted in a form (e.g. \"yes\" or \"no\"), use radio inputs instead.\n\nRadio\n​\ntemplate\n<input type=\"radio\" v-model=\"pick\" :value=\"first\" />\n<input type=\"radio\" v-model=\"pick\" :value=\"second\" />\n\npick will be set to the value of first when the first radio input is checked, and set to the value of second when the second one is checked.\n\nSelect Options\n​\ntemplate\n<select v-model=\"selected\">\n  <!-- inline object literal -->\n  <option :value=\"{ number: 123 }\">123</option>\n</select>\n\nv-model supports value bindings of non-string values as well! In the above example, when the option is selected, selected will be set to the object literal value of { number: 123 }.\n\nModifiers\n​\n.lazy\n​\n\nBy default, v-model syncs the input with the data after each input event (with the exception of IME composition as stated above). You can add the lazy modifier to instead sync after change events:\n\ntemplate\n<!-- synced after \"change\" instead of \"input\" -->\n<input v-model.lazy=\"msg\" />\n.number\n​\n\nIf you want user input to be automatically typecast as a number, you can add the number modifier to your v-model managed inputs:\n\ntemplate\n<input v-model.number=\"age\" />\n\nIf the value cannot be parsed with parseFloat(), then the original value is used instead.\n\nThe number modifier is applied automatically if the input has type=\"number\".\n\n.trim\n​\n\nIf you want whitespace from user input to be trimmed automatically, you can add the trim modifier to your v-model-managed inputs:\n\ntemplate\n<input v-model.trim=\"msg\" />\nv-model with Components\n​\n\nIf you're not yet familiar with Vue's components, you can skip this for now.\n\nHTML's built-in input types won't always meet your needs. Fortunately, Vue components allow you to build reusable inputs with completely customized behavior. These inputs even work with v-model! To learn more, read about Usage with v-model in the Components guide.\n\nEdit this page on GitHub\n\n Previous\nEvent Handling\nNext \nLifecycle Hooks\nForm Input Bindings has loaded"
  },
  {
    "title": "Event Handling | Vue.js",
    "url": "https://vuejs.org/guide/essentials/event-handling",
    "html": "Skip to content\nGet 60% off a year of Vue Mastery courses\nGET DISCOUNT\nVue.js\nSearch\nCtrl\nK\nMain Navigation\nDocs\nAPI\nPlayground\nEcosystem\nAbout\nSponsor\nPartners\ngithub\ntwitter\ndiscord\nAPI Preference\nOptions\nComposition\n?\n\nAPI style now defaults to Composition API.\n\nSome pages contain different content based on the API style chosen. Use this switch to toggle between APIs styles.\n\nLearn moreGot it\n\nSidebar Navigation\nGetting Started\n\nIntroduction\n\nQuick Start\n\nEssentials\n\nCreating an Application\n\nTemplate Syntax\n\nReactivity Fundamentals\n\nComputed Properties\n\nClass and Style Bindings\n\nConditional Rendering\n\nList Rendering\n\nEvent Handling\n\nForm Input Bindings\n\nLifecycle Hooks\n\nWatchers\n\nTemplate Refs\n\nComponents Basics\n\nComponents In-Depth\n\nRegistration\n\nProps\n\nEvents\n\nComponent v-model\n\nFallthrough Attributes\n\nSlots\n\nProvide / inject\n\nAsync Components\n\nReusability\n\nComposables\n\nCustom Directives\n\nPlugins\n\nBuilt-in Components\n\nTransition\n\nTransitionGroup\n\nKeepAlive\n\nTeleport\n\nSuspense\n\nScaling Up\n\nSingle-File Components\n\nTooling\n\nRouting\n\nState Management\n\nTesting\n\nServer-Side Rendering (SSR)\n\nBest Practices\n\nProduction Deployment\n\nPerformance\n\nAccessibility\n\nSecurity\n\nTypeScript\n\nOverview\n\nTS with Composition API\n\nTS with Options API\n\nExtra Topics\n\nWays of Using Vue\n\nComposition API FAQ\n\nReactivity in Depth\n\nRendering Mechanism\n\nRender Functions & JSX\n\nVue and Web Components\n\nAnimation Techniques\n\nON THIS PAGE\nTable of Contents for current page\nListening to Events\nInline Handlers\nMethod Handlers\nCalling Methods in Inline Handlers\nAccessing Event Argument in Inline Handlers\nEvent Modifiers\nKey Modifiers\nMouse Button Modifiers\nSPONSORS\nBecome a Sponsor\nCloud, simplified. Technology and expertise to manage the cloud from a Google Cloud Partner.\nADS VIA CARBON\nEvent Handling\n​\nWatch a free video lesson on Vue School\nListening to Events\n​\n\nWe can use the v-on directive, which we typically shorten to the @ symbol, to listen to DOM events and run some JavaScript when they're triggered. The usage would be v-on:click=\"handler\" or with the shortcut, @click=\"handler\".\n\nThe handler value can be one of the following:\n\nInline handlers: Inline JavaScript to be executed when the event is triggered (similar to the native onclick attribute).\n\nMethod handlers: A property name or path that points to a method defined on the component.\n\nInline Handlers\n​\n\nInline handlers are typically used in simple cases, for example:\n\njs\nconst count = ref(0)\ntemplate\n<button @click=\"count++\">Add 1</button>\n<p>Count is: {{ count }}</p>\n\nTry it in the Playground\n\nMethod Handlers\n​\n\nThe logic for many event handlers will be more complex though, and likely isn't feasible with inline handlers. That's why v-on can also accept the name or path of a component method you'd like to call.\n\nFor example:\n\njs\nconst name = ref('Vue.js')\n\nfunction greet(event) {\n  alert(`Hello ${name.value}!`)\n  // `event` is the native DOM event\n  if (event) {\n    alert(event.target.tagName)\n  }\n}\ntemplate\n<!-- `greet` is the name of the method defined above -->\n<button @click=\"greet\">Greet</button>\n\nTry it in the Playground\n\nA method handler automatically receives the native DOM Event object that triggers it - in the example above, we are able to access the element dispatching the event via event.target.\n\nSee also: Typing Event Handlers \n\nMethod vs. Inline Detection\n​\n\nThe template compiler detects method handlers by checking whether the v-on value string is a valid JavaScript identifier or property access path. For example, foo, foo.bar and foo['bar'] are treated as method handlers, while foo() and count++ are treated as inline handlers.\n\nCalling Methods in Inline Handlers\n​\n\nInstead of binding directly to a method name, we can also call methods in an inline handler. This allows us to pass the method custom arguments instead of the native event:\n\njs\nfunction say(message) {\n  alert(message)\n}\ntemplate\n<button @click=\"say('hello')\">Say hello</button>\n<button @click=\"say('bye')\">Say bye</button>\n\nTry it in the Playground\n\nAccessing Event Argument in Inline Handlers\n​\n\nSometimes we also need to access the original DOM event in an inline handler. You can pass it into a method using the special $event variable, or use an inline arrow function:\n\ntemplate\n<!-- using $event special variable -->\n<button @click=\"warn('Form cannot be submitted yet.', $event)\">\n  Submit\n</button>\n\n<!-- using inline arrow function -->\n<button @click=\"(event) => warn('Form cannot be submitted yet.', event)\">\n  Submit\n</button>\njs\nfunction warn(message, event) {\n  // now we have access to the native event\n  if (event) {\n    event.preventDefault()\n  }\n  alert(message)\n}\nEvent Modifiers\n​\n\nIt is a very common need to call event.preventDefault() or event.stopPropagation() inside event handlers. Although we can do this easily inside methods, it would be better if the methods can be purely about data logic rather than having to deal with DOM event details.\n\nTo address this problem, Vue provides event modifiers for v-on. Recall that modifiers are directive postfixes denoted by a dot.\n\n.stop\n.prevent\n.self\n.capture\n.once\n.passive\ntemplate\n<!-- the click event's propagation will be stopped -->\n<a @click.stop=\"doThis\"></a>\n\n<!-- the submit event will no longer reload the page -->\n<form @submit.prevent=\"onSubmit\"></form>\n\n<!-- modifiers can be chained -->\n<a @click.stop.prevent=\"doThat\"></a>\n\n<!-- just the modifier -->\n<form @submit.prevent></form>\n\n<!-- only trigger handler if event.target is the element itself -->\n<!-- i.e. not from a child element -->\n<div @click.self=\"doThat\">...</div>\n\nTIP\n\nOrder matters when using modifiers because the relevant code is generated in the same order. Therefore using @click.prevent.self will prevent click's default action on the element itself and its children, while @click.self.prevent will only prevent click's default action on the element itself.\n\nThe .capture, .once, and .passive modifiers mirror the options of the native addEventListener method:\n\ntemplate\n<!-- use capture mode when adding the event listener     -->\n<!-- i.e. an event targeting an inner element is handled -->\n<!-- here before being handled by that element           -->\n<div @click.capture=\"doThis\">...</div>\n\n<!-- the click event will be triggered at most once -->\n<a @click.once=\"doThis\"></a>\n\n<!-- the scroll event's default behavior (scrolling) will happen -->\n<!-- immediately, instead of waiting for `onScroll` to complete  -->\n<!-- in case it contains `event.preventDefault()`                -->\n<div @scroll.passive=\"onScroll\">...</div>\n\nThe .passive modifier is typically used with touch event listeners for improving performance on mobile devices.\n\nTIP\n\nDo not use .passive and .prevent together, because .passive already indicates to the browser that you do not intend to prevent the event's default behavior, and you will likely see a warning from the browser if you do so.\n\nKey Modifiers\n​\n\nWhen listening for keyboard events, we often need to check for specific keys. Vue allows adding key modifiers for v-on or @ when listening for key events:\n\ntemplate\n<!-- only call `submit` when the `key` is `Enter` -->\n<input @keyup.enter=\"submit\" />\n\nYou can directly use any valid key names exposed via KeyboardEvent.key as modifiers by converting them to kebab-case.\n\ntemplate\n<input @keyup.page-down=\"onPageDown\" />\n\nIn the above example, the handler will only be called if $event.key is equal to 'PageDown'.\n\nKey Aliases\n​\n\nVue provides aliases for the most commonly used keys:\n\n.enter\n.tab\n.delete (captures both \"Delete\" and \"Backspace\" keys)\n.esc\n.space\n.up\n.down\n.left\n.right\nSystem Modifier Keys\n​\n\nYou can use the following modifiers to trigger mouse or keyboard event listeners only when the corresponding modifier key is pressed:\n\n.ctrl\n.alt\n.shift\n.meta\n\nNote\n\nOn Macintosh keyboards, meta is the command key (⌘). On Windows keyboards, meta is the Windows key (⊞). On Sun Microsystems keyboards, meta is marked as a solid diamond (◆). On certain keyboards, specifically MIT and Lisp machine keyboards and successors, such as the Knight keyboard, space-cadet keyboard, meta is labeled “META”. On Symbolics keyboards, meta is labeled “META” or “Meta”.\n\nFor example:\n\ntemplate\n<!-- Alt + Enter -->\n<input @keyup.alt.enter=\"clear\" />\n\n<!-- Ctrl + Click -->\n<div @click.ctrl=\"doSomething\">Do something</div>\n\nTIP\n\nNote that modifier keys are different from regular keys and when used with keyup events, they have to be pressed when the event is emitted. In other words, keyup.ctrl will only trigger if you release a key while holding down ctrl. It won't trigger if you release the ctrl key alone.\n\n.exact Modifier\n​\n\nThe .exact modifier allows control of the exact combination of system modifiers needed to trigger an event.\n\ntemplate\n<!-- this will fire even if Alt or Shift is also pressed -->\n<button @click.ctrl=\"onClick\">A</button>\n\n<!-- this will only fire when Ctrl and no other keys are pressed -->\n<button @click.ctrl.exact=\"onCtrlClick\">A</button>\n\n<!-- this will only fire when no system modifiers are pressed -->\n<button @click.exact=\"onClick\">A</button>\nMouse Button Modifiers\n​\n.left\n.right\n.middle\n\nThese modifiers restrict the handler to events triggered by a specific mouse button.\n\nEdit this page on GitHub\n\n Previous\nList Rendering\nNext \nForm Input Bindings\nEvent Handling has loaded"
  },
  {
    "title": "List Rendering | Vue.js",
    "url": "https://vuejs.org/guide/essentials/list",
    "html": "Skip to content\nGet 60% off a year of Vue Mastery courses\nGET DISCOUNT\nVue.js\nSearch\nCtrl\nK\nMain Navigation\nDocs\nAPI\nPlayground\nEcosystem\nAbout\nSponsor\nPartners\ngithub\ntwitter\ndiscord\nAPI Preference\nOptions\nComposition\n?\n\nAPI style now defaults to Composition API.\n\nSome pages contain different content based on the API style chosen. Use this switch to toggle between APIs styles.\n\nLearn moreGot it\n\nSidebar Navigation\nGetting Started\n\nIntroduction\n\nQuick Start\n\nEssentials\n\nCreating an Application\n\nTemplate Syntax\n\nReactivity Fundamentals\n\nComputed Properties\n\nClass and Style Bindings\n\nConditional Rendering\n\nList Rendering\n\nEvent Handling\n\nForm Input Bindings\n\nLifecycle Hooks\n\nWatchers\n\nTemplate Refs\n\nComponents Basics\n\nComponents In-Depth\n\nRegistration\n\nProps\n\nEvents\n\nComponent v-model\n\nFallthrough Attributes\n\nSlots\n\nProvide / inject\n\nAsync Components\n\nReusability\n\nComposables\n\nCustom Directives\n\nPlugins\n\nBuilt-in Components\n\nTransition\n\nTransitionGroup\n\nKeepAlive\n\nTeleport\n\nSuspense\n\nScaling Up\n\nSingle-File Components\n\nTooling\n\nRouting\n\nState Management\n\nTesting\n\nServer-Side Rendering (SSR)\n\nBest Practices\n\nProduction Deployment\n\nPerformance\n\nAccessibility\n\nSecurity\n\nTypeScript\n\nOverview\n\nTS with Composition API\n\nTS with Options API\n\nExtra Topics\n\nWays of Using Vue\n\nComposition API FAQ\n\nReactivity in Depth\n\nRendering Mechanism\n\nRender Functions & JSX\n\nVue and Web Components\n\nAnimation Techniques\n\nON THIS PAGE\nTable of Contents for current page\nv-for\nv-for with an Object\nv-for with a Range\nv-for on <template>\nv-for with v-if\nMaintaining State with key\nv-for with a Component\nArray Change Detection\nDisplaying Filtered/Sorted Results\nSPONSORS\nBecome a Sponsor\nWhat are the risks of outsourcing your auth and how can you mitigate them? Find out in this eBook\nADS VIA CARBON\nList Rendering\n​\nWatch a free video lesson on Vue School\nv-for\n​\n\nWe can use the v-for directive to render a list of items based on an array. The v-for directive requires a special syntax in the form of item in items, where items is the source data array and item is an alias for the array element being iterated on:\n\njs\nconst items = ref([{ message: 'Foo' }, { message: 'Bar' }])\ntemplate\n<li v-for=\"item in items\">\n  {{ item.message }}\n</li>\n\nInside the v-for scope, template expressions have access to all parent scope properties. In addition, v-for also supports an optional second alias for the index of the current item:\n\njs\nconst parentMessage = ref('Parent')\nconst items = ref([{ message: 'Foo' }, { message: 'Bar' }])\ntemplate\n<li v-for=\"(item, index) in items\">\n  {{ parentMessage }} - {{ index }} - {{ item.message }}\n</li>\nParent - 0 - Foo\nParent - 1 - Bar\n\nTry it in the Playground\n\nThe variable scoping of v-for is similar to the following JavaScript:\n\njs\nconst parentMessage = 'Parent'\nconst items = [\n  /* ... */\n]\n\nitems.forEach((item, index) => {\n  // has access to outer scope `parentMessage`\n  // but `item` and `index` are only available in here\n  console.log(parentMessage, item.message, index)\n})\n\nNotice how the v-for value matches the function signature of the forEach callback. In fact, you can use destructuring on the v-for item alias similar to destructuring function arguments:\n\ntemplate\n<li v-for=\"{ message } in items\">\n  {{ message }}\n</li>\n\n<!-- with index alias -->\n<li v-for=\"({ message }, index) in items\">\n  {{ message }} {{ index }}\n</li>\n\nFor nested v-for, scoping also works similar to nested functions. Each v-for scope has access to parent scopes:\n\ntemplate\n<li v-for=\"item in items\">\n  <span v-for=\"childItem in item.children\">\n    {{ item.message }} {{ childItem }}\n  </span>\n</li>\n\nYou can also use of as the delimiter instead of in, so that it is closer to JavaScript's syntax for iterators:\n\ntemplate\n<div v-for=\"item of items\"></div>\nv-for with an Object\n​\n\nYou can also use v-for to iterate through the properties of an object. The iteration order will be based on the result of calling Object.keys() on the object:\n\njs\nconst myObject = reactive({\n  title: 'How to do lists in Vue',\n  author: 'Jane Doe',\n  publishedAt: '2016-04-10'\n})\ntemplate\n<ul>\n  <li v-for=\"value in myObject\">\n    {{ value }}\n  </li>\n</ul>\n\nYou can also provide a second alias for the property's name (a.k.a. key):\n\ntemplate\n<li v-for=\"(value, key) in myObject\">\n  {{ key }}: {{ value }}\n</li>\n\nAnd another for the index:\n\ntemplate\n<li v-for=\"(value, key, index) in myObject\">\n  {{ index }}. {{ key }}: {{ value }}\n</li>\n\nTry it in the Playground\n\nv-for with a Range\n​\n\nv-for can also take an integer. In this case it will repeat the template that many times, based on a range of 1...n.\n\ntemplate\n<span v-for=\"n in 10\">{{ n }}</span>\n\nNote here n starts with an initial value of 1 instead of 0.\n\nv-for on <template>\n​\n\nSimilar to template v-if, you can also use a <template> tag with v-for to render a block of multiple elements. For example:\n\ntemplate\n<ul>\n  <template v-for=\"item in items\">\n    <li>{{ item.msg }}</li>\n    <li class=\"divider\" role=\"presentation\"></li>\n  </template>\n</ul>\nv-for with v-if\n​\n\nNote\n\nIt's not recommended to use v-if and v-for on the same element due to implicit precedence. Refer to style guide for details.\n\nWhen they exist on the same node, v-if has a higher priority than v-for. That means the v-if condition will not have access to variables from the scope of the v-for:\n\ntemplate\n<!--\nThis will throw an error because property \"todo\"\nis not defined on instance.\n-->\n<li v-for=\"todo in todos\" v-if=\"!todo.isComplete\">\n  {{ todo.name }}\n</li>\n\nThis can be fixed by moving v-for to a wrapping <template> tag (which is also more explicit):\n\ntemplate\n<template v-for=\"todo in todos\">\n  <li v-if=\"!todo.isComplete\">\n    {{ todo.name }}\n  </li>\n</template>\nMaintaining State with key\n​\n\nWhen Vue is updating a list of elements rendered with v-for, by default it uses an \"in-place patch\" strategy. If the order of the data items has changed, instead of moving the DOM elements to match the order of the items, Vue will patch each element in-place and make sure it reflects what should be rendered at that particular index.\n\nThis default mode is efficient, but only suitable when your list render output does not rely on child component state or temporary DOM state (e.g. form input values).\n\nTo give Vue a hint so that it can track each node's identity, and thus reuse and reorder existing elements, you need to provide a unique key attribute for each item:\n\ntemplate\n<div v-for=\"item in items\" :key=\"item.id\">\n  <!-- content -->\n</div>\n\nWhen using <template v-for>, the key should be placed on the <template> container:\n\ntemplate\n<template v-for=\"todo in todos\" :key=\"todo.name\">\n  <li>{{ todo.name }}</li>\n</template>\n\nNote\n\nkey here is a special attribute being bound with v-bind. It should not be confused with the property key variable when using v-for with an object.\n\nIt is recommended to provide a key attribute with v-for whenever possible, unless the iterated DOM content is simple (i.e. contains no components or stateful DOM elements), or you are intentionally relying on the default behavior for performance gains.\n\nThe key binding expects primitive values - i.e. strings and numbers. Do not use objects as v-for keys. For detailed usage of the key attribute, please see the key API documentation.\n\nv-for with a Component\n​\n\nThis section assumes knowledge of Components. Feel free to skip it and come back later.\n\nYou can directly use v-for on a component, like any normal element (don't forget to provide a key):\n\ntemplate\n<MyComponent v-for=\"item in items\" :key=\"item.id\" />\n\nHowever, this won't automatically pass any data to the component, because components have isolated scopes of their own. In order to pass the iterated data into the component, we should also use props:\n\ntemplate\n<MyComponent\n  v-for=\"(item, index) in items\"\n  :item=\"item\"\n  :index=\"index\"\n  :key=\"item.id\"\n/>\n\nThe reason for not automatically injecting item into the component is because that makes the component tightly coupled to how v-for works. Being explicit about where its data comes from makes the component reusable in other situations.\n\nCheck out this example of a simple todo list to see how to render a list of components using v-for, passing different data to each instance.\n\nArray Change Detection\n​\nMutation Methods\n​\n\nVue is able to detect when a reactive array's mutation methods are called and trigger necessary updates. These mutation methods are:\n\npush()\npop()\nshift()\nunshift()\nsplice()\nsort()\nreverse()\nReplacing an Array\n​\n\nMutation methods, as the name suggests, mutate the original array they are called on. In comparison, there are also non-mutating methods, e.g. filter(), concat() and slice(), which do not mutate the original array but always return a new array. When working with non-mutating methods, we should replace the old array with the new one:\n\njs\n// `items` is a ref with array value\nitems.value = items.value.filter((item) => item.message.match(/Foo/))\n\nYou might think this will cause Vue to throw away the existing DOM and re-render the entire list - luckily, that is not the case. Vue implements some smart heuristics to maximize DOM element reuse, so replacing an array with another array containing overlapping objects is a very efficient operation.\n\nDisplaying Filtered/Sorted Results\n​\n\nSometimes we want to display a filtered or sorted version of an array without actually mutating or resetting the original data. In this case, you can create a computed property that returns the filtered or sorted array.\n\nFor example:\n\njs\nconst numbers = ref([1, 2, 3, 4, 5])\n\nconst evenNumbers = computed(() => {\n  return numbers.value.filter((n) => n % 2 === 0)\n})\ntemplate\n<li v-for=\"n in evenNumbers\">{{ n }}</li>\n\nIn situations where computed properties are not feasible (e.g. inside nested v-for loops), you can use a method:\n\njs\nconst sets = ref([\n  [1, 2, 3, 4, 5],\n  [6, 7, 8, 9, 10]\n])\n\nfunction even(numbers) {\n  return numbers.filter((number) => number % 2 === 0)\n}\ntemplate\n<ul v-for=\"numbers in sets\">\n  <li v-for=\"n in even(numbers)\">{{ n }}</li>\n</ul>\n\nBe careful with reverse() and sort() in a computed property! These two methods will mutate the original array, which should be avoided in computed getters. Create a copy of the original array before calling these methods:\n\ndiff\n- return numbers.reverse()\n+ return [...numbers].reverse()\n\nEdit this page on GitHub\n\n Previous\nConditional Rendering\nNext \nEvent Handling\nList Rendering has loaded"
  },
  {
    "title": "Conditional Rendering | Vue.js",
    "url": "https://vuejs.org/guide/essentials/conditional",
    "html": "Skip to content\nGet 60% off a year of Vue Mastery courses\nGET DISCOUNT\nVue.js\nSearch\nCtrl\nK\nMain Navigation\nDocs\nAPI\nPlayground\nEcosystem\nAbout\nSponsor\nPartners\ngithub\ntwitter\ndiscord\nAPI Preference\nOptions\nComposition\n?\n\nAPI style now defaults to Composition API.\n\nSome pages contain different content based on the API style chosen. Use this switch to toggle between APIs styles.\n\nLearn moreGot it\n\nSidebar Navigation\nGetting Started\n\nIntroduction\n\nQuick Start\n\nEssentials\n\nCreating an Application\n\nTemplate Syntax\n\nReactivity Fundamentals\n\nComputed Properties\n\nClass and Style Bindings\n\nConditional Rendering\n\nList Rendering\n\nEvent Handling\n\nForm Input Bindings\n\nLifecycle Hooks\n\nWatchers\n\nTemplate Refs\n\nComponents Basics\n\nComponents In-Depth\n\nRegistration\n\nProps\n\nEvents\n\nComponent v-model\n\nFallthrough Attributes\n\nSlots\n\nProvide / inject\n\nAsync Components\n\nReusability\n\nComposables\n\nCustom Directives\n\nPlugins\n\nBuilt-in Components\n\nTransition\n\nTransitionGroup\n\nKeepAlive\n\nTeleport\n\nSuspense\n\nScaling Up\n\nSingle-File Components\n\nTooling\n\nRouting\n\nState Management\n\nTesting\n\nServer-Side Rendering (SSR)\n\nBest Practices\n\nProduction Deployment\n\nPerformance\n\nAccessibility\n\nSecurity\n\nTypeScript\n\nOverview\n\nTS with Composition API\n\nTS with Options API\n\nExtra Topics\n\nWays of Using Vue\n\nComposition API FAQ\n\nReactivity in Depth\n\nRendering Mechanism\n\nRender Functions & JSX\n\nVue and Web Components\n\nAnimation Techniques\n\nON THIS PAGE\nTable of Contents for current page\nv-if\nv-else\nv-else-if\nv-if on <template>\nv-show\nv-if vs. v-show\nv-if with v-for\nSPONSORS\nBecome a Sponsor\nDowntime is expensive. Cloud Native keeps your business running\nADS VIA CARBON\nConditional Rendering\n​\nWatch a free video lesson on Vue School\nv-if\n​\n\nThe directive v-if is used to conditionally render a block. The block will only be rendered if the directive's expression returns a truthy value.\n\ntemplate\n<h1 v-if=\"awesome\">Vue is awesome!</h1>\nv-else\n​\n\nYou can use the v-else directive to indicate an \"else block\" for v-if:\n\ntemplate\n<button @click=\"awesome = !awesome\">Toggle</button>\n\n<h1 v-if=\"awesome\">Vue is awesome!</h1>\n<h1 v-else>Oh no 😢</h1>\nToggle\nVue is awesome!\n\nTry it in the Playground\n\nA v-else element must immediately follow a v-if or a v-else-if element - otherwise it will not be recognized.\n\nv-else-if\n​\n\nThe v-else-if, as the name suggests, serves as an \"else if block\" for v-if. It can also be chained multiple times:\n\ntemplate\n<div v-if=\"type === 'A'\">\n  A\n</div>\n<div v-else-if=\"type === 'B'\">\n  B\n</div>\n<div v-else-if=\"type === 'C'\">\n  C\n</div>\n<div v-else>\n  Not A/B/C\n</div>\n\nSimilar to v-else, a v-else-if element must immediately follow a v-if or a v-else-if element.\n\nv-if on <template>\n​\n\nBecause v-if is a directive, it has to be attached to a single element. But what if we want to toggle more than one element? In this case we can use v-if on a <template> element, which serves as an invisible wrapper. The final rendered result will not include the <template> element.\n\ntemplate\n<template v-if=\"ok\">\n  <h1>Title</h1>\n  <p>Paragraph 1</p>\n  <p>Paragraph 2</p>\n</template>\n\nv-else and v-else-if can also be used on <template>.\n\nv-show\n​\n\nAnother option for conditionally displaying an element is the v-show directive. The usage is largely the same:\n\ntemplate\n<h1 v-show=\"ok\">Hello!</h1>\n\nThe difference is that an element with v-show will always be rendered and remain in the DOM; v-show only toggles the display CSS property of the element.\n\nv-show doesn't support the <template> element, nor does it work with v-else.\n\nv-if vs. v-show\n​\n\nv-if is \"real\" conditional rendering because it ensures that event listeners and child components inside the conditional block are properly destroyed and re-created during toggles.\n\nv-if is also lazy: if the condition is false on initial render, it will not do anything - the conditional block won't be rendered until the condition becomes true for the first time.\n\nIn comparison, v-show is much simpler - the element is always rendered regardless of initial condition, with CSS-based toggling.\n\nGenerally speaking, v-if has higher toggle costs while v-show has higher initial render costs. So prefer v-show if you need to toggle something very often, and prefer v-if if the condition is unlikely to change at runtime.\n\nv-if with v-for\n​\n\nNote\n\nIt's not recommended to use v-if and v-for on the same element due to implicit precedence. Refer to style guide for details.\n\nWhen v-if and v-for are both used on the same element, v-if will be evaluated first. See the list rendering guide for details.\n\nEdit this page on GitHub\n\n Previous\nClass and Style Bindings\nNext \nList Rendering\nConditional Rendering has loaded"
  },
  {
    "title": "Class and Style Bindings | Vue.js",
    "url": "https://vuejs.org/guide/essentials/class-and-style",
    "html": "Skip to content\nGet 60% off a year of Vue Mastery courses\nGET DISCOUNT\nVue.js\nSearch\nCtrl\nK\nMain Navigation\nDocs\nAPI\nPlayground\nEcosystem\nAbout\nSponsor\nPartners\ngithub\ntwitter\ndiscord\nAPI Preference\nOptions\nComposition\n?\n\nAPI style now defaults to Composition API.\n\nSome pages contain different content based on the API style chosen. Use this switch to toggle between APIs styles.\n\nLearn moreGot it\n\nSidebar Navigation\nGetting Started\n\nIntroduction\n\nQuick Start\n\nEssentials\n\nCreating an Application\n\nTemplate Syntax\n\nReactivity Fundamentals\n\nComputed Properties\n\nClass and Style Bindings\n\nConditional Rendering\n\nList Rendering\n\nEvent Handling\n\nForm Input Bindings\n\nLifecycle Hooks\n\nWatchers\n\nTemplate Refs\n\nComponents Basics\n\nComponents In-Depth\n\nRegistration\n\nProps\n\nEvents\n\nComponent v-model\n\nFallthrough Attributes\n\nSlots\n\nProvide / inject\n\nAsync Components\n\nReusability\n\nComposables\n\nCustom Directives\n\nPlugins\n\nBuilt-in Components\n\nTransition\n\nTransitionGroup\n\nKeepAlive\n\nTeleport\n\nSuspense\n\nScaling Up\n\nSingle-File Components\n\nTooling\n\nRouting\n\nState Management\n\nTesting\n\nServer-Side Rendering (SSR)\n\nBest Practices\n\nProduction Deployment\n\nPerformance\n\nAccessibility\n\nSecurity\n\nTypeScript\n\nOverview\n\nTS with Composition API\n\nTS with Options API\n\nExtra Topics\n\nWays of Using Vue\n\nComposition API FAQ\n\nReactivity in Depth\n\nRendering Mechanism\n\nRender Functions & JSX\n\nVue and Web Components\n\nAnimation Techniques\n\nON THIS PAGE\nTable of Contents for current page\nBinding HTML Classes\nBinding Inline Styles\nSPONSORS\nBecome a Sponsor\nNever lose a byte with security updates always one step ahead\nADS VIA CARBON\nClass and Style Bindings\n​\n\nA common need for data binding is manipulating an element's class list and inline styles. Since class and style are both attributes, we can use v-bind to assign them a string value dynamically, much like with other attributes. However, trying to generate those values using string concatenation can be annoying and error-prone. For this reason, Vue provides special enhancements when v-bind is used with class and style. In addition to strings, the expressions can also evaluate to objects or arrays.\n\nBinding HTML Classes\n​\nWatch a free video lesson on Vue School\nBinding to Objects\n​\n\nWe can pass an object to :class (short for v-bind:class) to dynamically toggle classes:\n\ntemplate\n<div :class=\"{ active: isActive }\"></div>\n\nThe above syntax means the presence of the active class will be determined by the truthiness of the data property isActive.\n\nYou can have multiple classes toggled by having more fields in the object. In addition, the :class directive can also co-exist with the plain class attribute. So given the following state:\n\njs\nconst isActive = ref(true)\nconst hasError = ref(false)\n\nAnd the following template:\n\ntemplate\n<div\n  class=\"static\"\n  :class=\"{ active: isActive, 'text-danger': hasError }\"\n></div>\n\nIt will render:\n\ntemplate\n<div class=\"static active\"></div>\n\nWhen isActive or hasError changes, the class list will be updated accordingly. For example, if hasError becomes true, the class list will become \"static active text-danger\".\n\nThe bound object doesn't have to be inline:\n\njs\nconst classObject = reactive({\n  active: true,\n  'text-danger': false\n})\ntemplate\n<div :class=\"classObject\"></div>\n\nThis will render:\n\ntemplate\n<div class=\"active\"></div>\n\nWe can also bind to a computed property that returns an object. This is a common and powerful pattern:\n\njs\nconst isActive = ref(true)\nconst error = ref(null)\n\nconst classObject = computed(() => ({\n  active: isActive.value && !error.value,\n  'text-danger': error.value && error.value.type === 'fatal'\n}))\ntemplate\n<div :class=\"classObject\"></div>\nBinding to Arrays\n​\n\nWe can bind :class to an array to apply a list of classes:\n\njs\nconst activeClass = ref('active')\nconst errorClass = ref('text-danger')\ntemplate\n<div :class=\"[activeClass, errorClass]\"></div>\n\nWhich will render:\n\ntemplate\n<div class=\"active text-danger\"></div>\n\nIf you would like to also toggle a class in the list conditionally, you can do it with a ternary expression:\n\ntemplate\n<div :class=\"[isActive ? activeClass : '', errorClass]\"></div>\n\nThis will always apply errorClass, but activeClass will only be applied when isActive is truthy.\n\nHowever, this can be a bit verbose if you have multiple conditional classes. That's why it's also possible to use the object syntax inside the array syntax:\n\ntemplate\n<div :class=\"[{ activeClass: isActive }, errorClass]\"></div>\nWith Components\n​\n\nThis section assumes knowledge of Components. Feel free to skip it and come back later.\n\nWhen you use the class attribute on a component with a single root element, those classes will be added to the component's root element and merged with any existing class already on it.\n\nFor example, if we have a component named MyComponent with the following template:\n\ntemplate\n<!-- child component template -->\n<p class=\"foo bar\">Hi!</p>\n\nThen add some classes when using it:\n\ntemplate\n<!-- when using the component -->\n<MyComponent class=\"baz boo\" />\n\nThe rendered HTML will be:\n\ntemplate\n<p class=\"foo bar baz boo\">Hi!</p>\n\nThe same is true for class bindings:\n\ntemplate\n<MyComponent :class=\"{ active: isActive }\" />\n\nWhen isActive is truthy, the rendered HTML will be:\n\ntemplate\n<p class=\"foo bar active\">Hi!</p>\n\nIf your component has multiple root elements, you would need to define which element will receive this class. You can do this using the $attrs component property:\n\ntemplate\n<!-- MyComponent template using $attrs -->\n<p :class=\"$attrs.class\">Hi!</p>\n<span>This is a child component</span>\ntemplate\n<MyComponent class=\"baz\" />\n\nWill render:\n\nhtml\n<p class=\"baz\">Hi!</p>\n<span>This is a child component</span>\n\nYou can learn more about component attribute inheritance in Fallthrough Attributes section.\n\nBinding Inline Styles\n​\nBinding to Objects\n​\n\n:style supports binding to JavaScript object values - it corresponds to an HTML element's style property:\n\njs\nconst activeColor = ref('red')\nconst fontSize = ref(30)\ntemplate\n<div :style=\"{ color: activeColor, fontSize: fontSize + 'px' }\"></div>\n\nAlthough camelCase keys are recommended, :style also supports kebab-cased CSS property keys (corresponds to how they are used in actual CSS) - for example:\n\ntemplate\n<div :style=\"{ 'font-size': fontSize + 'px' }\"></div>\n\nIt is often a good idea to bind to a style object directly so that the template is cleaner:\n\njs\nconst styleObject = reactive({\n  color: 'red',\n  fontSize: '30px'\n})\ntemplate\n<div :style=\"styleObject\"></div>\n\nAgain, object style binding is often used in conjunction with computed properties that return objects.\n\nBinding to Arrays\n​\n\nWe can bind :style to an array of multiple style objects. These objects will be merged and applied to the same element:\n\ntemplate\n<div :style=\"[baseStyles, overridingStyles]\"></div>\nAuto-prefixing\n​\n\nWhen you use a CSS property that requires a vendor prefix in :style, Vue will automatically add the appropriate prefix. Vue does this by checking at runtime to see which style properties are supported in the current browser. If the browser doesn't support a particular property then various prefixed variants will be tested to try to find one that is supported.\n\nMultiple Values\n​\n\nYou can provide an array of multiple (prefixed) values to a style property, for example:\n\ntemplate\n<div :style=\"{ display: ['-webkit-box', '-ms-flexbox', 'flex'] }\"></div>\n\nThis will only render the last value in the array which the browser supports. In this example, it will render display: flex for browsers that support the unprefixed version of flexbox.\n\nEdit this page on GitHub\n\n Previous\nComputed Properties\nNext \nConditional Rendering\nClass and Style Bindings has loaded"
  },
  {
    "title": "Computed Properties | Vue.js",
    "url": "https://vuejs.org/guide/essentials/computed",
    "html": "Skip to content\nGet 60% off a year of Vue Mastery courses\nGET DISCOUNT\nVue.js\nSearch\nCtrl\nK\nMain Navigation\nDocs\nAPI\nPlayground\nEcosystem\nAbout\nSponsor\nPartners\ngithub\ntwitter\ndiscord\nAPI Preference\nOptions\nComposition\n?\n\nAPI style now defaults to Composition API.\n\nSome pages contain different content based on the API style chosen. Use this switch to toggle between APIs styles.\n\nLearn moreGot it\n\nSidebar Navigation\nGetting Started\n\nIntroduction\n\nQuick Start\n\nEssentials\n\nCreating an Application\n\nTemplate Syntax\n\nReactivity Fundamentals\n\nComputed Properties\n\nClass and Style Bindings\n\nConditional Rendering\n\nList Rendering\n\nEvent Handling\n\nForm Input Bindings\n\nLifecycle Hooks\n\nWatchers\n\nTemplate Refs\n\nComponents Basics\n\nComponents In-Depth\n\nRegistration\n\nProps\n\nEvents\n\nComponent v-model\n\nFallthrough Attributes\n\nSlots\n\nProvide / inject\n\nAsync Components\n\nReusability\n\nComposables\n\nCustom Directives\n\nPlugins\n\nBuilt-in Components\n\nTransition\n\nTransitionGroup\n\nKeepAlive\n\nTeleport\n\nSuspense\n\nScaling Up\n\nSingle-File Components\n\nTooling\n\nRouting\n\nState Management\n\nTesting\n\nServer-Side Rendering (SSR)\n\nBest Practices\n\nProduction Deployment\n\nPerformance\n\nAccessibility\n\nSecurity\n\nTypeScript\n\nOverview\n\nTS with Composition API\n\nTS with Options API\n\nExtra Topics\n\nWays of Using Vue\n\nComposition API FAQ\n\nReactivity in Depth\n\nRendering Mechanism\n\nRender Functions & JSX\n\nVue and Web Components\n\nAnimation Techniques\n\nON THIS PAGE\nTable of Contents for current page\nBasic Example\nComputed Caching vs. Methods\nWritable Computed\nBest Practices\nSPONSORS\nBecome a Sponsor\nComputed Properties\n​\nWatch a free video lesson on Vue School\nBasic Example\n​\n\nIn-template expressions are very convenient, but they are meant for simple operations. Putting too much logic in your templates can make them bloated and hard to maintain. For example, if we have an object with a nested array:\n\njs\nconst author = reactive({\n  name: 'John Doe',\n  books: [\n    'Vue 2 - Advanced Guide',\n    'Vue 3 - Basic Guide',\n    'Vue 4 - The Mystery'\n  ]\n})\n\nAnd we want to display different messages depending on if author already has some books or not:\n\ntemplate\n<p>Has published books:</p>\n<span>{{ author.books.length > 0 ? 'Yes' : 'No' }}</span>\n\nAt this point, the template is getting a bit cluttered. We have to look at it for a second before realizing that it performs a calculation depending on author.books. More importantly, we probably don't want to repeat ourselves if we need to include this calculation in the template more than once.\n\nThat's why for complex logic that includes reactive data, it is recommended to use a computed property. Here's the same example, refactored:\n\nvue\n<script setup>\nimport { reactive, computed } from 'vue'\n\nconst author = reactive({\n  name: 'John Doe',\n  books: [\n    'Vue 2 - Advanced Guide',\n    'Vue 3 - Basic Guide',\n    'Vue 4 - The Mystery'\n  ]\n})\n\n// a computed ref\nconst publishedBooksMessage = computed(() => {\n  return author.books.length > 0 ? 'Yes' : 'No'\n})\n</script>\n\n<template>\n  <p>Has published books:</p>\n  <span>{{ publishedBooksMessage }}</span>\n</template>\n\nTry it in the Playground\n\nHere we have declared a computed property publishedBooksMessage. The computed() function expects to be passed a getter function, and the returned value is a computed ref. Similar to normal refs, you can access the computed result as publishedBooksMessage.value. Computed refs are also auto-unwrapped in templates so you can reference them without .value in template expressions.\n\nA computed property automatically tracks its reactive dependencies. Vue is aware that the computation of publishedBooksMessage depends on author.books, so it will update any bindings that depend on publishedBooksMessage when author.books changes.\n\nSee also: Typing Computed \n\nComputed Caching vs. Methods\n​\n\nYou may have noticed we can achieve the same result by invoking a method in the expression:\n\ntemplate\n<p>{{ calculateBooksMessage() }}</p>\njs\n// in component\nfunction calculateBooksMessage() {\n  return author.books.length > 0 ? 'Yes' : 'No'\n}\n\nInstead of a computed property, we can define the same function as a method. For the end result, the two approaches are indeed exactly the same. However, the difference is that computed properties are cached based on their reactive dependencies. A computed property will only re-evaluate when some of its reactive dependencies have changed. This means as long as author.books has not changed, multiple access to publishedBooksMessage will immediately return the previously computed result without having to run the getter function again.\n\nThis also means the following computed property will never update, because Date.now() is not a reactive dependency:\n\njs\nconst now = computed(() => Date.now())\n\nIn comparison, a method invocation will always run the function whenever a re-render happens.\n\nWhy do we need caching? Imagine we have an expensive computed property list, which requires looping through a huge array and doing a lot of computations. Then we may have other computed properties that in turn depend on list. Without caching, we would be executing list’s getter many more times than necessary! In cases where you do not want caching, use a method call instead.\n\nWritable Computed\n​\n\nComputed properties are by default getter-only. If you attempt to assign a new value to a computed property, you will receive a runtime warning. In the rare cases where you need a \"writable\" computed property, you can create one by providing both a getter and a setter:\n\nvue\n<script setup>\nimport { ref, computed } from 'vue'\n\nconst firstName = ref('John')\nconst lastName = ref('Doe')\n\nconst fullName = computed({\n  // getter\n  get() {\n    return firstName.value + ' ' + lastName.value\n  },\n  // setter\n  set(newValue) {\n    // Note: we are using destructuring assignment syntax here.\n    [firstName.value, lastName.value] = newValue.split(' ')\n  }\n})\n</script>\n\nNow when you run fullName.value = 'John Doe', the setter will be invoked and firstName and lastName will be updated accordingly.\n\nBest Practices\n​\nGetters should be side-effect free\n​\n\nIt is important to remember that computed getter functions should only perform pure computation and be free of side effects. For example, don't mutate other state, make async requests, or mutate the DOM inside a computed getter! Think of a computed property as declaratively describing how to derive a value based on other values - its only responsibility should be computing and returning that value. Later in the guide we will discuss how we can perform side effects in reaction to state changes with watchers.\n\nAvoid mutating computed value\n​\n\nThe returned value from a computed property is derived state. Think of it as a temporary snapshot - every time the source state changes, a new snapshot is created. It does not make sense to mutate a snapshot, so a computed return value should be treated as read-only and never be mutated - instead, update the source state it depends on to trigger new computations.\n\nEdit this page on GitHub\n\n Previous\nReactivity Fundamentals\nNext \nClass and Style Bindings\nComputed Properties has loaded"
  },
  {
    "title": "Reactivity Fundamentals | Vue.js",
    "url": "https://vuejs.org/guide/essentials/reactivity-fundamentals",
    "html": "Skip to content\nGet 60% off a year of Vue Mastery courses\nGET DISCOUNT\nVue.js\nSearch\nCtrl\nK\nMain Navigation\nDocs\nAPI\nPlayground\nEcosystem\nAbout\nSponsor\nPartners\ngithub\ntwitter\ndiscord\nAPI Preference\nOptions\nComposition\n?\n\nAPI style now defaults to Composition API.\n\nSome pages contain different content based on the API style chosen. Use this switch to toggle between APIs styles.\n\nLearn moreGot it\n\nSidebar Navigation\nGetting Started\n\nIntroduction\n\nQuick Start\n\nEssentials\n\nCreating an Application\n\nTemplate Syntax\n\nReactivity Fundamentals\n\nComputed Properties\n\nClass and Style Bindings\n\nConditional Rendering\n\nList Rendering\n\nEvent Handling\n\nForm Input Bindings\n\nLifecycle Hooks\n\nWatchers\n\nTemplate Refs\n\nComponents Basics\n\nComponents In-Depth\n\nRegistration\n\nProps\n\nEvents\n\nComponent v-model\n\nFallthrough Attributes\n\nSlots\n\nProvide / inject\n\nAsync Components\n\nReusability\n\nComposables\n\nCustom Directives\n\nPlugins\n\nBuilt-in Components\n\nTransition\n\nTransitionGroup\n\nKeepAlive\n\nTeleport\n\nSuspense\n\nScaling Up\n\nSingle-File Components\n\nTooling\n\nRouting\n\nState Management\n\nTesting\n\nServer-Side Rendering (SSR)\n\nBest Practices\n\nProduction Deployment\n\nPerformance\n\nAccessibility\n\nSecurity\n\nTypeScript\n\nOverview\n\nTS with Composition API\n\nTS with Options API\n\nExtra Topics\n\nWays of Using Vue\n\nComposition API FAQ\n\nReactivity in Depth\n\nRendering Mechanism\n\nRender Functions & JSX\n\nVue and Web Components\n\nAnimation Techniques\n\nON THIS PAGE\nTable of Contents for current page\nDeclaring Reactive State\nref()\n<script setup>\nWhy Refs?\nDeep Reactivity\nDOM Update Timing\nreactive()\nReactive Proxy vs. Original\nLimitations of reactive()\nAdditional Ref Unwrapping Details\nAs Reactive Object Property\nCaveat in Arrays and Collections\nCaveat when Unwrapping in Templates\nSPONSORS\nBecome a Sponsor\nReactivity Fundamentals\n​\n\nAPI Preference\n\nThis page and many other chapters later in the guide contain different content for the Options API and the Composition API. Your current preference is Composition API. You can toggle between the API styles using the \"API Preference\" switches at the top of the left sidebar.\n\nDeclaring Reactive State\n​\nref()\n​\n\nIn Composition API, the recommended way to declare reactive state is using the ref() function:\n\njs\nimport { ref } from 'vue'\n\nconst count = ref(0)\n\nref() takes the argument and returns it wrapped within a ref object with a .value property:\n\njs\nconst count = ref(0)\n\nconsole.log(count) // { value: 0 }\nconsole.log(count.value) // 0\n\ncount.value++\nconsole.log(count.value) // 1\n\nSee also: Typing Refs \n\nTo access refs in a component's template, declare and return them from a component's setup() function:\n\njs\nimport { ref } from 'vue'\n\nexport default {\n  // `setup` is a special hook dedicated for the Composition API.\n  setup() {\n    const count = ref(0)\n\n    // expose the ref to the template\n    return {\n      count\n    }\n  }\n}\ntemplate\n<div>{{ count }}</div>\n\nNotice that we did not need to append .value when using the ref in the template. For convenience, refs are automatically unwrapped when used inside templates (with a few caveats).\n\nYou can also mutate a ref directly in event handlers:\n\ntemplate\n<button @click=\"count++\">\n  {{ count }}\n</button>\n\nFor more complex logic, we can declare functions that mutate refs in the same scope and expose them as methods alongside the state:\n\njs\nimport { ref } from 'vue'\n\nexport default {\n  setup() {\n    const count = ref(0)\n\n    function increment() {\n      // .value is needed in JavaScript\n      count.value++\n    }\n\n    // don't forget to expose the function as well.\n    return {\n      count,\n      increment\n    }\n  }\n}\n\nExposed methods can then be used as event handlers:\n\ntemplate\n<button @click=\"increment\">\n  {{ count }}\n</button>\n\nHere's the example live on Codepen, without using any build tools.\n\n<script setup>\n​\n\nManually exposing state and methods via setup() can be verbose. Luckily, it can be avoided when using Single-File Components (SFCs). We can simplify the usage with <script setup>:\n\nvue\n<script setup>\nimport { ref } from 'vue'\n\nconst count = ref(0)\n\nfunction increment() {\n  count.value++\n}\n</script>\n\n<template>\n  <button @click=\"increment\">\n    {{ count }}\n  </button>\n</template>\n\nTry it in the Playground\n\nTop-level imports, variables and functions declared in <script setup> are automatically usable in the template of the same component. Think of the template as a JavaScript function declared in the same scope - it naturally has access to everything declared alongside it.\n\nTIP\n\nFor the rest of the guide, we will be primarily using SFC + <script setup> syntax for the Composition API code examples, as that is the most common usage for Vue developers.\n\nIf you are not using SFC, you can still use Composition API with the setup() option.\n\nWhy Refs?\n​\n\nYou might be wondering why we need refs with the .value instead of plain variables. To explain that, we will need to briefly discuss how Vue's reactivity system works.\n\nWhen you use a ref in a template, and change the ref's value later, Vue automatically detects the change and updates the DOM accordingly. This is made possible with a dependency-tracking based reactivity system. When a component is rendered for the first time, Vue tracks every ref that was used during the render. Later on, when a ref is mutated, it will trigger a re-render for components that are tracking it.\n\nIn standard JavaScript, there is no way to detect the access or mutation of plain variables. However, we can intercept the get and set operations of an object's properties using getter and setter methods.\n\nThe .value property gives Vue the opportunity to detect when a ref has been accessed or mutated. Under the hood, Vue performs the tracking in its getter, and performs triggering in its setter. Conceptually, you can think of a ref as an object that looks like this:\n\njs\n// pseudo code, not actual implementation\nconst myRef = {\n  _value: 0,\n  get value() {\n    track()\n    return this._value\n  },\n  set value(newValue) {\n    this._value = newValue\n    trigger()\n  }\n}\n\nAnother nice trait of refs is that unlike plain variables, you can pass refs into functions while retaining access to the latest value and the reactivity connection. This is particularly useful when refactoring complex logic into reusable code.\n\nThe reactivity system is discussed in more details in the Reactivity in Depth section.\n\nDeep Reactivity\n​\n\nRefs can hold any value type, including deeply nested objects, arrays, or JavaScript built-in data structures like Map.\n\nA ref will make its value deeply reactive. This means you can expect changes to be detected even when you mutate nested objects or arrays:\n\njs\nimport { ref } from 'vue'\n\nconst obj = ref({\n  nested: { count: 0 },\n  arr: ['foo', 'bar']\n})\n\nfunction mutateDeeply() {\n  // these will work as expected.\n  obj.value.nested.count++\n  obj.value.arr.push('baz')\n}\n\nNon-primitive values are turned into reactive proxies via reactive(), which is discussed below.\n\nIt is also possible to opt-out of deep reactivity with shallow refs. For shallow refs, only .value access is tracked for reactivity. Shallow refs can be used for optimizing performance by avoiding the observation cost of large objects, or in cases where the inner state is managed by an external library.\n\nFurther reading:\n\nReduce Reactivity Overhead for Large Immutable Structures\nIntegration with External State Systems\nDOM Update Timing\n​\n\nWhen you mutate reactive state, the DOM is updated automatically. However, it should be noted that the DOM updates are not applied synchronously. Instead, Vue buffers them until the \"next tick\" in the update cycle to ensure that each component updates only once no matter how many state changes you have made.\n\nTo wait for the DOM update to complete after a state change, you can use the nextTick() global API:\n\njs\nimport { nextTick } from 'vue'\n\nasync function increment() {\n  count.value++\n  await nextTick()\n  // Now the DOM is updated\n}\nreactive()\n​\n\nThere is another way to declare reactive state, with the reactive() API. Unlike a ref which wraps the inner value in a special object, reactive() makes an object itself reactive:\n\njs\nimport { reactive } from 'vue'\n\nconst state = reactive({ count: 0 })\n\nSee also: Typing Reactive \n\nUsage in template:\n\ntemplate\n<button @click=\"state.count++\">\n  {{ state.count }}\n</button>\n\nReactive objects are JavaScript Proxies and behave just like normal objects. The difference is that Vue is able to intercept the access and mutation of all properties of a reactive object for reactivity tracking and triggering.\n\nreactive() converts the object deeply: nested objects are also wrapped with reactive() when accessed. It is also called by ref() internally when the ref value is an object. Similar to shallow refs, there is also the shallowReactive() API for opting-out of deep reactivity.\n\nReactive Proxy vs. Original\n​\n\nIt is important to note that the returned value from reactive() is a Proxy of the original object, which is not equal to the original object:\n\njs\nconst raw = {}\nconst proxy = reactive(raw)\n\n// proxy is NOT equal to the original.\nconsole.log(proxy === raw) // false\n\nOnly the proxy is reactive - mutating the original object will not trigger updates. Therefore, the best practice when working with Vue's reactivity system is to exclusively use the proxied versions of your state.\n\nTo ensure consistent access to the proxy, calling reactive() on the same object always returns the same proxy, and calling reactive() on an existing proxy also returns that same proxy:\n\njs\n// calling reactive() on the same object returns the same proxy\nconsole.log(reactive(raw) === proxy) // true\n\n// calling reactive() on a proxy returns itself\nconsole.log(reactive(proxy) === proxy) // true\n\nThis rule applies to nested objects as well. Due to deep reactivity, nested objects inside a reactive object are also proxies:\n\njs\nconst proxy = reactive({})\n\nconst raw = {}\nproxy.nested = raw\n\nconsole.log(proxy.nested === raw) // false\nLimitations of reactive()\n​\n\nThe reactive() API has a few limitations:\n\nLimited value types: it only works for object types (objects, arrays, and collection types such as Map and Set). It cannot hold primitive types such as string, number or boolean.\n\nCannot replace entire object: since Vue's reactivity tracking works over property access, we must always keep the same reference to the reactive object. This means we can't easily \"replace\" a reactive object because the reactivity connection to the first reference is lost:\n\njs\nlet state = reactive({ count: 0 })\n\n// the above reference ({ count: 0 }) is no longer being tracked\n// (reactivity connection is lost!)\nstate = reactive({ count: 1 })\n\nNot destructure-friendly: when we destructure a reactive object's primitive type property into local variables, or when we pass that property into a function, we will lose the reactivity connection:\n\njs\nconst state = reactive({ count: 0 })\n\n// count is disconnected from state.count when destructured.\nlet { count } = state\n// does not affect original state\ncount++\n\n// the function receives a plain number and\n// won't be able to track changes to state.count\n// we have to pass the entire object in to retain reactivity\ncallSomeFunction(state.count)\n\nDue to these limitations, we recommend using ref() as the primary API for declaring reactive state.\n\nAdditional Ref Unwrapping Details\n​\nAs Reactive Object Property\n​\n\nA ref is automatically unwrapped when accessed or mutated as a property of a reactive object. In other words, it behaves like a normal property :\n\njs\nconst count = ref(0)\nconst state = reactive({\n  count\n})\n\nconsole.log(state.count) // 0\n\nstate.count = 1\nconsole.log(count.value) // 1\n\nIf a new ref is assigned to a property linked to an existing ref, it will replace the old ref:\n\njs\nconst otherCount = ref(2)\n\nstate.count = otherCount\nconsole.log(state.count) // 2\n// original ref is now disconnected from state.count\nconsole.log(count.value) // 1\n\nRef unwrapping only happens when nested inside a deep reactive object. It does not apply when it is accessed as a property of a shallow reactive object.\n\nCaveat in Arrays and Collections\n​\n\nUnlike reactive objects, there is no unwrapping performed when the ref is accessed as an element of a reactive array or a native collection type like Map:\n\njs\nconst books = reactive([ref('Vue 3 Guide')])\n// need .value here\nconsole.log(books[0].value)\n\nconst map = reactive(new Map([['count', ref(0)]]))\n// need .value here\nconsole.log(map.get('count').value)\nCaveat when Unwrapping in Templates\n​\n\nRef unwrapping in templates only applies if the ref is a top-level property in the template render context.\n\nIn the example below, count and object are top-level properties, but object.id is not:\n\njs\nconst count = ref(0)\nconst object = { id: ref(1) }\n\nTherefore, this expression works as expected:\n\ntemplate\n{{ count + 1 }}\n\n...while this one does NOT:\n\ntemplate\n{{ object.id + 1 }}\n\nThe rendered result will be [object Object]1 because object.id is not unwrapped when evaluating the expression and remains a ref object. To fix this, we can destructure id into a top-level property:\n\njs\nconst { id } = object\ntemplate\n{{ id + 1 }}\n\nNow the render result will be 2.\n\nAnother thing to note is that a ref does get unwrapped if it is the final evaluated value of a text interpolation (i.e. a {{ }} tag), so the following will render 1:\n\ntemplate\n{{ object.id }}\n\nThis is just a convenience feature of text interpolation and is equivalent to {{ object.id.value }}.\n\nEdit this page on GitHub\n\n Previous\nTemplate Syntax\nNext \nComputed Properties\nReactivity Fundamentals has loaded"
  },
  {
    "title": "Template Syntax | Vue.js",
    "url": "https://vuejs.org/guide/essentials/template-syntax",
    "html": "Skip to content\nGet 60% off a year of Vue Mastery courses\nGET DISCOUNT\nVue.js\nSearch\nCtrl\nK\nMain Navigation\nDocs\nAPI\nPlayground\nEcosystem\nAbout\nSponsor\nPartners\ngithub\ntwitter\ndiscord\nAPI Preference\nOptions\nComposition\n?\n\nAPI style now defaults to Composition API.\n\nSome pages contain different content based on the API style chosen. Use this switch to toggle between APIs styles.\n\nLearn moreGot it\n\nSidebar Navigation\nGetting Started\n\nIntroduction\n\nQuick Start\n\nEssentials\n\nCreating an Application\n\nTemplate Syntax\n\nReactivity Fundamentals\n\nComputed Properties\n\nClass and Style Bindings\n\nConditional Rendering\n\nList Rendering\n\nEvent Handling\n\nForm Input Bindings\n\nLifecycle Hooks\n\nWatchers\n\nTemplate Refs\n\nComponents Basics\n\nComponents In-Depth\n\nRegistration\n\nProps\n\nEvents\n\nComponent v-model\n\nFallthrough Attributes\n\nSlots\n\nProvide / inject\n\nAsync Components\n\nReusability\n\nComposables\n\nCustom Directives\n\nPlugins\n\nBuilt-in Components\n\nTransition\n\nTransitionGroup\n\nKeepAlive\n\nTeleport\n\nSuspense\n\nScaling Up\n\nSingle-File Components\n\nTooling\n\nRouting\n\nState Management\n\nTesting\n\nServer-Side Rendering (SSR)\n\nBest Practices\n\nProduction Deployment\n\nPerformance\n\nAccessibility\n\nSecurity\n\nTypeScript\n\nOverview\n\nTS with Composition API\n\nTS with Options API\n\nExtra Topics\n\nWays of Using Vue\n\nComposition API FAQ\n\nReactivity in Depth\n\nRendering Mechanism\n\nRender Functions & JSX\n\nVue and Web Components\n\nAnimation Techniques\n\nON THIS PAGE\nTable of Contents for current page\nText Interpolation\nRaw HTML\nAttribute Bindings\nUsing JavaScript Expressions\nDirectives\nSPONSORS\nBecome a Sponsor\nFast implementation, a customizable login experience, and flexible user journeys. Try Auth0 for free\nADS VIA CARBON\nTemplate Syntax\n​\n\nVue uses an HTML-based template syntax that allows you to declaratively bind the rendered DOM to the underlying component instance's data. All Vue templates are syntactically valid HTML that can be parsed by spec-compliant browsers and HTML parsers.\n\nUnder the hood, Vue compiles the templates into highly-optimized JavaScript code. Combined with the reactivity system, Vue can intelligently figure out the minimal number of components to re-render and apply the minimal amount of DOM manipulations when the app state changes.\n\nIf you are familiar with Virtual DOM concepts and prefer the raw power of JavaScript, you can also directly write render functions instead of templates, with optional JSX support. However, do note that they do not enjoy the same level of compile-time optimizations as templates.\n\nText Interpolation\n​\n\nThe most basic form of data binding is text interpolation using the \"Mustache\" syntax (double curly braces):\n\ntemplate\n<span>Message: {{ msg }}</span>\n\nThe mustache tag will be replaced with the value of the msg property from the corresponding component instance. It will also be updated whenever the msg property changes.\n\nRaw HTML\n​\n\nThe double mustaches interpret the data as plain text, not HTML. In order to output real HTML, you will need to use the v-html directive:\n\ntemplate\n<p>Using text interpolation: {{ rawHtml }}</p>\n<p>Using v-html directive: <span v-html=\"rawHtml\"></span></p>\n\nUsing text interpolation: <span style=\"color: red\">This should be red.</span>\n\nUsing v-html directive: This should be red.\n\nHere we're encountering something new. The v-html attribute you're seeing is called a directive. Directives are prefixed with v- to indicate that they are special attributes provided by Vue, and as you may have guessed, they apply special reactive behavior to the rendered DOM. Here, we're basically saying \"keep this element's inner HTML up-to-date with the rawHtml property on the current active instance.\"\n\nThe contents of the span will be replaced with the value of the rawHtml property, interpreted as plain HTML - data bindings are ignored. Note that you cannot use v-html to compose template partials, because Vue is not a string-based templating engine. Instead, components are preferred as the fundamental unit for UI reuse and composition.\n\nSecurity Warning\n\nDynamically rendering arbitrary HTML on your website can be very dangerous because it can easily lead to XSS vulnerabilities. Only use v-html on trusted content and never on user-provided content.\n\nAttribute Bindings\n​\n\nMustaches cannot be used inside HTML attributes. Instead, use a v-bind directive:\n\ntemplate\n<div v-bind:id=\"dynamicId\"></div>\n\nThe v-bind directive instructs Vue to keep the element's id attribute in sync with the component's dynamicId property. If the bound value is null or undefined, then the attribute will be removed from the rendered element.\n\nShorthand\n​\n\nBecause v-bind is so commonly used, it has a dedicated shorthand syntax:\n\ntemplate\n<div :id=\"dynamicId\"></div>\n\nAttributes that start with : may look a bit different from normal HTML, but it is in fact a valid character for attribute names and all Vue-supported browsers can parse it correctly. In addition, they do not appear in the final rendered markup. The shorthand syntax is optional, but you will likely appreciate it when you learn more about its usage later.\n\nFor the rest of the guide, we will be using the shorthand syntax in code examples, as that's the most common usage for Vue developers.\n\nSame-name Shorthand \n​\n\nIf the attribute has the same name with the JavaScript value being bound, the syntax can be further shortened to omit the attribute value:\n\ntemplate\n<!-- same as :id=\"id\" -->\n<div :id></div>\n\n<!-- this also works -->\n<div v-bind:id></div>\n\nThis is similar to the property shorthand syntax when declaring objects in JavaScript. Note this is a feature that is only available in Vue 3.4 and above.\n\nBoolean Attributes\n​\n\nBoolean attributes are attributes that can indicate true / false values by their presence on an element. For example, disabled is one of the most commonly used boolean attributes.\n\nv-bind works a bit differently in this case:\n\ntemplate\n<button :disabled=\"isButtonDisabled\">Button</button>\n\nThe disabled attribute will be included if isButtonDisabled has a truthy value. It will also be included if the value is an empty string, maintaining consistency with <button disabled=\"\">. For other falsy values the attribute will be omitted.\n\nDynamically Binding Multiple Attributes\n​\n\nIf you have a JavaScript object representing multiple attributes that looks like this:\n\njs\nconst objectOfAttrs = {\n  id: 'container',\n  class: 'wrapper',\n  style: 'background-color:green'\n}\n\nYou can bind them to a single element by using v-bind without an argument:\n\ntemplate\n<div v-bind=\"objectOfAttrs\"></div>\nUsing JavaScript Expressions\n​\n\nSo far we've only been binding to simple property keys in our templates. But Vue actually supports the full power of JavaScript expressions inside all data bindings:\n\ntemplate\n{{ number + 1 }}\n\n{{ ok ? 'YES' : 'NO' }}\n\n{{ message.split('').reverse().join('') }}\n\n<div :id=\"`list-${id}`\"></div>\n\nThese expressions will be evaluated as JavaScript in the data scope of the current component instance.\n\nIn Vue templates, JavaScript expressions can be used in the following positions:\n\nInside text interpolations (mustaches)\nIn the attribute value of any Vue directives (special attributes that start with v-)\nExpressions Only\n​\n\nEach binding can only contain one single expression. An expression is a piece of code that can be evaluated to a value. A simple check is whether it can be used after return.\n\nTherefore, the following will NOT work:\n\ntemplate\n<!-- this is a statement, not an expression: -->\n{{ var a = 1 }}\n\n<!-- flow control won't work either, use ternary expressions -->\n{{ if (ok) { return message } }}\nCalling Functions\n​\n\nIt is possible to call a component-exposed method inside a binding expression:\n\ntemplate\n<time :title=\"toTitleDate(date)\" :datetime=\"date\">\n  {{ formatDate(date) }}\n</time>\n\nTIP\n\nFunctions called inside binding expressions will be called every time the component updates, so they should not have any side effects, such as changing data or triggering asynchronous operations.\n\nRestricted Globals Access\n​\n\nTemplate expressions are sandboxed and only have access to a restricted list of globals. The list exposes commonly used built-in globals such as Math and Date.\n\nGlobals not explicitly included in the list, for example user-attached properties on window, will not be accessible in template expressions. You can, however, explicitly define additional globals for all Vue expressions by adding them to app.config.globalProperties.\n\nDirectives\n​\n\nDirectives are special attributes with the v- prefix. Vue provides a number of built-in directives, including v-html and v-bind which we have introduced above.\n\nDirective attribute values are expected to be single JavaScript expressions (with the exception of v-for, v-on and v-slot, which will be discussed in their respective sections later). A directive's job is to reactively apply updates to the DOM when the value of its expression changes. Take v-if as an example:\n\ntemplate\n<p v-if=\"seen\">Now you see me</p>\n\nHere, the v-if directive would remove / insert the <p> element based on the truthiness of the value of the expression seen.\n\nArguments\n​\n\nSome directives can take an \"argument\", denoted by a colon after the directive name. For example, the v-bind directive is used to reactively update an HTML attribute:\n\ntemplate\n<a v-bind:href=\"url\"> ... </a>\n\n<!-- shorthand -->\n<a :href=\"url\"> ... </a>\n\nHere, href is the argument, which tells the v-bind directive to bind the element's href attribute to the value of the expression url. In the shorthand, everything before the argument (i.e., v-bind:) is condensed into a single character, :.\n\nAnother example is the v-on directive, which listens to DOM events:\n\ntemplate\n<a v-on:click=\"doSomething\"> ... </a>\n\n<!-- shorthand -->\n<a @click=\"doSomething\"> ... </a>\n\nHere, the argument is the event name to listen to: click. v-on has a corresponding shorthand, namely the @ character. We will talk about event handling in more detail too.\n\nDynamic Arguments\n​\n\nIt is also possible to use a JavaScript expression in a directive argument by wrapping it with square brackets:\n\ntemplate\n<!--\nNote that there are some constraints to the argument expression,\nas explained in the \"Dynamic Argument Value Constraints\" and \"Dynamic Argument Syntax Constraints\" sections below.\n-->\n<a v-bind:[attributeName]=\"url\"> ... </a>\n\n<!-- shorthand -->\n<a :[attributeName]=\"url\"> ... </a>\n\nHere, attributeName will be dynamically evaluated as a JavaScript expression, and its evaluated value will be used as the final value for the argument. For example, if your component instance has a data property, attributeName, whose value is \"href\", then this binding will be equivalent to v-bind:href.\n\nSimilarly, you can use dynamic arguments to bind a handler to a dynamic event name:\n\ntemplate\n<a v-on:[eventName]=\"doSomething\"> ... </a>\n\n<!-- shorthand -->\n<a @[eventName]=\"doSomething\"> ... </a>\n\nIn this example, when eventName's value is \"focus\", v-on:[eventName] will be equivalent to v-on:focus.\n\nDynamic Argument Value Constraints\n​\n\nDynamic arguments are expected to evaluate to a string, with the exception of null. The special value null can be used to explicitly remove the binding. Any other non-string value will trigger a warning.\n\nDynamic Argument Syntax Constraints\n​\n\nDynamic argument expressions have some syntax constraints because certain characters, such as spaces and quotes, are invalid inside HTML attribute names. For example, the following is invalid:\n\ntemplate\n<!-- This will trigger a compiler warning. -->\n<a :['foo' + bar]=\"value\"> ... </a>\n\nIf you need to pass a complex dynamic argument, it's probably better to use a computed property, which we will cover shortly.\n\nWhen using in-DOM templates (templates directly written in an HTML file), you should also avoid naming keys with uppercase characters, as browsers will coerce attribute names into lowercase:\n\ntemplate\n<a :[someAttr]=\"value\"> ... </a>\n\nThe above will be converted to :[someattr] in in-DOM templates. If your component has a someAttr property instead of someattr, your code won't work. Templates inside Single-File Components are not subject to this constraint.\n\nModifiers\n​\n\nModifiers are special postfixes denoted by a dot, which indicate that a directive should be bound in some special way. For example, the .prevent modifier tells the v-on directive to call event.preventDefault() on the triggered event:\n\ntemplate\n<form @submit.prevent=\"onSubmit\">...</form>\n\nYou'll see other examples of modifiers later, for v-on and for v-model, when we explore those features.\n\nAnd finally, here's the full directive syntax visualized:\n\nEdit this page on GitHub\n\n Previous\nCreating an Application\nNext \nReactivity Fundamentals\nTemplate Syntax has loaded"
  },
  {
    "title": "Creating a Vue Application | Vue.js",
    "url": "https://vuejs.org/guide/essentials/application",
    "html": "Skip to content\nGet 60% off a year of Vue Mastery courses\nGET DISCOUNT\nVue.js\nSearch\nCtrl\nK\nMain Navigation\nDocs\nAPI\nPlayground\nEcosystem\nAbout\nSponsor\nPartners\ngithub\ntwitter\ndiscord\nAPI Preference\nOptions\nComposition\n?\n\nAPI style now defaults to Composition API.\n\nSome pages contain different content based on the API style chosen. Use this switch to toggle between APIs styles.\n\nLearn moreGot it\n\nSidebar Navigation\nGetting Started\n\nIntroduction\n\nQuick Start\n\nEssentials\n\nCreating an Application\n\nTemplate Syntax\n\nReactivity Fundamentals\n\nComputed Properties\n\nClass and Style Bindings\n\nConditional Rendering\n\nList Rendering\n\nEvent Handling\n\nForm Input Bindings\n\nLifecycle Hooks\n\nWatchers\n\nTemplate Refs\n\nComponents Basics\n\nComponents In-Depth\n\nRegistration\n\nProps\n\nEvents\n\nComponent v-model\n\nFallthrough Attributes\n\nSlots\n\nProvide / inject\n\nAsync Components\n\nReusability\n\nComposables\n\nCustom Directives\n\nPlugins\n\nBuilt-in Components\n\nTransition\n\nTransitionGroup\n\nKeepAlive\n\nTeleport\n\nSuspense\n\nScaling Up\n\nSingle-File Components\n\nTooling\n\nRouting\n\nState Management\n\nTesting\n\nServer-Side Rendering (SSR)\n\nBest Practices\n\nProduction Deployment\n\nPerformance\n\nAccessibility\n\nSecurity\n\nTypeScript\n\nOverview\n\nTS with Composition API\n\nTS with Options API\n\nExtra Topics\n\nWays of Using Vue\n\nComposition API FAQ\n\nReactivity in Depth\n\nRendering Mechanism\n\nRender Functions & JSX\n\nVue and Web Components\n\nAnimation Techniques\n\nON THIS PAGE\nTable of Contents for current page\nThe application instance\nThe Root Component\nMounting the App\nApp Configurations\nMultiple application instances\nSPONSORS\nBecome a Sponsor\nSecure & Scalable. Boost Your Business Agility with Leading-Edge Servers for SMB\nADS VIA CARBON\nCreating a Vue Application\n​\nThe application instance\n​\n\nEvery Vue application starts by creating a new application instance with the createApp function:\n\njs\nimport { createApp } from 'vue'\n\nconst app = createApp({\n  /* root component options */\n})\nThe Root Component\n​\n\nThe object we are passing into createApp is in fact a component. Every app requires a \"root component\" that can contain other components as its children.\n\nIf you are using Single-File Components, we typically import the root component from another file:\n\njs\nimport { createApp } from 'vue'\n// import the root component App from a single-file component.\nimport App from './App.vue'\n\nconst app = createApp(App)\n\nWhile many examples in this guide only need a single component, most real applications are organized into a tree of nested, reusable components. For example, a Todo application's component tree might look like this:\n\nApp (root component)\n├─ TodoList\n│  └─ TodoItem\n│     ├─ TodoDeleteButton\n│     └─ TodoEditButton\n└─ TodoFooter\n   ├─ TodoClearButton\n   └─ TodoStatistics\n\nIn later sections of the guide, we will discuss how to define and compose multiple components together. Before that, we will focus on what happens inside a single component.\n\nMounting the App\n​\n\nAn application instance won't render anything until its .mount() method is called. It expects a \"container\" argument, which can either be an actual DOM element or a selector string:\n\nhtml\n<div id=\"app\"></div>\njs\napp.mount('#app')\n\nThe content of the app's root component will be rendered inside the container element. The container element itself is not considered part of the app.\n\nThe .mount() method should always be called after all app configurations and asset registrations are done. Also note that its return value, unlike the asset registration methods, is the root component instance instead of the application instance.\n\nIn-DOM Root Component Template\n​\n\nThe template for the root component is usually part of the component itself, but it is also possible to provide the template separately by writing it directly inside the mount container:\n\nhtml\n<div id=\"app\">\n  <button @click=\"count++\">{{ count }}</button>\n</div>\njs\nimport { createApp } from 'vue'\n\nconst app = createApp({\n  data() {\n    return {\n      count: 0\n    }\n  }\n})\n\napp.mount('#app')\n\nVue will automatically use the container's innerHTML as the template if the root component does not already have a template option.\n\nIn-DOM templates are often used in applications that are using Vue without a build step. They can also be used in conjunction with server-side frameworks, where the root template might be generated dynamically by the server.\n\nApp Configurations\n​\n\nThe application instance exposes a .config object that allows us to configure a few app-level options, for example, defining an app-level error handler that captures errors from all descendant components:\n\njs\napp.config.errorHandler = (err) => {\n  /* handle error */\n}\n\nThe application instance also provides a few methods for registering app-scoped assets. For example, registering a component:\n\njs\napp.component('TodoDeleteButton', TodoDeleteButton)\n\nThis makes the TodoDeleteButton available for use anywhere in our app. We will discuss registration for components and other types of assets in later sections of the guide. You can also browse the full list of application instance APIs in its API reference.\n\nMake sure to apply all app configurations before mounting the app!\n\nMultiple application instances\n​\n\nYou are not limited to a single application instance on the same page. The createApp API allows multiple Vue applications to co-exist on the same page, each with its own scope for configuration and global assets:\n\njs\nconst app1 = createApp({\n  /* ... */\n})\napp1.mount('#container-1')\n\nconst app2 = createApp({\n  /* ... */\n})\napp2.mount('#container-2')\n\nIf you are using Vue to enhance server-rendered HTML and only need Vue to control specific parts of a large page, avoid mounting a single Vue application instance on the entire page. Instead, create multiple small application instances and mount them on the elements they are responsible for.\n\nEdit this page on GitHub\n\n Previous\nQuick Start\nNext \nTemplate Syntax\nCreating a Vue Application has loaded"
  },
  {
    "title": "Tooling | Vue.js",
    "url": "https://vuejs.org/guide/scaling-up/tooling",
    "html": "Skip to content\nGet 60% off a year of Vue Mastery courses\nGET DISCOUNT\nVue.js\nSearch\nCtrl\nK\nMain Navigation\nDocs\nAPI\nPlayground\nEcosystem\nAbout\nSponsor\nPartners\ngithub\ntwitter\ndiscord\nAPI Preference\nOptions\nComposition\n?\n\nAPI style now defaults to Composition API.\n\nSome pages contain different content based on the API style chosen. Use this switch to toggle between APIs styles.\n\nLearn moreGot it\n\nSidebar Navigation\nGetting Started\n\nIntroduction\n\nQuick Start\n\nEssentials\n\nCreating an Application\n\nTemplate Syntax\n\nReactivity Fundamentals\n\nComputed Properties\n\nClass and Style Bindings\n\nConditional Rendering\n\nList Rendering\n\nEvent Handling\n\nForm Input Bindings\n\nLifecycle Hooks\n\nWatchers\n\nTemplate Refs\n\nComponents Basics\n\nComponents In-Depth\n\nRegistration\n\nProps\n\nEvents\n\nComponent v-model\n\nFallthrough Attributes\n\nSlots\n\nProvide / inject\n\nAsync Components\n\nReusability\n\nComposables\n\nCustom Directives\n\nPlugins\n\nBuilt-in Components\n\nTransition\n\nTransitionGroup\n\nKeepAlive\n\nTeleport\n\nSuspense\n\nScaling Up\n\nSingle-File Components\n\nTooling\n\nRouting\n\nState Management\n\nTesting\n\nServer-Side Rendering (SSR)\n\nBest Practices\n\nProduction Deployment\n\nPerformance\n\nAccessibility\n\nSecurity\n\nTypeScript\n\nOverview\n\nTS with Composition API\n\nTS with Options API\n\nExtra Topics\n\nWays of Using Vue\n\nComposition API FAQ\n\nReactivity in Depth\n\nRendering Mechanism\n\nRender Functions & JSX\n\nVue and Web Components\n\nAnimation Techniques\n\nON THIS PAGE\nTable of Contents for current page\nTry It Online\nProject Scaffolding\nIDE Support\nBrowser Devtools\nTypeScript\nTesting\nLinting\nFormatting\nSFC Custom Block Integrations\nLower-Level Packages\nOther Online Playgrounds\nSPONSORS\nBecome a Sponsor\nTooling\n​\nTry It Online\n​\n\nYou don't need to install anything on your machine to try out Vue SFCs - there are online playgrounds that allow you to do so right in the browser:\n\nVue SFC Playground\nAlways deployed from latest commit\nDesigned for inspecting component compilation results\nVue + Vite on StackBlitz\nIDE-like environment running actual Vite dev server in the browser\nClosest to local setup\n\nIt is also recommended to use these online playgrounds to provide reproductions when reporting bugs.\n\nProject Scaffolding\n​\nVite\n​\n\nVite is a lightweight and fast build tool with first-class Vue SFC support. It is created by Evan You, who is also the author of Vue!\n\nTo get started with Vite + Vue, simply run:\n\nnpm\npnpm\nyarn\nbun\nsh\n$ npm create vue@latest\n\nThis command will install and execute create-vue, the official Vue project scaffolding tool.\n\nTo learn more about Vite, check out the Vite docs.\nTo configure Vue-specific behavior in a Vite project, for example passing options to the Vue compiler, check out the docs for @vitejs/plugin-vue.\n\nBoth online playgrounds mentioned above also support downloading files as a Vite project.\n\nVue CLI\n​\n\nVue CLI is the official webpack-based toolchain for Vue. It is now in maintenance mode and we recommend starting new projects with Vite unless you rely on specific webpack-only features. Vite will provide superior developer experience in most cases.\n\nFor information on migrating from Vue CLI to Vite:\n\nVue CLI -> Vite Migration Guide from VueSchool.io\nTools / Plugins that help with auto migration\nNote on In-Browser Template Compilation\n​\n\nWhen using Vue without a build step, component templates are written either directly in the page's HTML or as inlined JavaScript strings. In such cases, Vue needs to ship the template compiler to the browser in order to perform on-the-fly template compilation. On the other hand, the compiler would be unnecessary if we pre-compile the templates with a build step. To reduce client bundle size, Vue provides different \"builds\" optimized for different use cases.\n\nBuild files that start with vue.runtime.* are runtime-only builds: they do not include the compiler. When using these builds, all templates must be pre-compiled via a build step.\n\nBuild files that do not include .runtime are full builds: they include the compiler and support compiling templates directly in the browser. However, they will increase the payload by ~14kb.\n\nOur default tooling setups use the runtime-only build since all templates in SFCs are pre-compiled. If, for some reason, you need in-browser template compilation even with a build step, you can do so by configuring the build tool to alias vue to vue/dist/vue.esm-bundler.js instead.\n\nIf you are looking for a lighter-weight alternative for no-build-step usage, check out petite-vue.\n\nIDE Support\n​\n\nThe recommended IDE setup is VS Code + the Vue - Official extension (previously Volar). The extension provides syntax highlighting, TypeScript support, and intellisense for template expressions and component props.\n\nTIP\n\nVue - Official replaces Vetur, our previous official VS Code extension for Vue 2. If you have Vetur currently installed, make sure to disable it in Vue 3 projects.\n\nWebStorm also provides great built-in support for Vue SFCs.\n\nOther IDEs that support the Language Service Protocol (LSP) can also leverage Volar's core functionalities via LSP:\n\nSublime Text support via LSP-Volar.\n\nvim / Neovim support via coc-volar.\n\nemacs support via lsp-mode\n\nBrowser Devtools\n​\nWatch a free video lesson on Vue School\n\nThe Vue browser devtools extension allows you to explore a Vue app's component tree, inspect the state of individual components, track state management events, and profile performance.\n\nDocumentation\nChrome Extension\nFirefox Addon\nEdge Extension\nStandalone Electron app\nTypeScript\n​\n\nMain article: Using Vue with TypeScript.\n\nVue - Official extension provides type checking for SFCs using <script lang=\"ts\"> blocks, including template expressions and cross-component props validation.\n\nUse vue-tsc for performing the same type checking from the command line, or for generating d.ts files for SFCs.\n\nTesting\n​\n\nMain article: Testing Guide.\n\nCypress is recommended for E2E tests. It can also be used for component testing for Vue SFCs via the Cypress Component Test Runner.\n\nVitest is a test runner created by Vue / Vite team members that focuses on speed. It is specifically designed for Vite-based applications to provide the same instant feedback loop for unit / component testing.\n\nJest can be made to work with Vite via vite-jest. However, this is only recommended if you have existing Jest-based test suites that you need to migrate over to a Vite-based setup, as Vitest provides similar functionalities with a much more efficient integration.\n\nLinting\n​\n\nThe Vue team maintains eslint-plugin-vue, an ESLint plugin that supports SFC-specific linting rules.\n\nUsers previously using Vue CLI may be used to having linters configured via webpack loaders. However when using a Vite-based build setup, our general recommendation is:\n\nnpm install -D eslint eslint-plugin-vue, then follow eslint-plugin-vue's configuration guide.\n\nSetup ESLint IDE extensions, for example ESLint for VS Code, so you get linter feedback right in your editor during development. This also avoids unnecessary linting cost when starting the dev server.\n\nRun ESLint as part of the production build command, so you get full linter feedback before shipping to production.\n\n(Optional) Setup tools like lint-staged to automatically lint modified files on git commit.\n\nFormatting\n​\n\nThe Vue - Official VS Code extension provides formatting for Vue SFCs out of the box.\n\nAlternatively, Prettier provides built-in Vue SFC formatting support.\n\nSFC Custom Block Integrations\n​\n\nCustom blocks are compiled into imports to the same Vue file with different request queries. It is up to the underlying build tool to handle these import requests.\n\nIf using Vite, a custom Vite plugin should be used to transform matched custom blocks into executable JavaScript. Example\n\nIf using Vue CLI or plain webpack, a webpack loader should be configured to transform the matched blocks. Example\n\nLower-Level Packages\n​\n@vue/compiler-sfc\n​\nDocs\n\nThis package is part of the Vue core monorepo and is always published with the same version as the main vue package. It is included as a dependency of the main vue package and proxied under vue/compiler-sfc so you don't need to install it individually.\n\nThe package itself provides lower-level utilities for processing Vue SFCs and is only meant for tooling authors that need to support Vue SFCs in custom tools.\n\nTIP\n\nAlways prefer using this package via the vue/compiler-sfc deep import since this ensures its version is in sync with the Vue runtime.\n\n@vitejs/plugin-vue\n​\nDocs\n\nOfficial plugin that provides Vue SFC support in Vite.\n\nvue-loader\n​\nDocs\n\nThe official loader that provides Vue SFC support in webpack. If you are using Vue CLI, also see docs on modifying vue-loader options in Vue CLI.\n\nOther Online Playgrounds\n​\nVueUse Playground\nVue + Vite on Repl.it\nVue on CodeSandbox\nVue on Codepen\nVue on Components.studio\nVue on WebComponents.dev\n\nEdit this page on GitHub\n\n Previous\nSingle-File Components\nNext \nRouting\nTooling has loaded"
  },
  {
    "title": "Introduction | Vue.js",
    "url": "https://vuejs.org/guide/introduction",
    "html": "Skip to content\nGet 60% off a year of Vue Mastery courses\nGET DISCOUNT\nVue.js\nSearch\nCtrl\nK\nMain Navigation\nDocs\nAPI\nPlayground\nEcosystem\nAbout\nSponsor\nPartners\ngithub\ntwitter\ndiscord\nAPI Preference\nOptions\nComposition\n?\n\nAPI style now defaults to Composition API.\n\nSome pages contain different content based on the API style chosen. Use this switch to toggle between APIs styles.\n\nLearn moreGot it\n\nSidebar Navigation\nGetting Started\n\nIntroduction\n\nQuick Start\n\nEssentials\n\nCreating an Application\n\nTemplate Syntax\n\nReactivity Fundamentals\n\nComputed Properties\n\nClass and Style Bindings\n\nConditional Rendering\n\nList Rendering\n\nEvent Handling\n\nForm Input Bindings\n\nLifecycle Hooks\n\nWatchers\n\nTemplate Refs\n\nComponents Basics\n\nComponents In-Depth\n\nRegistration\n\nProps\n\nEvents\n\nComponent v-model\n\nFallthrough Attributes\n\nSlots\n\nProvide / inject\n\nAsync Components\n\nReusability\n\nComposables\n\nCustom Directives\n\nPlugins\n\nBuilt-in Components\n\nTransition\n\nTransitionGroup\n\nKeepAlive\n\nTeleport\n\nSuspense\n\nScaling Up\n\nSingle-File Components\n\nTooling\n\nRouting\n\nState Management\n\nTesting\n\nServer-Side Rendering (SSR)\n\nBest Practices\n\nProduction Deployment\n\nPerformance\n\nAccessibility\n\nSecurity\n\nTypeScript\n\nOverview\n\nTS with Composition API\n\nTS with Options API\n\nExtra Topics\n\nWays of Using Vue\n\nComposition API FAQ\n\nReactivity in Depth\n\nRendering Mechanism\n\nRender Functions & JSX\n\nVue and Web Components\n\nAnimation Techniques\n\nON THIS PAGE\nTable of Contents for current page\nWhat is Vue?\nThe Progressive Framework\nSingle-File Components\nAPI Styles\nStill Got Questions?\nPick Your Learning Path\nSPONSORS\nBecome a Sponsor\nPower your apps & games with Eco Dedicated Servers. From £4.99/month. Shop now\nADS VIA CARBON\nIntroduction\n​\n\nYou are reading the documentation for Vue 3!\n\nVue 2 support has ended on Dec 31, 2023. Learn more about Vue 2 EOL.\nUpgrading from Vue 2? Check out the Migration Guide.\n\nLearn Vue with video tutorials on VueMastery.com\n\nWhat is Vue?\n​\n\nVue (pronounced /vjuː/, like view) is a JavaScript framework for building user interfaces. It builds on top of standard HTML, CSS, and JavaScript and provides a declarative, component-based programming model that helps you efficiently develop user interfaces of any complexity.\n\nHere is a minimal example:\n\njs\nimport { createApp, ref } from 'vue'\n\ncreateApp({\n  setup() {\n    return {\n      count: ref(0)\n    }\n  }\n}).mount('#app')\ntemplate\n<div id=\"app\">\n  <button @click=\"count++\">\n    Count is: {{ count }}\n  </button>\n</div>\n\nResult\n\nCount is: 0\n\nThe above example demonstrates the two core features of Vue:\n\nDeclarative Rendering: Vue extends standard HTML with a template syntax that allows us to declaratively describe HTML output based on JavaScript state.\n\nReactivity: Vue automatically tracks JavaScript state changes and efficiently updates the DOM when changes happen.\n\nYou may already have questions - don't worry. We will cover every little detail in the rest of the documentation. For now, please read along so you can have a high-level understanding of what Vue offers.\n\nPrerequisites\n\nThe rest of the documentation assumes basic familiarity with HTML, CSS, and JavaScript. If you are totally new to frontend development, it might not be the best idea to jump right into a framework as your first step - grasp the basics and then come back! You can check your knowledge level with these overviews for JavaScript, HTML and CSS if needed. Prior experience with other frameworks helps, but is not required.\n\nThe Progressive Framework\n​\n\nVue is a framework and ecosystem that covers most of the common features needed in frontend development. But the web is extremely diverse - the things we build on the web may vary drastically in form and scale. With that in mind, Vue is designed to be flexible and incrementally adoptable. Depending on your use case, Vue can be used in different ways:\n\nEnhancing static HTML without a build step\nEmbedding as Web Components on any page\nSingle-Page Application (SPA)\nFullstack / Server-Side Rendering (SSR)\nJamstack / Static Site Generation (SSG)\nTargeting desktop, mobile, WebGL, and even the terminal\n\nIf you find these concepts intimidating, don't worry! The tutorial and guide only require basic HTML and JavaScript knowledge, and you should be able to follow along without being an expert in any of these.\n\nIf you are an experienced developer interested in how to best integrate Vue into your stack, or you are curious about what these terms mean, we discuss them in more detail in Ways of Using Vue.\n\nDespite the flexibility, the core knowledge about how Vue works is shared across all these use cases. Even if you are just a beginner now, the knowledge gained along the way will stay useful as you grow to tackle more ambitious goals in the future. If you are a veteran, you can pick the optimal way to leverage Vue based on the problems you are trying to solve, while retaining the same productivity. This is why we call Vue \"The Progressive Framework\": it's a framework that can grow with you and adapt to your needs.\n\nSingle-File Components\n​\n\nIn most build-tool-enabled Vue projects, we author Vue components using an HTML-like file format called Single-File Component (also known as *.vue files, abbreviated as SFC). A Vue SFC, as the name suggests, encapsulates the component's logic (JavaScript), template (HTML), and styles (CSS) in a single file. Here's the previous example, written in SFC format:\n\nvue\n<script setup>\nimport { ref } from 'vue'\nconst count = ref(0)\n</script>\n\n<template>\n  <button @click=\"count++\">Count is: {{ count }}</button>\n</template>\n\n<style scoped>\nbutton {\n  font-weight: bold;\n}\n</style>\n\nSFC is a defining feature of Vue and is the recommended way to author Vue components if your use case warrants a build setup. You can learn more about the how and why of SFC in its dedicated section - but for now, just know that Vue will handle all the build tools setup for you.\n\nAPI Styles\n​\n\nVue components can be authored in two different API styles: Options API and Composition API.\n\nOptions API\n​\n\nWith Options API, we define a component's logic using an object of options such as data, methods, and mounted. Properties defined by options are exposed on this inside functions, which points to the component instance:\n\nvue\n<script>\nexport default {\n  // Properties returned from data() become reactive state\n  // and will be exposed on `this`.\n  data() {\n    return {\n      count: 0\n    }\n  },\n\n  // Methods are functions that mutate state and trigger updates.\n  // They can be bound as event handlers in templates.\n  methods: {\n    increment() {\n      this.count++\n    }\n  },\n\n  // Lifecycle hooks are called at different stages\n  // of a component's lifecycle.\n  // This function will be called when the component is mounted.\n  mounted() {\n    console.log(`The initial count is ${this.count}.`)\n  }\n}\n</script>\n\n<template>\n  <button @click=\"increment\">Count is: {{ count }}</button>\n</template>\n\nTry it in the Playground\n\nComposition API\n​\n\nWith Composition API, we define a component's logic using imported API functions. In SFCs, Composition API is typically used with <script setup>. The setup attribute is a hint that makes Vue perform compile-time transforms that allow us to use Composition API with less boilerplate. For example, imports and top-level variables / functions declared in <script setup> are directly usable in the template.\n\nHere is the same component, with the exact same template, but using Composition API and <script setup> instead:\n\nvue\n<script setup>\nimport { ref, onMounted } from 'vue'\n\n// reactive state\nconst count = ref(0)\n\n// functions that mutate state and trigger updates\nfunction increment() {\n  count.value++\n}\n\n// lifecycle hooks\nonMounted(() => {\n  console.log(`The initial count is ${count.value}.`)\n})\n</script>\n\n<template>\n  <button @click=\"increment\">Count is: {{ count }}</button>\n</template>\n\nTry it in the Playground\n\nWhich to Choose?\n​\n\nBoth API styles are fully capable of covering common use cases. They are different interfaces powered by the exact same underlying system. In fact, the Options API is implemented on top of the Composition API! The fundamental concepts and knowledge about Vue are shared across the two styles.\n\nThe Options API is centered around the concept of a \"component instance\" (this as seen in the example), which typically aligns better with a class-based mental model for users coming from OOP language backgrounds. It is also more beginner-friendly by abstracting away the reactivity details and enforcing code organization via option groups.\n\nThe Composition API is centered around declaring reactive state variables directly in a function scope and composing state from multiple functions together to handle complexity. It is more free-form and requires an understanding of how reactivity works in Vue to be used effectively. In return, its flexibility enables more powerful patterns for organizing and reusing logic.\n\nYou can learn more about the comparison between the two styles and the potential benefits of Composition API in the Composition API FAQ.\n\nIf you are new to Vue, here's our general recommendation:\n\nFor learning purposes, go with the style that looks easier to understand to you. Again, most of the core concepts are shared between the two styles. You can always pick up the other style later.\n\nFor production use:\n\nGo with Options API if you are not using build tools, or plan to use Vue primarily in low-complexity scenarios, e.g. progressive enhancement.\n\nGo with Composition API + Single-File Components if you plan to build full applications with Vue.\n\nYou don't have to commit to only one style during the learning phase. The rest of the documentation will provide code samples in both styles where applicable, and you can toggle between them at any time using the API Preference switches at the top of the left sidebar.\n\nStill Got Questions?\n​\n\nCheck out our FAQ.\n\nPick Your Learning Path\n​\n\nDifferent developers have different learning styles. Feel free to pick a learning path that suits your preference - although we do recommend going over all of the content, if possible!\n\nTry the Tutorial\n\nFor those who prefer learning things hands-on.\n\nRead the Guide\n\nThe guide walks you through every aspect of the framework in full detail.\n\nCheck out the Examples\n\nExplore examples of core features and common UI tasks.\n\nEdit this page on GitHub\n\nIntroduction has loaded"
  },
  {
    "title": "Quick Start | Vue.js",
    "url": "https://vuejs.org/guide/quick-start",
    "html": "Skip to content\nGet 60% off a year of Vue Mastery courses\nGET DISCOUNT\nVue.js\nSearch\nCtrl\nK\nMain Navigation\nDocs\nAPI\nPlayground\nEcosystem\nAbout\nSponsor\nPartners\ngithub\ntwitter\ndiscord\nAPI Preference\nOptions\nComposition\n?\n\nAPI style now defaults to Composition API.\n\nSome pages contain different content based on the API style chosen. Use this switch to toggle between APIs styles.\n\nLearn moreGot it\n\nSidebar Navigation\nGetting Started\n\nIntroduction\n\nQuick Start\n\nEssentials\n\nCreating an Application\n\nTemplate Syntax\n\nReactivity Fundamentals\n\nComputed Properties\n\nClass and Style Bindings\n\nConditional Rendering\n\nList Rendering\n\nEvent Handling\n\nForm Input Bindings\n\nLifecycle Hooks\n\nWatchers\n\nTemplate Refs\n\nComponents Basics\n\nComponents In-Depth\n\nRegistration\n\nProps\n\nEvents\n\nComponent v-model\n\nFallthrough Attributes\n\nSlots\n\nProvide / inject\n\nAsync Components\n\nReusability\n\nComposables\n\nCustom Directives\n\nPlugins\n\nBuilt-in Components\n\nTransition\n\nTransitionGroup\n\nKeepAlive\n\nTeleport\n\nSuspense\n\nScaling Up\n\nSingle-File Components\n\nTooling\n\nRouting\n\nState Management\n\nTesting\n\nServer-Side Rendering (SSR)\n\nBest Practices\n\nProduction Deployment\n\nPerformance\n\nAccessibility\n\nSecurity\n\nTypeScript\n\nOverview\n\nTS with Composition API\n\nTS with Options API\n\nExtra Topics\n\nWays of Using Vue\n\nComposition API FAQ\n\nReactivity in Depth\n\nRendering Mechanism\n\nRender Functions & JSX\n\nVue and Web Components\n\nAnimation Techniques\n\nON THIS PAGE\nTable of Contents for current page\nTry Vue Online\nCreating a Vue Application\nUsing Vue from CDN\nNext Steps\nSPONSORS\nBecome a Sponsor\nSee what your team could do with The DevSecOps Platform. Take GitLab for a spin.\nADS VIA CARBON\nQuick Start\n​\nTry Vue Online\n​\n\nTo quickly get a taste of Vue, you can try it directly in our Playground.\n\nIf you prefer a plain HTML setup without any build steps, you can use this JSFiddle as your starting point.\n\nIf you are already familiar with Node.js and the concept of build tools, you can also try a complete build setup right within your browser on StackBlitz.\n\nCreating a Vue Application\n​\n\nPrerequisites\n\nFamiliarity with the command line\nInstall Node.js version 18.3 or higher\n\nIn this section we will introduce how to scaffold a Vue Single Page Application on your local machine. The created project will be using a build setup based on Vite and allow us to use Vue Single-File Components (SFCs).\n\nMake sure you have an up-to-date version of Node.js installed and your current working directory is the one where you intend to create a project. Run the following command in your command line (without the $ sign):\n\nnpm\npnpm\nyarn\nbun\nsh\n$ npm create vue@latest\n\nThis command will install and execute create-vue, the official Vue project scaffolding tool. You will be presented with prompts for several optional features such as TypeScript and testing support:\n\n✔ Project name: … <your-project-name>\n✔ Add TypeScript? … No / Yes\n✔ Add JSX Support? … No / Yes\n✔ Add Vue Router for Single Page Application development? … No / Yes\n✔ Add Pinia for state management? … No / Yes\n✔ Add Vitest for Unit testing? … No / Yes\n✔ Add an End-to-End Testing Solution? … No / Cypress / Nightwatch / Playwright\n✔ Add ESLint for code quality? … No / Yes\n✔ Add Prettier for code formatting? … No / Yes\n✔ Add Vue DevTools 7 extension for debugging? (experimental) … No / Yes\n\nScaffolding project in ./<your-project-name>...\nDone.\n\nIf you are unsure about an option, simply choose No by hitting enter for now. Once the project is created, follow the instructions to install dependencies and start the dev server:\n\nnpm\npnpm\nyarn\nbun\nsh\n$ cd <your-project-name>\n$ npm install\n$ npm run dev\n\nYou should now have your first Vue project running! Note that the example components in the generated project are written using the Composition API and <script setup>, rather than the Options API. Here are some additional tips:\n\nThe recommended IDE setup is Visual Studio Code + Vue - Official extension. If you use other editors, check out the IDE support section.\nMore tooling details, including integration with backend frameworks, are discussed in the Tooling Guide.\nTo learn more about the underlying build tool Vite, check out the Vite docs.\nIf you choose to use TypeScript, check out the TypeScript Usage Guide.\n\nWhen you are ready to ship your app to production, run the following:\n\nnpm\npnpm\nyarn\nbun\nsh\n$ npm run build\n\nThis will create a production-ready build of your app in the project's ./dist directory. Check out the Production Deployment Guide to learn more about shipping your app to production.\n\nNext Steps >\n\nUsing Vue from CDN\n​\n\nYou can use Vue directly from a CDN via a script tag:\n\nhtml\n<script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script>\n\nHere we are using unpkg, but you can also use any CDN that serves npm packages, for example jsdelivr or cdnjs. Of course, you can also download this file and serve it yourself.\n\nWhen using Vue from a CDN, there is no \"build step\" involved. This makes the setup a lot simpler, and is suitable for enhancing static HTML or integrating with a backend framework. However, you won't be able to use the Single-File Component (SFC) syntax.\n\nUsing the Global Build\n​\n\nThe above link loads the global build of Vue, where all top-level APIs are exposed as properties on the global Vue object. Here is a full example using the global build:\n\nhtml\n<script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script>\n\n<div id=\"app\">{{ message }}</div>\n\n<script>\n  const { createApp, ref } = Vue\n\n  createApp({\n    setup() {\n      const message = ref('Hello vue!')\n      return {\n        message\n      }\n    }\n  }).mount('#app')\n</script>\n\nCodePen Demo >\n\nTIP\n\nMany of the examples for Composition API throughout the guide will be using the <script setup> syntax, which requires build tools. If you intend to use Composition API without a build step, consult the usage of the setup() option.\n\nUsing the ES Module Build\n​\n\nThroughout the rest of the documentation, we will be primarily using ES modules syntax. Most modern browsers now support ES modules natively, so we can use Vue from a CDN via native ES modules like this:\n\nhtml\n<div id=\"app\">{{ message }}</div>\n\n<script type=\"module\">\n  import { createApp, ref } from 'https://unpkg.com/vue@3/dist/vue.esm-browser.js'\n\n  createApp({\n    setup() {\n      const message = ref('Hello Vue!')\n      return {\n        message\n      }\n    }\n  }).mount('#app')\n</script>\n\nNotice that we are using <script type=\"module\">, and the imported CDN URL is pointing to the ES modules build of Vue instead.\n\nCodePen Demo >\n\nEnabling Import maps\n​\n\nIn the above example, we are importing from the full CDN URL, but in the rest of the documentation you will see code like this:\n\njs\nimport { createApp } from 'vue'\n\nWe can teach the browser where to locate the vue import by using Import Maps:\n\nhtml\n<script type=\"importmap\">\n  {\n    \"imports\": {\n      \"vue\": \"https://unpkg.com/vue@3/dist/vue.esm-browser.js\"\n    }\n  }\n</script>\n\n<div id=\"app\">{{ message }}</div>\n\n<script type=\"module\">\n  import { createApp, ref } from 'vue'\n\n  createApp({\n    setup() {\n      const message = ref('Hello Vue!')\n      return {\n        message\n      }\n    }\n  }).mount('#app')\n</script>\n\nCodePen Demo >\n\nYou can also add entries for other dependencies to the import map - but make sure they point to the ES modules version of the library you intend to use.\n\nImport Maps Browser Support\n\nImport Maps is a relatively new browser feature. Make sure to use a browser within its support range. In particular, it is only supported in Safari 16.4+.\n\nNotes on Production Use\n\nThe examples so far are using the development build of Vue - if you intend to use Vue from a CDN in production, make sure to check out the Production Deployment Guide.\n\nWhile it is possible to use Vue without a build system, an alternative approach to consider is using vuejs/petite-vue that could better suit the context where jquery/jquery (in the past) or alpinejs/alpine (in the present) might be used instead.\n\nSplitting Up the Modules\n​\n\nAs we dive deeper into the guide, we may need to split our code into separate JavaScript files so that they are easier to manage. For example:\n\nhtml\n<!-- index.html -->\n<div id=\"app\"></div>\n\n<script type=\"module\">\n  import { createApp } from 'vue'\n  import MyComponent from './my-component.js'\n\n  createApp(MyComponent).mount('#app')\n</script>\njs\n// my-component.js\nimport { ref } from 'vue'\nexport default {\n  setup() {\n    const count = ref(0)\n    return { count }\n  },\n  template: `<div>Count is: {{ count }}</div>`\n}\n\nIf you directly open the above index.html in your browser, you will find that it throws an error because ES modules cannot work over the file:// protocol, which is the protocol the browser uses when you open a local file.\n\nDue to security reasons, ES modules can only work over the http:// protocol, which is what the browsers use when opening pages on the web. In order for ES modules to work on our local machine, we need to serve the index.html over the http:// protocol, with a local HTTP server.\n\nTo start a local HTTP server, first make sure you have Node.js installed, then run npx serve from the command line in the same directory where your HTML file is. You can also use any other HTTP server that can serve static files with the correct MIME types.\n\nYou may have noticed that the imported component's template is inlined as a JavaScript string. If you are using VS Code, you can install the es6-string-html extension and prefix the strings with a /*html*/ comment to get syntax highlighting for them.\n\nNext Steps\n​\n\nIf you skipped the Introduction, we strongly recommend reading it before moving on to the rest of the documentation.\n\nContinue with the Guide\n\nThe guide walks you through every aspect of the framework in full detail.\n\nTry the Tutorial\n\nFor those who prefer learning things hands-on.\n\nCheck out the Examples\n\nExplore examples of core features and common UI tasks.\n\nEdit this page on GitHub\n\nQuick Start has loaded"
  },
  {
    "title": "Introduction | Vue.js",
    "url": "https://vuejs.org/guide/introduction.html",
    "html": "Skip to content\nGet 60% off a year of Vue Mastery courses\nGET DISCOUNT\nVue.js\nSearch\nCtrl\nK\nMain Navigation\nDocs\nAPI\nPlayground\nEcosystem\nAbout\nSponsor\nPartners\ngithub\ntwitter\ndiscord\nAPI Preference\nOptions\nComposition\n?\n\nAPI style now defaults to Composition API.\n\nSome pages contain different content based on the API style chosen. Use this switch to toggle between APIs styles.\n\nLearn moreGot it\n\nSidebar Navigation\nGetting Started\n\nIntroduction\n\nQuick Start\n\nEssentials\n\nCreating an Application\n\nTemplate Syntax\n\nReactivity Fundamentals\n\nComputed Properties\n\nClass and Style Bindings\n\nConditional Rendering\n\nList Rendering\n\nEvent Handling\n\nForm Input Bindings\n\nLifecycle Hooks\n\nWatchers\n\nTemplate Refs\n\nComponents Basics\n\nComponents In-Depth\n\nRegistration\n\nProps\n\nEvents\n\nComponent v-model\n\nFallthrough Attributes\n\nSlots\n\nProvide / inject\n\nAsync Components\n\nReusability\n\nComposables\n\nCustom Directives\n\nPlugins\n\nBuilt-in Components\n\nTransition\n\nTransitionGroup\n\nKeepAlive\n\nTeleport\n\nSuspense\n\nScaling Up\n\nSingle-File Components\n\nTooling\n\nRouting\n\nState Management\n\nTesting\n\nServer-Side Rendering (SSR)\n\nBest Practices\n\nProduction Deployment\n\nPerformance\n\nAccessibility\n\nSecurity\n\nTypeScript\n\nOverview\n\nTS with Composition API\n\nTS with Options API\n\nExtra Topics\n\nWays of Using Vue\n\nComposition API FAQ\n\nReactivity in Depth\n\nRendering Mechanism\n\nRender Functions & JSX\n\nVue and Web Components\n\nAnimation Techniques\n\nON THIS PAGE\nTable of Contents for current page\nWhat is Vue?\nThe Progressive Framework\nSingle-File Components\nAPI Styles\nStill Got Questions?\nPick Your Learning Path\nSPONSORS\nBecome a Sponsor\nIntroduction\n​\n\nYou are reading the documentation for Vue 3!\n\nVue 2 support has ended on Dec 31, 2023. Learn more about Vue 2 EOL.\nUpgrading from Vue 2? Check out the Migration Guide.\n\nLearn Vue with video tutorials on VueMastery.com\n\nWhat is Vue?\n​\n\nVue (pronounced /vjuː/, like view) is a JavaScript framework for building user interfaces. It builds on top of standard HTML, CSS, and JavaScript and provides a declarative, component-based programming model that helps you efficiently develop user interfaces of any complexity.\n\nHere is a minimal example:\n\njs\nimport { createApp, ref } from 'vue'\n\ncreateApp({\n  setup() {\n    return {\n      count: ref(0)\n    }\n  }\n}).mount('#app')\ntemplate\n<div id=\"app\">\n  <button @click=\"count++\">\n    Count is: {{ count }}\n  </button>\n</div>\n\nResult\n\nCount is: 0\n\nThe above example demonstrates the two core features of Vue:\n\nDeclarative Rendering: Vue extends standard HTML with a template syntax that allows us to declaratively describe HTML output based on JavaScript state.\n\nReactivity: Vue automatically tracks JavaScript state changes and efficiently updates the DOM when changes happen.\n\nYou may already have questions - don't worry. We will cover every little detail in the rest of the documentation. For now, please read along so you can have a high-level understanding of what Vue offers.\n\nPrerequisites\n\nThe rest of the documentation assumes basic familiarity with HTML, CSS, and JavaScript. If you are totally new to frontend development, it might not be the best idea to jump right into a framework as your first step - grasp the basics and then come back! You can check your knowledge level with these overviews for JavaScript, HTML and CSS if needed. Prior experience with other frameworks helps, but is not required.\n\nThe Progressive Framework\n​\n\nVue is a framework and ecosystem that covers most of the common features needed in frontend development. But the web is extremely diverse - the things we build on the web may vary drastically in form and scale. With that in mind, Vue is designed to be flexible and incrementally adoptable. Depending on your use case, Vue can be used in different ways:\n\nEnhancing static HTML without a build step\nEmbedding as Web Components on any page\nSingle-Page Application (SPA)\nFullstack / Server-Side Rendering (SSR)\nJamstack / Static Site Generation (SSG)\nTargeting desktop, mobile, WebGL, and even the terminal\n\nIf you find these concepts intimidating, don't worry! The tutorial and guide only require basic HTML and JavaScript knowledge, and you should be able to follow along without being an expert in any of these.\n\nIf you are an experienced developer interested in how to best integrate Vue into your stack, or you are curious about what these terms mean, we discuss them in more detail in Ways of Using Vue.\n\nDespite the flexibility, the core knowledge about how Vue works is shared across all these use cases. Even if you are just a beginner now, the knowledge gained along the way will stay useful as you grow to tackle more ambitious goals in the future. If you are a veteran, you can pick the optimal way to leverage Vue based on the problems you are trying to solve, while retaining the same productivity. This is why we call Vue \"The Progressive Framework\": it's a framework that can grow with you and adapt to your needs.\n\nSingle-File Components\n​\n\nIn most build-tool-enabled Vue projects, we author Vue components using an HTML-like file format called Single-File Component (also known as *.vue files, abbreviated as SFC). A Vue SFC, as the name suggests, encapsulates the component's logic (JavaScript), template (HTML), and styles (CSS) in a single file. Here's the previous example, written in SFC format:\n\nvue\n<script setup>\nimport { ref } from 'vue'\nconst count = ref(0)\n</script>\n\n<template>\n  <button @click=\"count++\">Count is: {{ count }}</button>\n</template>\n\n<style scoped>\nbutton {\n  font-weight: bold;\n}\n</style>\n\nSFC is a defining feature of Vue and is the recommended way to author Vue components if your use case warrants a build setup. You can learn more about the how and why of SFC in its dedicated section - but for now, just know that Vue will handle all the build tools setup for you.\n\nAPI Styles\n​\n\nVue components can be authored in two different API styles: Options API and Composition API.\n\nOptions API\n​\n\nWith Options API, we define a component's logic using an object of options such as data, methods, and mounted. Properties defined by options are exposed on this inside functions, which points to the component instance:\n\nvue\n<script>\nexport default {\n  // Properties returned from data() become reactive state\n  // and will be exposed on `this`.\n  data() {\n    return {\n      count: 0\n    }\n  },\n\n  // Methods are functions that mutate state and trigger updates.\n  // They can be bound as event handlers in templates.\n  methods: {\n    increment() {\n      this.count++\n    }\n  },\n\n  // Lifecycle hooks are called at different stages\n  // of a component's lifecycle.\n  // This function will be called when the component is mounted.\n  mounted() {\n    console.log(`The initial count is ${this.count}.`)\n  }\n}\n</script>\n\n<template>\n  <button @click=\"increment\">Count is: {{ count }}</button>\n</template>\n\nTry it in the Playground\n\nComposition API\n​\n\nWith Composition API, we define a component's logic using imported API functions. In SFCs, Composition API is typically used with <script setup>. The setup attribute is a hint that makes Vue perform compile-time transforms that allow us to use Composition API with less boilerplate. For example, imports and top-level variables / functions declared in <script setup> are directly usable in the template.\n\nHere is the same component, with the exact same template, but using Composition API and <script setup> instead:\n\nvue\n<script setup>\nimport { ref, onMounted } from 'vue'\n\n// reactive state\nconst count = ref(0)\n\n// functions that mutate state and trigger updates\nfunction increment() {\n  count.value++\n}\n\n// lifecycle hooks\nonMounted(() => {\n  console.log(`The initial count is ${count.value}.`)\n})\n</script>\n\n<template>\n  <button @click=\"increment\">Count is: {{ count }}</button>\n</template>\n\nTry it in the Playground\n\nWhich to Choose?\n​\n\nBoth API styles are fully capable of covering common use cases. They are different interfaces powered by the exact same underlying system. In fact, the Options API is implemented on top of the Composition API! The fundamental concepts and knowledge about Vue are shared across the two styles.\n\nThe Options API is centered around the concept of a \"component instance\" (this as seen in the example), which typically aligns better with a class-based mental model for users coming from OOP language backgrounds. It is also more beginner-friendly by abstracting away the reactivity details and enforcing code organization via option groups.\n\nThe Composition API is centered around declaring reactive state variables directly in a function scope and composing state from multiple functions together to handle complexity. It is more free-form and requires an understanding of how reactivity works in Vue to be used effectively. In return, its flexibility enables more powerful patterns for organizing and reusing logic.\n\nYou can learn more about the comparison between the two styles and the potential benefits of Composition API in the Composition API FAQ.\n\nIf you are new to Vue, here's our general recommendation:\n\nFor learning purposes, go with the style that looks easier to understand to you. Again, most of the core concepts are shared between the two styles. You can always pick up the other style later.\n\nFor production use:\n\nGo with Options API if you are not using build tools, or plan to use Vue primarily in low-complexity scenarios, e.g. progressive enhancement.\n\nGo with Composition API + Single-File Components if you plan to build full applications with Vue.\n\nYou don't have to commit to only one style during the learning phase. The rest of the documentation will provide code samples in both styles where applicable, and you can toggle between them at any time using the API Preference switches at the top of the left sidebar.\n\nStill Got Questions?\n​\n\nCheck out our FAQ.\n\nPick Your Learning Path\n​\n\nDifferent developers have different learning styles. Feel free to pick a learning path that suits your preference - although we do recommend going over all of the content, if possible!\n\nTry the Tutorial\n\nFor those who prefer learning things hands-on.\n\nRead the Guide\n\nThe guide walks you through every aspect of the framework in full detail.\n\nCheck out the Examples\n\nExplore examples of core features and common UI tasks.\n\nEdit this page on GitHub\n\nIntroduction has loaded"
  }
]