[
  {
    "title": "pre-commit hooks | 1.7 | Documentation | Poetry - Python dependency management and packaging made easy",
    "url": "https://python-poetry.org/docs/1.7/pre-commit-hooks/",
    "html": "Home\nSearch\n1.7\nUse dark mode\nDOCUMENTATION\nBLOG\nHISTORY\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\npoetry-check\nArguments\npoetry-lock\nArguments\npoetry-export\nArguments\npoetry-install\nArguments\nUsage\nFAQ\nWhy does pre-commit autoupdate not update to the latest version?\npre-commit hooks\n\npre-commit is a framework for building and running git hooks. See the official documentation for more information: pre-commit.com\n\nThis document provides a list of available pre-commit hooks provided by Poetry.\n\nIf you specify the args: for a hook in your .pre-commit-config.yaml, the defaults are overwritten. You must fully specify all arguments for your hook if you make use of args:.\nIf the pyproject.toml file is not in the root directory, you can specify args: [\"-C\", \"./subdirectory\"].\npoetry-check\n\nThe poetry-check hook calls the poetry check command to make sure the poetry configuration does not get committed in a broken state.\n\nArguments\n\nThe hook takes the same arguments as the poetry command. For more information see the check command.\n\npoetry-lock\n\nThe poetry-lock hook calls the poetry lock command to make sure the lock file is up-to-date when committing changes.\n\nArguments\n\nThe hook takes the same arguments as the poetry command. For more information see the lock command.\n\npoetry-export\n\nThe poetry-export hook calls the poetry export command to sync your requirements.txt file with your current dependencies.\n\nThis hook is provided by the Export Poetry Plugin.\nIt is recommended to run the poetry-lock hook prior to this one.\nArguments\n\nThe hook takes the same arguments as the poetry command. For more information see the export command.\n\nThe default arguments are args: [\"-f\", \"requirements.txt\", \"-o\", \"requirements.txt\"], which will create/update the requirements.txt file in the current working directory.\n\nYou may add verbose: true in your .pre-commit-config.yaml in order to output to the console:\n\nhooks:\n-   id: poetry-export\n    args: [\"-f\", \"requirements.txt\"]\n    verbose: true\n\n\nAlso, --dev can be added to args to write dev-dependencies to requirements.txt:\n\nhooks:\n-   id: poetry-export\n    args: [\"--dev\", \"-f\", \"requirements.txt\", \"-o\", \"requirements.txt\"]\n\npoetry-install\n\nThe poetry-install hook calls the poetry install command to make sure all locked packages are installed. In order to install this hook, you either need to specify default_install_hook_types, or you have to install it via pre-commit install --install-hooks -t post-checkout -t post-merge.\n\nArguments\n\nThe hook takes the same arguments as the poetry command. For more information see the install command.\n\nUsage\n\nFor more information on how to use pre-commit please see the official documentation.\n\nA minimalistic .pre-commit-config.yaml example:\n\nrepos:\n-   repo: https://github.com/python-poetry/poetry\n    rev: ''  # add version here\n    hooks:\n    -   id: poetry-check\n    -   id: poetry-lock\n    -   id: poetry-export\n    -   id: poetry-install\n\n\nA .pre-commit-config.yaml example for a monorepo setup or if the pyproject.toml file is not in the root directory:\n\nrepos:\n-   repo: https://github.com/python-poetry/poetry\n    rev: ''  # add version here\n    hooks:\n    -   id: poetry-check\n        args: [\"-C\", \"./subdirectory\"]\n    -   id: poetry-lock\n        args: [\"-C\", \"./subdirectory\"]\n    -   id: poetry-export\n        args: [\"-C\", \"./subdirectory\", \"-f\", \"requirements.txt\", \"-o\", \"./subdirectory/requirements.txt\"]\n    -   id: poetry-install\n        args: [\"-C\", \"./subdirectory\"]\n\nFAQ\nWhy does pre-commit autoupdate not update to the latest version?\n\npre-commit autoupdate updates the rev for each repository defined in your .pre-commit-config.yaml to the latest available tag in the default branch.\n\nPoetry follows a branching strategy where the default branch is the active development branch, and fixes get backported to stable branches. New tags are assigned in these stable branches.\n\npre-commit does not support such a branching strategy and has decided to not implement an option, either on the user’s side or the hook author’s side, to define a branch for looking up the latest available tag.\n\nThus, pre-commit autoupdate is not usable for the hooks described here.\n\nYou can avoid changing the rev to an unexpected value by using the --repo parameter (may be specified multiple times), to explicitly list repositories that should be updated. An option to explicitly exclude repositories will not be implemented into pre-commit.\n\nFooter\n\nPython packaging and dependency management made easy.\n\nGitHub\nDiscord\nDOCUMENTATION\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\n GITHUB\nProject\nIssues\nDiscussions\nOTHER PROJECTS\npoetry-core\ninstall.python-poetry.org\nBundle plugin\nExport plugin\n\nCopyright © 2018-2024. All Rights Reserved.\nPowered by"
  },
  {
    "title": "FAQ | 1.7 | Documentation | Poetry - Python dependency management and packaging made easy",
    "url": "https://python-poetry.org/docs/1.7/faq/",
    "html": "Home\nSearch\n1.7\nUse dark mode\nDOCUMENTATION\nBLOG\nHISTORY\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\nWhy is the dependency resolution process slow?\nWhat kind of versioning scheme does Poetry use for itself?\nWhy does Poetry not adhere to semantic versioning?\nAre unbound version constraints a bad idea?\nIs tox supported?\nIs Nox supported?\nI don’t want Poetry to manage my virtual environments. Can I disable it?\nWhy is Poetry telling me that the current project’s supported Python range is not compatible with one or more packages' Python requirements?\nWhy does Poetry enforce PEP 440 versions?\nPoetry busts my Docker cache because it requires me to COPY my source files in before installing 3rd party dependencies\nMy requests are timing out!\npre-commit hooks\nFAQ\nWhy is the dependency resolution process slow?\n\nWhile the dependency resolver at the heart of Poetry is highly optimized and should be fast enough for most cases, with certain sets of dependencies it can take time to find a valid solution.\n\nThis is due to the fact that not all libraries on PyPI have properly declared their metadata and, as such, they are not available via the PyPI JSON API. At this point, Poetry has no choice but to download the packages and inspect them to get the necessary information. This is an expensive operation, both in bandwidth and time, which is why it seems this is a long process.\n\nAt the moment there is no way around it. However, if you notice that Poetry is downloading many versions of a single package, you can lessen the workload by constraining that one package in your pyproject.toml more narrowly. That way Poetry does not have to sift through so many versions of it, which may speed up the locking process considerably in some cases.\n\nOnce Poetry has cached the releases' information on your machine, the dependency resolution process will be much faster.\nWhat kind of versioning scheme does Poetry use for itself?\n\nPoetry uses “major.minor.micro” version identifiers as mentioned in PEP 440.\n\nVersion bumps are done similar to Python’s versioning:\n\nA major version bump (incrementing the first number) is only done for breaking changes if a deprecation cycle is not possible and many users have to perform some manual steps to migrate from one version to the next one.\nA minor version bump (incrementing the second number) may include new features as well as new deprecations and drop features deprecated in an earlier minor release.\nA micro version bump (incrementing the third number) usually only includes bug fixes. Deprecated features will not be dropped in a micro release.\nWhy does Poetry not adhere to semantic versioning?\n\nBecause of its large user base, even small changes not considered relevant by most users can turn out to be a breaking change for some users in hindsight. Sticking to strict semantic versioning and (almost) always bumping the major version instead of the minor version does not seem desirable since the minor version will not carry any meaning anymore.\n\nAre unbound version constraints a bad idea?\n\nA version constraint without an upper bound such as * or >=3.4 will allow updates to any future version of the dependency. This includes major versions breaking backward compatibility.\n\nOnce a release of your package is published, you cannot tweak its dependencies anymore in case a dependency breaks BC – you have to do a new release but the previous one stays broken. (Users can still work around the broken dependency by restricting it by themselves.)\n\nTo avoid such issues you can define an upper bound on your constraints, which you can increase in a new release after testing that your package is compatible with the new major version of your dependency.\n\nFor example instead of using >=3.4 you can use ^3.4 which allows all versions <4.0. The ^ operator works very well with libraries following semantic versioning.\n\nHowever, when defining an upper bound, users of your package are not able to update a dependency beyond the upper bound even if it does not break anything and is fully compatible with your package. You have to release a new version of your package with an increased upper bound first.\n\nIf your package will be used as a library in other packages, it might be better to avoid upper bounds and thus unnecessary dependency conflicts (unless you already know for sure that the next release of the dependency will break your package). If your package will be used as an application, it might be worth to define an upper bound.\n\nIs tox supported?\n\nYes. By using the isolated builds tox provides, you can use it in combination with the PEP 517 compliant build system provided by Poetry.\n\nSo, in your pyproject.toml file, add this section if it does not already exist:\n\n[build-system]\nrequires = [\"poetry-core>=1.0.0\"]\nbuild-backend = \"poetry.core.masonry.api\"\n\n\ntox can be configured in multiple ways. It depends on what should be the code under test and which dependencies should be installed.\n\nUsecase #1\n[tox]\nisolated_build = true\n\n[testenv]\ndeps =\n    pytest\ncommands =\n    pytest tests/ --import-mode importlib\n\n\ntox will create an sdist package of the project and uses pip to install it in a fresh environment. Thus, dependencies are resolved by pip.\n\nUsecase #2\n[tox]\nisolated_build = true\n\n[testenv]\nallowlist_externals = poetry\ncommands_pre =\n    poetry install --no-root --sync\ncommands =\n    poetry run pytest tests/ --import-mode importlib\n\n\ntox will create an sdist package of the project and uses pip to install it in a fresh environment. Thus, dependencies are resolved by pip in the first place. But afterwards we run Poetry, which will install the locked dependencies into the environment.\n\nUsecase #3\n[tox]\nisolated_build = true\n\n[testenv]\nskip_install = true\nallowlist_externals = poetry\ncommands_pre =\n    poetry install\ncommands =\n    poetry run pytest tests/ --import-mode importlib\n\n\ntox will not do any install. Poetry installs all the dependencies and the current package in editable mode. Thus, tests are running against the local files and not the built and installed package.\n\nIs Nox supported?\n\nUse the nox-poetry package to install locked versions of dependencies specified in poetry.lock into Nox sessions.\n\nI don’t want Poetry to manage my virtual environments. Can I disable it?\n\nWhile Poetry automatically creates virtual environments to always work isolated from the global Python installation, there are valid reasons why it’s not necessary and is an overhead, like when working with containers.\n\nIn this case, you can disable this feature by setting the virtualenvs.create setting to false:\n\npoetry config virtualenvs.create false\n\nWhy is Poetry telling me that the current project’s supported Python range is not compatible with one or more packages' Python requirements?\n\nUnlike pip, Poetry doesn’t resolve for just the Python in the current environment. Instead it makes sure that a dependency is resolvable within the given Python version range in pyproject.toml.\n\nAssume you have the following pyproject.toml:\n\n[tool.poetry.dependencies]\npython = \"^3.7\"\n\n\nThis means your project aims to be compatible with any Python version >=3.7,<4.0. Whenever you try to add a dependency whose Python requirement doesn’t match the whole range Poetry will tell you this, e.g.:\n\nThe current project's supported Python range (>=3.7.0,<4.0.0) is not compatible with some of the required packages Python requirement:\n    - scipy requires Python >=3.7,<3.11, so it will not be satisfied for Python >=3.11,<4.0.0\n\n\nUsually you will want to match the supported Python range of your project with the upper bound of the failing dependency. Alternatively you can tell Poetry to install this dependency only for a specific range of Python versions, if you know that it’s not needed in all versions.\n\nWhy does Poetry enforce PEP 440 versions?\n\nThis is done to be compliant with the broader Python ecosystem.\n\nFor example, if Poetry builds a distribution for a project that uses a version that is not valid according to PEP 440, third party tools will be unable to parse the version correctly.\n\nPoetry busts my Docker cache because it requires me to COPY my source files in before installing 3rd party dependencies\n\nBy default running poetry install ... requires you to have your source files present (both the “root” package and any directory path dependencies you might have). This interacts poorly with Docker’s caching mechanisms because any change to a source file will make any layers (subsequent commands in your Dockerfile) re-run. For example, you might have a Dockerfile that looks something like this:\n\nFROM python\nCOPY pyproject.toml poetry.lock .\nCOPY src/ ./src\nRUN pip install poetry && poetry install --no-dev\n\n\nAs soon as any source file changes, the cache for the RUN layer will be invalidated, which forces all 3rd party dependencies (likely the slowest step out of these) to be installed again if you changed any files in src/.\n\nTo avoid this cache busting you can split this into two steps:\n\nInstall 3rd party dependencies.\nCopy over your source code and install just the source code.\n\nThis might look something like this:\n\nFROM python\nCOPY pyproject.toml poetry.lock .\nRUN pip install poetry && poetry install --no-root --no-directory\nCOPY src/ ./src\nRUN poetry install --no-dev\n\n\nThe two key options we are using here are --no-root (skips installing the project source) and --no-directory (skips installing any local directory path dependencies, you can omit this if you don’t have any). More information on the options available for poetry install.\n\nMy requests are timing out!\n\nPoetry’s default HTTP request timeout is 15 seconds, the same as pip. Similar to PIP_REQUESTS_TIMEOUT, the experimental environment variable POETRY_REQUESTS_TIMEOUT can be set to alter this value.\n\nFooter\n\nPython packaging and dependency management made easy.\n\nGitHub\nDiscord\nDOCUMENTATION\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\n GITHUB\nProject\nIssues\nDiscussions\nOTHER PROJECTS\npoetry-core\ninstall.python-poetry.org\nBundle plugin\nExport plugin\n\nCopyright © 2018-2024. All Rights Reserved.\nPowered by"
  },
  {
    "title": "Community | 1.7 | Documentation | Poetry - Python dependency management and packaging made easy",
    "url": "https://python-poetry.org/docs/1.7/community/",
    "html": "Home\nSearch\n1.7\nUse dark mode\nDOCUMENTATION\nBLOG\nHISTORY\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nBadge\nFAQ\npre-commit hooks\nCommunity\nBadge\n\nFor any projects using Poetry, you may add its official badge somewhere prominent like the README.\n\nMarkdown\n\n[![Poetry](https://img.shields.io/endpoint?url=https://python-poetry.org/badge/v0.json)](https://python-poetry.org/)\n\n\nreStructuredText\n\n.. image:: https://img.shields.io/endpoint?url=https://python-poetry.org/badge/v0.json\n   :alt: Poetry\n   :target: https://python-poetry.org/\n\nFooter\n\nPython packaging and dependency management made easy.\n\nGitHub\nDiscord\nDOCUMENTATION\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\n GITHUB\nProject\nIssues\nDiscussions\nOTHER PROJECTS\npoetry-core\ninstall.python-poetry.org\nBundle plugin\nExport plugin\n\nCopyright © 2018-2024. All Rights Reserved.\nPowered by"
  },
  {
    "title": "Contributing to Poetry | 1.7 | Documentation | Poetry - Python dependency management and packaging made easy",
    "url": "https://python-poetry.org/docs/1.7/contributing/",
    "html": "Home\nSearch\n1.7\nUse dark mode\nDOCUMENTATION\nBLOG\nHISTORY\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nHow to contribute\nReporting bugs\nSuggesting enhancements\nDocumentation contributions\nCode contributions\nIssue triage\nCommunity\nFAQ\npre-commit hooks\nContributing to Poetry\n\nFirst off, thanks for taking the time to contribute!\n\nThe following is a set of guidelines for contributing to Poetry on GitHub. These are mostly guidelines, not rules. Use your best judgement, and feel free to propose changes to this document in a pull request.\n\nHow to contribute\nReporting bugs\n\nThis section guides you through submitting a bug report for Poetry. Following these guidelines helps maintainers and the community understand your report, reproduce the behavior, and find related reports.\n\nBefore submitting a bug report\nCheck the FAQ for a list of common questions and problems.\nCheck the blog for release notes from recent releases, including steps for upgrading and known issues.\nCheck that your issue does not already exist in the issue tracker.\nMake sure your issue is really a bug, and is not a support request or question better suited for Discussions or Discord.\nIf you find a Closed issue that seems like it is the same thing that you’re experiencing, open a new issue and include a link to the original issue in the body of your new one.\nHow do I submit a bug report?\n\nBugs concerning Poetry and poetry-core should be submitted to the main issue tracker, using the correct issue template.\n\nExplain the problem and make it easy for others to search for and understand:\n\nUse a clear and descriptive title for the issue to identify the problem.\nDescribe the exact steps which reproduce the problem in as many details as possible.\nDescribe the behavior you observed after following the steps and point out how this is a bug.\nExplain which behavior you expected to see instead and why.\nIf the problem involves an unexpected error being raised, execute the problematic command in debug mode (with -vvv flag).\n\nProvide detailed steps for reproduction of your issue:\n\nProvide your pyproject.toml file in a Gist, pastebin, or example repository after removing potential private information like private package repositories or names.\nProvide specific examples to demonstrate the steps to reproduce the issue. This could be an example repository, a sequence of steps run in a container, or just a pyproject.toml for very simple cases.\nAre you unable to reliably reproduce the issue? If so, provide details about how often the problem happens and under which conditions it normally happens.\n\nProvide more context by answering these questions:\n\nDid the problem start happening recently (e.g. after updating to a new version of Poetry) or was this always a problem?\nIf the problem started happening recently, can you reproduce the problem in an older version of Poetry? What’s the most recent version in which the problem does not happen?\nIs there anything exotic or unusual about your environment? This could include use of special container images, newer CPU architectures like Apple Silicon, or corporate proxies that intercept or modify your network traffic.\n\nInclude details about your configuration and environment:\n\nWhich version of Poetry are you using? You can get the exact version by running poetry --version.\nWhat version of Python is being used to run Poetry? Execute the poetry debug info to get this information.\nWhat’s the name and version of the OS you’re using? Examples include Ubuntu 22.04 or macOS 12.6.\n\nTo give others the best chance to understand and reproduce your issue, please be sure to put extra effort into your reproduction steps. You can both rule out local configuration issues on your end, and ensure others can cleanly reproduce your issue if attempt all reproductions in a pristine container (or VM), and provide the steps you performed inside that container/VM in your issue report.\n\nSuggesting enhancements\n\nThis section guides you through submitting an enhancement suggestion for Poetry, including completely new features as well as improvements to existing functionality. Following these guidelines helps maintainers and the community understand your suggestion and find related suggestions.\n\nBefore submitting a suggested enhancement\nCheck the FAQ for a list of common questions and problems.\nCheck that your issue does not already exist in the issue tracker.\nHow do I submit a suggested enhancement?\n\nSuggested enhancements concerning Poetry and poetry-core should be submitted to the main issue tracker, using the correct issue template.\n\nUse a clear and descriptive title for the issue to identify the suggestion.\nProvide a detailed description of the proposed enhancement, with specific steps or examples when possible.\nDescribe the current behavior and explain which behavior you would like to see instead, and why.\nDocumentation contributions\n\nOne of the simplest ways to get started contributing to a project is through improving documentation. Poetry is constantly evolving, and this means that sometimes our documentation has gaps. You can help by adding missing sections, editing the existing content to be more accessible, or creating new content such as tutorials, FAQs, etc.\n\nGithub Discussions and the kind/question label are excellent sources for FAQ candidates.\n\nIssues pertaining to the documentation are usually marked with the area/docs label, which will also trigger a preview of the changes as rendered by this website.\n\nCode contributions\nPicking an issue\nIf you are a first time contributor, and are looking for an issue to take on, you might want to look for at the contributing page for candidates. We do our best to curate good issues for first-time contributors there, but do fall behind – so if you don’t see anything good, feel free to ask.\n\nIf you would like to take on an issue, feel free to comment on the issue tagging @python-poetry/triage. We are more than happy to discuss solutions on the issue. If you would like help with navigating the code base, are looking for something to work on, or want feedback on a design or change, join us on our Discord server or start a Discussion.\n\nLocal development\n\nPoetry is developed using Poetry. Refer to the documentation to install Poetry in your local environment.\n\nPoetry’s development toolchain requires Python 3.8 or newer.\n\nYou should first fork the Poetry repository and then clone it locally, so that you can make pull requests against the project. If you are new to Git and pull request based development, GitHub provides a guide you will find helpful.\n\nNext, you should install Poetry’s dependencies, and run the test suite to make sure everything is working as expected:\n\npoetry install\npoetry run pytest\n\n\nWhen you contribute to Poetry, automated tools will be run to make sure your code is suitable to be merged. Besides pytest, you will need to make sure your code typechecks properly using mypy:\n\npoetry run mypy\n\n\nFinally, a great deal of linting tools are run on your code, to try and ensure consistent code style and root out common mistakes. The pre-commit tool is used to install and run these tools, and requires one-time setup:\n\npoetry run pre-commit install\n\n\npre-commit will now run and check your code every time you make a commit. By default, it will only run on changed files, but you can run it on all files manually (this may be useful if you altered the pre-commit config):\n\npoetry run pre-commit run --all-files\n\nPull requests\nFill out the pull request body completely and describe your changes as accurately as possible. The pull request body should be kept up to date as it will usually form the base for the final merge commit and the changelog entry.\nBe sure that your pull request contains tests that cover the changed or added code. Tests are generally required for code be to be considered mergeable, and code without passing tests will not be merged.\nEnsure your pull request passes the mypy and pre-commit checks. Remember that you can run these tools locally instead of relying on remote CI.\nIf your changes warrant a documentation change, the pull request must also update the documentation. Make sure to review the documentation preview generated by CI for any rendering issues.\nMake sure your branch is rebased against the latest base branch. A maintainer might ask you to ensure the branch is up-to-date prior to merging your pull request (especially if there have been CI changes on the base branch), and will also ask you to fix any conflicts.\n\nAll pull requests, unless otherwise instructed, need to be first accepted into the master branch. Maintainers will generally decide if any backports to other branches are required, and carry them out as needed.\n\nIssue triage\nIf you have an issue that hasn’t had any attention, you can ping us @python-poetry/triage on the issue. Please give us reasonable time to get to your issue first, and avoid pinging any individuals directly, especially if they are not part of the Poetry team.\n\nIf you are helping with the triage of reported issues, this section provides some useful information to assist you in your contribution.\n\nTriage steps\nDetermine what area and versions of Poetry the issue is related to, and set the appropriate labels (e.g. version/x.x.x, area/docs, area/venv), and remove the status/triage label.\nIf requested information (such as debug logs, pyproject.toml, etc.) is not provided and is relevant, request it from the author.\nSet the status/waiting-on-response label while waiting to hear back from the author.\nAttempt to reproduce the issue with the reported Poetry version or request further clarification from the author.\nEnsure the issue is not already resolved. Try reproducing it on the latest stable release, the latest prerelease (if present), and the development branch.\nIf the issue cannot be reproduced,\nrequest more reproduction steps and clarification from the issue’s author,\nset the status/needs-reproduction label,\nclose the issue if there is no reproduction forthcoming.\nIf the issue can be reproduced,\ncomment on the issue confirming so,\nset the status/confirmed label,\nif possible, identify the root cause of the issue,\nif interested, attempt to fix it via a pull request.\nMultiple versions\n\nWhen trying to reproduce issues, you often want to use multiple versions of Poetry at the same time. pipx makes this easy to do:\n\npipx install --suffix @1.2.1 'poetry==1.2.1'\npipx install --suffix @1.3.0rc1 'poetry==1.3.0rc1'\npipx install --suffix @master 'poetry @ git+https://github.com/python-poetry/poetry'\npipx install --suffix @local '/path/to/local/clone/of/poetry'\n\n# now you can use any of the chosen versions of Poetry with their configured suffix, e.g.\npoetry@master --version\n\nDo not forget to pipx upgrade poetry@master before using it, to make sure you have the latest changes.\n\nThis mechanism can also be used to test pull requests by using GitHub’s pull request remote refs:\n\npipx install --suffix @pr1234 git+https://github.com/python-poetry/poetry.git@refs/pull/1234/head\n\nFooter\n\nPython packaging and dependency management made easy.\n\nGitHub\nDiscord\nDOCUMENTATION\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\n GITHUB\nProject\nIssues\nDiscussions\nOTHER PROJECTS\npoetry-core\ninstall.python-poetry.org\nBundle plugin\nExport plugin\n\nCopyright © 2018-2024. All Rights Reserved.\nPowered by"
  },
  {
    "title": "The pyproject.toml file | 1.7 | Documentation | Poetry - Python dependency management and packaging made easy",
    "url": "https://python-poetry.org/docs/1.7/pyproject/",
    "html": "Home\nSearch\n1.7\nUse dark mode\nDOCUMENTATION\nBLOG\nHISTORY\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nname\nversion\ndescription\nlicense\nauthors\nmaintainers\nreadme\nhomepage\nrepository\ndocumentation\nkeywords\nclassifiers\npackages\ninclude and exclude\ndependencies and dependency groups\nscripts\nextras\nplugins\nurls\nPoetry and PEP-517\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\nThe pyproject.toml file\n\nThe tool.poetry section of the pyproject.toml file is composed of multiple sections.\n\nname\n\nThe name of the package. Required\n\nThis should be a valid name as defined by PEP 508.\n\nname = \"my-package\"\n\nversion\n\nThe version of the package. Required\n\nThis should be a valid PEP 440 string.\n\nversion = \"0.1.0\"\n\nIf you would like to use semantic versioning for your project, please see here.\ndescription\n\nA short description of the package. Required\n\ndescription = \"A short description of the package.\"\n\nlicense\n\nThe license of the package.\n\nThe recommended notation for the most common licenses is (alphabetical):\n\nApache-2.0\nBSD-2-Clause\nBSD-3-Clause\nBSD-4-Clause\nGPL-2.0-only\nGPL-2.0-or-later\nGPL-3.0-only\nGPL-3.0-or-later\nLGPL-2.1-only\nLGPL-2.1-or-later\nLGPL-3.0-only\nLGPL-3.0-or-later\nMIT\n\nOptional, but it is highly recommended to supply this. More identifiers are listed at the SPDX Open Source License Registry.\n\nlicense = \"MIT\"\n\nIf your project is proprietary and does not use a specific licence, you can set this value as Proprietary.\nauthors\n\nThe authors of the package. Required\n\nThis is a list of authors and should contain at least one author. Authors must be in the form name <email>.\n\nauthors = [\n    \"Sébastien Eustace <sebastien@eustace.io>\",\n]\n\nmaintainers\n\nThe maintainers of the package. Optional\n\nThis is a list of maintainers and should be distinct from authors. Maintainers may contain an email and be in the form name <email>.\n\nmaintainers = [\n    \"John Smith <johnsmith@example.org>\",\n    \"Jane Smith <janesmith@example.org>\",\n]\n\nreadme\n\nA path, or list of paths corresponding to the README file(s) of the package. Optional\n\nThe file(s) can be of any format, but if you intend to publish to PyPI keep the recommendations for a PyPI-friendly README in mind. README paths are implicitly relative to pyproject.toml.\n\nWhether paths are case-sensitive follows platform defaults, but it is recommended to keep cases.\n\nTo be specific, you can set readme = \"rEaDmE.mD\" for README.md on macOS and Windows, but Linux users can’t poetry install after cloning your repo. This is because macOS and Windows are case-insensitive and case-preserving.\n\nThe contents of the README file(s) are used to populate the Description field of your distribution’s metadata (similar to long_description in setuptools). When multiple files are specified they are concatenated with newlines.\n\n[tool.poetry]\n# ...\nreadme = \"README.md\"\n\n[tool.poetry]\n# ...\nreadme = [\"docs/README1.md\", \"docs/README2.md\"]\n\nhomepage\n\nAn URL to the website of the project. Optional\n\nhomepage = \"https://python-poetry.org/\"\n\nrepository\n\nAn URL to the repository of the project. Optional\n\nrepository = \"https://github.com/python-poetry/poetry\"\n\ndocumentation\n\nAn URL to the documentation of the project. Optional\n\ndocumentation = \"https://python-poetry.org/docs/\"\n\nkeywords\n\nA list of keywords that the package is related to. Optional\n\nkeywords = [\"packaging\", \"poetry\"]\n\nclassifiers\n\nA list of PyPI trove classifiers that describe the project. Optional\n\n[tool.poetry]\n# ...\nclassifiers = [\n    \"Topic :: Software Development :: Build Tools\",\n    \"Topic :: Software Development :: Libraries :: Python Modules\"\n]\n\n\nNote that Python classifiers are still automatically added for you and are determined by your python requirement.\n\nThe license property will also set the License classifier automatically.\n\npackages\n\nA list of packages and modules to include in the final distribution.\n\nIf your project structure differs from the standard one supported by poetry, you can specify the packages you want to include in the final distribution.\n\n[tool.poetry]\n# ...\npackages = [\n    { include = \"my_package\" },\n    { include = \"extra_package/**/*.py\" },\n]\n\n\nIf your package is stored inside a “lib” directory, you must specify it:\n\n[tool.poetry]\n# ...\npackages = [\n    { include = \"my_package\", from = \"lib\" },\n]\n\n\nIf you want to restrict a package to a specific build format you can specify it by using format:\n\n[tool.poetry]\n# ...\npackages = [\n    { include = \"my_package\" },\n    { include = \"my_other_package\", format = \"sdist\" },\n]\n\n\nFrom now on, only the sdist build archive will include the my_other_package package.\n\nUsing packages disables the package auto-detection feature meaning you have to explicitly specify the “default” package.\n\nFor instance, if you have a package named my_package and you want to also include another package named extra_package, you will need to specify my_package explicitly:\n\npackages = [\n    { include = \"my_package\" },\n    { include = \"extra_package\" },\n]\n\n\nPoetry is clever enough to detect Python subpackages.\n\nThus, you only have to specify the directory where your root package resides.\n\ninclude and exclude\n\nA list of patterns that will be included in the final package.\n\nYou can explicitly specify to Poetry that a set of globs should be ignored or included for the purposes of packaging. The globs specified in the exclude field identify a set of files that are not included when a package is built.\n\nIf a VCS is being used for a package, the exclude field will be seeded with the VCS’ ignore settings (.gitignore for git for example).\n\nExplicitly declaring entries in include will negate VCS' ignore settings.\n[tool.poetry]\n# ...\ninclude = [\"CHANGELOG.md\"]\n\n\nYou can also specify the formats for which these patterns have to be included, as shown here:\n\n[tool.poetry]\n# ...\ninclude = [\n    { path = \"tests\", format = \"sdist\" },\n    { path = \"for_wheel.txt\", format = [\"sdist\", \"wheel\"] }\n]\n\n\nIf no format is specified, it will default to include both sdist and wheel.\n\nexclude = [\"my_package/excluded.py\"]\n\ndependencies and dependency groups\n\nPoetry is configured to look for dependencies on PyPI by default. Only the name and a version string are required in this case.\n\n[tool.poetry.dependencies]\nrequests = \"^2.13.0\"\n\n\nIf you want to use a private repository, you can add it to your pyproject.toml file, like so:\n\n[[tool.poetry.source]]\nname = \"private\"\nurl = \"http://example.com/simple\"\n\n\nIf you have multiple repositories configured, you can explicitly tell poetry where to look for a specific package:\n\n[tool.poetry.dependencies]\nrequests = { version = \"^2.13.0\", source = \"private\" }\n\n\nBe aware that declaring the python version for which your package is compatible is mandatory:\n\n[tool.poetry.dependencies]\npython = \"^3.7\"\n\n\nYou can organize your dependencies in groups to manage them in a more granular way.\n\n[tool.poetry.group.test.dependencies]\npytest = \"*\"\n\n[tool.poetry.group.docs.dependencies]\nmkdocs = \"*\"\n\n\nSee Dependency groups for a more in-depth look at how to manage dependency groups and Dependency specification for more information on other keys and specifying version ranges.\n\nscripts\n\nThis section describes the scripts or executables that will be installed when installing the package\n\n[tool.poetry.scripts]\nmy_package_cli = 'my_package.console:run'\n\n\nHere, we will have the my_package_cli script installed which will execute the run function in the console module in the my_package package.\n\nTo specify a script that depends on an extra, you may provide an entry as an inline table:\n\n[tool.poetry.scripts]\ndevtest = { reference = \"mypackage:test.run_tests\", extras = [\"test\"], type = \"console\" }\n\nWhen a script is added or updated, run poetry install to make them available in the project’s virtualenv.\nextras\n\nPoetry supports extras to allow expression of:\n\noptional dependencies, which enhance a package, but are not required; and\nclusters of optional dependencies.\n[tool.poetry]\nname = \"awesome\"\n\n[tool.poetry.dependencies]\n# These packages are mandatory and form the core of this package’s distribution.\nmandatory = \"^1.0\"\n\n# A list of all of the optional dependencies, some of which are included in the\n# below `extras`. They can be opted into by apps.\npsycopg2 = { version = \"^2.9\", optional = true }\nmysqlclient = { version = \"^1.3\", optional = true }\n\n[tool.poetry.extras]\nmysql = [\"mysqlclient\"]\npgsql = [\"psycopg2\"]\ndatabases = [\"mysqlclient\", \"psycopg2\"]\n\n\nWhen installing packages with Poetry, you can specify extras by using the -E|--extras option:\n\npoetry install --extras \"mysql pgsql\"\npoetry install -E mysql -E pgsql\n\n\nAny extras you don’t specify will be removed. Note this behavior is different from optional dependency groups not selected for install, e.g. those not specified via install --with.\n\nYou can install all extras with the --all-extras option:\n\npoetry install --all-extras\n\n\nNote that install --extras and the variations mentioned above (--all-extras, --extras foo, etc.) only work on dependencies defined in the current project. If you want to install extras defined by dependencies, you’ll have to express that in the dependency itself:\n\n[tool.poetry.group.dev.dependencies]\nfastapi = {version=\"^0.92.0\", extras=[\"all\"]}\n\n\nWhen installing or specifying Poetry-built packages, the extras defined in this section can be activated as described in PEP 508.\n\nFor example, when installing the package using pip, the dependencies required by the databases extra can be installed as shown below.\n\npip install awesome[databases]\n\n\nThe dependencies specified for each extra must already be defined as project dependencies.\n\nDependencies listed in dependency groups cannot be specified as extras.\n\nplugins\n\nPoetry supports arbitrary plugins, which are exposed as the ecosystem-standard entry points and discoverable using importlib.metadata. This is similar to (and compatible with) the entry points feature of setuptools. The syntax for registering a plugin is:\n\n[tool.poetry.plugins] # Optional super table\n\n[tool.poetry.plugins.\"A\"]\n\"B\" = \"C:D\"\n\n\nWhich are:\n\nA - type of the plugin, for example poetry.plugin or flake8.extension\nB - name of the plugin\nC - python module import path\nD - the entry point of the plugin (a function or class)\n\nExample (from poetry-plugin-export):\n\n[tool.poetry.plugins.\"poetry.application.plugin\"]\nexport = \"poetry_plugin_export.plugins:ExportApplicationPlugin\"\n\nurls\n\nIn addition to the basic urls (homepage, repository and documentation), you can specify any custom url in the urls section.\n\n[tool.poetry.urls]\n\"Bug Tracker\" = \"https://github.com/python-poetry/poetry/issues\"\n\n\nIf you publish your package on PyPI, they will appear in the Project Links section.\n\nPoetry and PEP-517\n\nPEP-517 introduces a standard way to define alternative build systems to build a Python project.\n\nPoetry is compliant with PEP-517, by providing a lightweight core library, so if you use Poetry to manage your Python project you should reference it in the build-system section of the pyproject.toml file like so:\n\n[build-system]\nrequires = [\"poetry-core>=1.0.0\"]\nbuild-backend = \"poetry.core.masonry.api\"\n\nWhen using the new or init command this section will be automatically added.\nIf your pyproject.toml file still references poetry directly as a build backend, you should update it to reference poetry-core instead.\nFooter\n\nPython packaging and dependency management made easy.\n\nGitHub\nDiscord\nDOCUMENTATION\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\n GITHUB\nProject\nIssues\nDiscussions\nOTHER PROJECTS\npoetry-core\ninstall.python-poetry.org\nBundle plugin\nExport plugin\n\nCopyright © 2018-2024. All Rights Reserved.\nPowered by"
  },
  {
    "title": "Dependency specification | 1.7 | Documentation | Poetry - Python dependency management and packaging made easy",
    "url": "https://python-poetry.org/docs/1.7/dependency-specification/",
    "html": "Home\nSearch\n1.7\nUse dark mode\nDOCUMENTATION\nBLOG\nHISTORY\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nVersion constraints\nCaret requirements\nTilde requirements\nWildcard requirements\nInequality requirements\nExact requirements\nUsing the @ operator\ngit dependencies\npath dependencies\nurl dependencies\nDependency extras\nsource dependencies\nPython restricted dependencies\nUsing environment markers\nMultiple constraints dependencies\nCombining git / url / path dependencies with source repositories\nExpanded dependency specification syntax\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\nDependency specification\n\nDependencies for a project can be specified in various forms, which depend on the type of the dependency and on the optional constraints that might be needed for it to be installed.\n\nVersion constraints\nCaret requirements\n\nCaret requirements allow SemVer compatible updates to a specified version. An update is allowed if the new version number does not modify the left-most non-zero digit in the major, minor, patch grouping. For instance, if we previously ran poetry add requests@^2.13.0 and wanted to update the library and ran poetry update requests, poetry would update us to version 2.14.0 if it was available, but would not update us to 3.0.0. If instead we had specified the version string as ^0.1.13, poetry would update to 0.1.14 but not 0.2.0. 0.0.x is not considered compatible with any other version.\n\nHere are some more examples of caret requirements and the versions that would be allowed with them:\n\nREQUIREMENT\tVERSIONS ALLOWED\n^1.2.3\t>=1.2.3 <2.0.0\n^1.2\t>=1.2.0 <2.0.0\n^1\t>=1.0.0 <2.0.0\n^0.2.3\t>=0.2.3 <0.3.0\n^0.0.3\t>=0.0.3 <0.0.4\n^0.0\t>=0.0.0 <0.1.0\n^0\t>=0.0.0 <1.0.0\nTilde requirements\n\nTilde requirements specify a minimal version with some ability to update. If you specify a major, minor, and patch version or only a major and minor version, only patch-level changes are allowed. If you only specify a major version, then minor- and patch-level changes are allowed.\n\n~1.2.3 is an example of a tilde requirement.\n\nREQUIREMENT\tVERSIONS ALLOWED\n~1.2.3\t>=1.2.3 <1.3.0\n~1.2\t>=1.2.0 <1.3.0\n~1\t>=1.0.0 <2.0.0\nWildcard requirements\n\nWildcard requirements allow for the latest (dependency dependent) version where the wildcard is positioned.\n\n*, 1.* and 1.2.* are examples of wildcard requirements.\n\nREQUIREMENT\tVERSIONS ALLOWED\n*\t>=0.0.0\n1.*\t>=1.0.0 <2.0.0\n1.2.*\t>=1.2.0 <1.3.0\nInequality requirements\n\nInequality requirements allow manually specifying a version range or an exact version to depend on.\n\nHere are some examples of inequality requirements:\n\n>= 1.2.0\n> 1\n< 2\n!= 1.2.3\n\nMultiple requirements\n\nMultiple version requirements can also be separated with a comma, e.g. >= 1.2, < 1.5.\n\nExact requirements\n\nYou can specify the exact version of a package.\n\n1.2.3 is an example of an exact version specification.\n\nThis will tell Poetry to install this version and this version only. If other dependencies require a different version, the solver will ultimately fail and abort any install or update procedures.\n\nExact versions can also be specified with == according to PEP 440.\n\n==1.2.3 is an example of this.\n\nUsing the @ operator\n\nWhen adding dependencies via poetry add, you can use the @ operator. This is understood similarly to the == syntax, but also allows prefixing any specifiers that are valid in pyproject.toml. For example:\n\npoetry add django@^4.0.0\n\n\nThe above would translate to the following entry in pyproject.toml:\n\nDjango = \"^4.0.0\"\n\n\nThe special keyword latest is also understood by the @ operator:\n\npoetry add django@latest\n\n\nThe above would translate to the following entry in pyproject.toml, assuming the latest release of django is 4.0.5:\n\nDjango = \"^4.0.5\"\n\nExtras\n\nExtras and @ can be combined as one might expect (package[extra]@version):\n\npoetry add django[bcrypt]@^4.0.0\n\ngit dependencies\n\nTo depend on a library located in a git repository, the minimum information you need to specify is the location of the repository with the git key:\n\n[tool.poetry.dependencies]\nrequests = { git = \"https://github.com/requests/requests.git\" }\n\n\nSince we haven’t specified any other information, Poetry assumes that we intend to use the latest commit on the master branch to build our project.\n\nYou can combine the git key with the branch key to use another branch. Alternatively, use rev or tag to pin a dependency to a specific commit hash or tagged ref, respectively. For example:\n\n[tool.poetry.dependencies]\n# Get the latest revision on the branch named \"next\"\nrequests = { git = \"https://github.com/kennethreitz/requests.git\", branch = \"next\" }\n# Get a revision by its commit hash\nflask = { git = \"https://github.com/pallets/flask.git\", rev = \"38eb5d3b\" }\n# Get a revision by its tag\nnumpy = { git = \"https://github.com/numpy/numpy.git\", tag = \"v0.13.2\" }\n\n\nIn cases where the package you want to install is located in a subdirectory of the VCS repository, you can use the subdirectory option, similarly to what pip provides:\n\n[tool.poetry.dependencies]\n# Install a package named `subdir_package` from a folder called `subdir` within the repository\nsubdir_package = { git = \"https://github.com/myorg/mypackage_with_subdirs.git\", subdirectory = \"subdir\" }\n\n\nwith the corresponding add call:\n\npoetry add \"git+https://github.com/myorg/mypackage_with_subdirs.git#subdirectory=subdir\"\n\n\nTo use an SSH connection, for example in the case of private repositories, use the following example syntax:\n\n[tool.poetry.dependencies]\nrequests = { git = \"git@github.com:requests/requests.git\" }\n\n\nTo use HTTP basic authentication with your git repositories, you can configure credentials similar to how repository credentials are configured.\n\npoetry config repositories.git-org-project https://github.com/org/project.git\npoetry config http-basic.git-org-project username token\npoetry add git+https://github.com/org/project.git\n\n\nWith Poetry 1.2 releases, the default git client used is Dulwich.\n\nWe fall back to legacy system git client implementation in cases where gitcredentials is used. This fallback will be removed in a future release where gitcredentials helpers can be better supported natively.\n\nIn cases where you encounter issues with the default implementation that used to work prior to Poetry 1.2, you may wish to explicitly configure the use of the system git client via a shell subprocess call.\n\npoetry config experimental.system-git-client true\n\n\nKeep in mind however, that doing so will surface bugs that existed in versions prior to 1.2 which were caused due to the use of the system git client.\n\npath dependencies\n\nTo depend on a library located in a local directory or file, you can use the path property:\n\n[tool.poetry.dependencies]\n# directory\nmy-package = { path = \"../my-package/\", develop = false }\n\n# file\nmy-package = { path = \"../my-package/dist/my-package-0.1.0.tar.gz\" }\n\nBefore poetry 1.1 directory path dependencies were installed in editable mode by default. You should set the develop attribute explicitly, to make sure the behavior is the same for all poetry versions.\nurl dependencies\n\nTo depend on a library located on a remote archive, you can use the url property:\n\n[tool.poetry.dependencies]\n# directory\nmy-package = { url = \"https://example.com/my-package-0.1.0.tar.gz\" }\n\n\nwith the corresponding add call:\n\npoetry add https://example.com/my-package-0.1.0.tar.gz\n\nDependency extras\n\nYou can specify PEP-508 Extras for a dependency as shown here.\n\n[tool.poetry.dependencies]\ngunicorn = { version = \"^20.1\", extras = [\"gevent\"] }\n\nThese activate extra defined for the dependency, to configure an optional dependency for extras in your project refer to extras.\nsource dependencies\n\nTo depend on a package from an alternate repository, you can use the source property:\n\n[[tool.poetry.source]]\nname = \"foo\"\nurl = \"https://foo.bar/simple/\"\npriority = \"supplemental\"\n\n[tool.poetry.dependencies]\nmy-cool-package = { version = \"*\", source = \"foo\" }\n\n\nwith the corresponding add call:\n\npoetry add my-cool-package --source foo\n\nIn this example, we expect foo to be configured correctly. See using a private repository for further information.\nPython restricted dependencies\n\nYou can also specify that a dependency should be installed only for specific Python versions:\n\n[tool.poetry.dependencies]\ntomli = { version = \"^2.0.1\", python = \"<3.11\" }\n\n[tool.poetry.dependencies]\npathlib2 = { version = \"^2.2\", python = \"^3.2\" }\n\nUsing environment markers\n\nIf you need more complex install conditions for your dependencies, Poetry supports environment markers via the markers property:\n\n[tool.poetry.dependencies]\npathlib2 = { version = \"^2.2\", markers = \"python_version <= '3.4' or sys_platform == 'win32'\" }\n\nMultiple constraints dependencies\n\nSometimes, one of your dependency may have different version ranges depending on the target Python versions.\n\nLet’s say you have a dependency on the package foo which is only compatible with Python 3.6-3.7 up to version 1.9, and compatible with Python 3.8+ from version 2.0: you would declare it like so:\n\n[tool.poetry.dependencies]\nfoo = [\n    {version = \"<=1.9\", python = \">=3.6,<3.8\"},\n    {version = \"^2.0\", python = \">=3.8\"}\n]\n\nThe constraints must have different requirements (like python) otherwise it will cause an error when resolving dependencies.\nCombining git / url / path dependencies with source repositories\n\nDirect origin (git/ url/ path) dependencies can satisfy the requirement of a dependency that doesn’t explicitly specify a source, even when mutually exclusive markers are used. For instance in the following example the url package will also be a valid solution for the second requirement:\n\nfoo = [\n    { platform = \"darwin\", url = \"https://example.com/example-1.0-py3-none-any.whl\" },\n    { platform = \"linux\", version = \"^1.0\" },\n]\n\n\nSometimes you may instead want to use a direct origin dependency for specific conditions (i.e. a compiled package that is not available on PyPI for a certain platform/architecture) while falling back on source repositories in other cases. In this case you should explicitly ask for your dependency to be satisfied by another source. For example:\n\nfoo = [\n    { platform = \"darwin\", url = \"https://example.com/foo-1.0.0-py3-none-macosx_11_0_arm64.whl\" },\n    { platform = \"linux\", version = \"^1.0\", source = \"pypi\" },\n]\n\nExpanded dependency specification syntax\n\nIn the case of more complex dependency specifications, you may find that you end up with lines which are very long and difficult to read. In these cases, you can shift from using “inline table” syntax, to the “standard table” syntax.\n\nAn example where this might be useful is the following:\n\n[tool.poetry.group.dev.dependencies]\nblack = {version = \"19.10b0\", allow-prereleases = true, python = \"^3.7\", markers = \"platform_python_implementation == 'CPython'\"}\n\n\nAs a single line, this is a lot to digest. To make this a bit easier to work with, you can do the following:\n\n[tool.poetry.group.dev.dependencies.black]\nversion = \"19.10b0\"\nallow-prereleases = true\npython = \"^3.7\"\nmarkers = \"platform_python_implementation == 'CPython'\"\n\n\nThe same information is still present, and ends up providing the exact same specification. It’s simply split into multiple, slightly more readable, lines.\n\nFooter\n\nPython packaging and dependency management made easy.\n\nGitHub\nDiscord\nDOCUMENTATION\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\n GITHUB\nProject\nIssues\nDiscussions\nOTHER PROJECTS\npoetry-core\ninstall.python-poetry.org\nBundle plugin\nExport plugin\n\nCopyright © 2018-2024. All Rights Reserved.\nPowered by"
  },
  {
    "title": "Plugins | 1.7 | Documentation | Poetry - Python dependency management and packaging made easy",
    "url": "https://python-poetry.org/docs/1.7/plugins/",
    "html": "Home\nSearch\n1.7\nUse dark mode\nDOCUMENTATION\nBLOG\nHISTORY\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nCreating a plugin\nPlugin package\nGeneric plugins\nApplication plugins\nEvent handler\nUsing plugins\nWith pipx inject\nWith pip\nThe self add command\nMaintaining a plugin\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\nPlugins\n\nPoetry supports using and building plugins if you wish to alter or expand Poetry’s functionality with your own.\n\nFor example if your environment poses special requirements on the behaviour of Poetry which do not apply to the majority of its users or if you wish to accomplish something with Poetry in a way that is not desired by most users.\n\nIn these cases you could consider creating a plugin to handle your specific logic.\n\nCreating a plugin\n\nA plugin is a regular Python package which ships its code as part of the package and may also depend on further packages.\n\nPlugin package\n\nThe plugin package must depend on Poetry and declare a proper plugin in the pyproject.toml file.\n\n[tool.poetry]\nname = \"my-poetry-plugin\"\nversion = \"1.0.0\"\n\n# ...\n[tool.poetry.dependencies]\npython = \"^3.7\"\npoetry = \"^1.2\"\n\n[tool.poetry.plugins.\"poetry.plugin\"]\ndemo = \"poetry_demo_plugin.plugin:MyPlugin\"\n\nGeneric plugins\n\nEvery plugin has to supply a class which implements the poetry.plugins.Plugin interface.\n\nThe activate() method of the plugin is called after the plugin is loaded and receives an instance of Poetry as well as an instance of cleo.io.io.IO.\n\nUsing these two objects all configuration can be read and all public internal objects and state can be manipulated as desired.\n\nExample:\n\nfrom cleo.io.io import IO\n\nfrom poetry.plugins.plugin import Plugin\nfrom poetry.poetry import Poetry\n\n\nclass MyPlugin(Plugin):\n\n    def activate(self, poetry: Poetry, io: IO):\n        io.write_line(\"Setting readme\")\n        poetry.package.readme = \"README.md\"\n        ...\n\nApplication plugins\n\nIf you want to add commands or options to the poetry script you need to create an application plugin which implements the poetry.plugins.ApplicationPlugin interface.\n\nThe activate() method of the application plugin is called after the plugin is loaded and receives an instance of poetry.console.Application.\n\nfrom cleo.commands.command import Command\nfrom poetry.plugins.application_plugin import ApplicationPlugin\n\n\nclass CustomCommand(Command):\n\n    name = \"my-command\"\n\n    def handle(self) -> int:\n        self.line(\"My command\")\n\n        return 0\n\n\ndef factory():\n    return CustomCommand()\n\n\nclass MyApplicationPlugin(ApplicationPlugin):\n    def activate(self, application):\n        application.command_loader.register_factory(\"my-command\", factory)\n\n\nIt’s possible to do the following to register the command:\n\napplication.add(MyCommand())\n\n\nHowever, it is strongly recommended to register a new factory in the command loader to defer the loading of the command when it’s actually called.\n\nThis will help keep the performances of Poetry good.\n\nThe plugin also must be declared in the pyproject.toml file of the plugin package as a poetry.application.plugin plugin:\n\n[tool.poetry.plugins.\"poetry.application.plugin\"]\nfoo-command = \"poetry_demo_plugin.plugin:MyApplicationPlugin\"\n\nA plugin must not remove or modify in any way the core commands of Poetry.\nEvent handler\n\nPlugins can also listen to specific events and act on them if necessary.\n\nThese events are fired by Cleo and are accessible from the cleo.events.console_events module.\n\nCOMMAND: this event allows attaching listeners before any command is executed.\nSIGNAL: this event allows some actions to be performed after the command execution is interrupted.\nTERMINATE: this event allows listeners to be attached after the command.\nERROR: this event occurs when an uncaught exception is raised.\n\nLet’s see how to implement an application event handler. For this example we will see how to load environment variables from a .env file before executing a command.\n\nfrom cleo.events.console_events import COMMAND\nfrom cleo.events.console_command_event import ConsoleCommandEvent\nfrom cleo.events.event_dispatcher import EventDispatcher\nfrom dotenv import load_dotenv\nfrom poetry.console.application import Application\nfrom poetry.console.commands.env_command import EnvCommand\nfrom poetry.plugins.application_plugin import ApplicationPlugin\n\n\nclass MyApplicationPlugin(ApplicationPlugin):\n    def activate(self, application: Application):\n        application.event_dispatcher.add_listener(\n            COMMAND, self.load_dotenv\n        )\n\n    def load_dotenv(\n        self,\n        event: ConsoleCommandEvent,\n        event_name: str,\n        dispatcher: EventDispatcher\n    ) -> None:\n        command = event.command\n        if not isinstance(command, EnvCommand):\n            return\n\n        io = event.io\n\n        if io.is_debug():\n            io.write_line(\n                \"<debug>Loading environment variables.</debug>\"\n            )\n\n        load_dotenv()\n\nUsing plugins\n\nInstalled plugin packages are automatically loaded when Poetry starts up.\n\nYou have multiple ways to install plugins for Poetry\n\nWith pipx inject\n\nIf you used pipx to install Poetry you can add the plugin packages via the pipx inject command.\n\npipx inject poetry poetry-plugin\n\n\nIf you want to uninstall a plugin, you can run:\n\npipx runpip poetry uninstall poetry-plugin\n\nWith pip\n\nThe pip binary in Poetry’s virtual environment can also be used to install and remove plugins. The environment variable $POETRY_HOME here is used to represent the path to the virtual environment. The installation instructions can be referenced if you are not sure where Poetry has been installed.\n\nTo add a plugin, you can use pip install:\n\n$POETRY_HOME/bin/pip install --user poetry-plugin\n\n\nIf you want to uninstall a plugin, you can run:\n\n$POETRY_HOME/bin/pip uninstall poetry-plugin\n\nThe self add command\nEspecially on Windows, self add and self remove may be problematic so that other methods should be preferred.\npoetry self add poetry-plugin\n\n\nThe self add command will ensure that the plugin is compatible with the current version of Poetry and install the needed packages for the plugin to work.\n\nThe package specification formats supported by the self add command are the same as the ones supported by the add command.\n\nIf you no longer need a plugin and want to uninstall it, you can use the self remove command.\n\npoetry self remove poetry-plugin\n\n\nYou can also list all currently installed plugins by running:\n\npoetry self show plugins\n\nMaintaining a plugin\n\nWhen writing a plugin, you will probably access internals of Poetry, since there is no stable public API. Although we try our best to deprecate methods first, before removing them, sometimes the signature of an internal method has to be changed.\n\nAs the author of a plugin, you are probably testing your plugin against the latest release of Poetry. Additionally, you should consider testing against the latest release branch and the master branch of Poetry and schedule a CI job that runs regularly even if you did not make any changes to your plugin. This way, you will notice internal changes that break your plugin immediately and can prepare for the next Poetry release.\n\nFooter\n\nPython packaging and dependency management made easy.\n\nGitHub\nDiscord\nDOCUMENTATION\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\n GITHUB\nProject\nIssues\nDiscussions\nOTHER PROJECTS\npoetry-core\ninstall.python-poetry.org\nBundle plugin\nExport plugin\n\nCopyright © 2018-2024. All Rights Reserved.\nPowered by"
  },
  {
    "title": "Managing environments | 1.7 | Documentation | Poetry - Python dependency management and packaging made easy",
    "url": "https://python-poetry.org/docs/1.7/managing-environments/",
    "html": "Home\nSearch\n1.7\nUse dark mode\nDOCUMENTATION\nBLOG\nHISTORY\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nSwitching between environments\nDisplaying the environment information\nListing the environments associated with the project\nDeleting the environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\nManaging environments\n\nPoetry makes project environment isolation one of its core features.\n\nWhat this means is that it will always work isolated from your global Python installation. To achieve this, it will first check if it’s currently running inside a virtual environment. If it is, it will use it directly without creating a new one. But if it’s not, it will use one that it has already created or create a brand new one for you.\n\nBy default, Poetry will try to use the Python version used during Poetry’s installation to create the virtual environment for the current project.\n\nHowever, for various reasons, this Python version might not be compatible with the python range supported by the project. In this case, Poetry will try to find one that is and use it. If it’s unable to do so then you will be prompted to activate one explicitly, see Switching environments.\n\nIf you use a tool like pyenv to manage different Python versions, you can set the experimental virtualenvs.prefer-active-python option to true. Poetry will then try to find the current python of your shell.\n\nFor instance, if your project requires a newer Python than is available with your system, a standard workflow would be:\n\npyenv install 3.9.8\npyenv local 3.9.8  # Activate Python 3.9 for the current project\npoetry install\n\nSince version 1.2, Poetry no longer supports managing environments for Python 2.7.\nSwitching between environments\n\nSometimes this might not be feasible for your system, especially Windows where pyenv is not available, or you simply prefer to have a more explicit control over your environment. For this specific purpose, you can use the env use command to tell Poetry which Python version to use for the current project.\n\npoetry env use /full/path/to/python\n\n\nIf you have the python executable in your PATH you can use it:\n\npoetry env use python3.7\n\n\nYou can even just use the minor Python version in this case:\n\npoetry env use 3.7\n\n\nIf you want to disable the explicitly activated virtual environment, you can use the special system Python version to retrieve the default behavior:\n\npoetry env use system\n\nDisplaying the environment information\n\nIf you want to get basic information about the currently activated virtual environment, you can use the env info command:\n\npoetry env info\n\n\nwill output something similar to this:\n\nVirtual environment\nPython:         3.7.1\nImplementation: CPython\nPath:           /path/to/poetry/cache/virtualenvs/test-O3eWbxRl-py3.7\nValid:          True\n\nSystem\nPlatform: darwin\nOS:       posix\nPython:   /path/to/main/python\n\n\nIf you only want to know the path to the virtual environment, you can pass the --path option to env info:\n\npoetry env info --path\n\n\nIf you only want to know the path to the python executable (useful for running mypy from a global environment without installing it in the virtual environment), you can pass the --executable option to env info:\n\npoetry env info --executable\n\nListing the environments associated with the project\n\nYou can also list all the virtual environments associated with the current project with the env list command:\n\npoetry env list\n\n\nwill output something like the following:\n\ntest-O3eWbxRl-py3.6\ntest-O3eWbxRl-py3.7 (Activated)\n\n\nYou can pass the option --full-path to display the full path to the environments:\n\npoetry env list --full-path\n\nDeleting the environments\n\nFinally, you can delete existing virtual environments by using env remove:\n\npoetry env remove /full/path/to/python\npoetry env remove python3.7\npoetry env remove 3.7\npoetry env remove test-O3eWbxRl-py3.7\n\n\nYou can delete more than one environment at a time.\n\npoetry env remove python3.6 python3.7 python3.8\n\n\nUse the --all option to delete all virtual environments at once.\n\npoetry env remove --all\n\n\nIf you remove the currently activated virtual environment, it will be automatically deactivated.\n\nFooter\n\nPython packaging and dependency management made easy.\n\nGitHub\nDiscord\nDOCUMENTATION\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\n GITHUB\nProject\nIssues\nDiscussions\nOTHER PROJECTS\npoetry-core\ninstall.python-poetry.org\nBundle plugin\nExport plugin\n\nCopyright © 2018-2024. All Rights Reserved.\nPowered by"
  },
  {
    "title": "Repositories | 1.7 | Documentation | Poetry - Python dependency management and packaging made easy",
    "url": "https://python-poetry.org/docs/1.7/repositories/",
    "html": "Home\nSearch\n1.7\nUse dark mode\nDOCUMENTATION\nBLOG\nHISTORY\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nPrivate Repository Example\nPackage Sources\nProject Configuration\nSupported Package Sources\nPublishable Repositories\nConfiguring Credentials\nCertificates\nCustom certificate authority and mutual TLS authentication\nCaches\nDebugging Issues\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\nRepositories\n\nPoetry supports the use of PyPI and private repositories for discovery of packages as well as for publishing your projects.\n\nBy default, Poetry is configured to use the PyPI repository, for package installation and publishing.\n\nSo, when you add dependencies to your project, Poetry will assume they are available on PyPI.\n\nThis represents most cases and will likely be enough for most users.\n\nPrivate Repository Example\nInstalling from private package sources\n\nBy default, Poetry discovers and installs packages from PyPI. But, you want to install a dependency to your project for a simple API repository? Let’s do it.\n\nFirst, configure the package source as a supplemental (or explicit) package source to your project.\n\npoetry source add --priority=supplemental foo https://pypi.example.org/simple/\n\n\nThen, assuming the repository requires authentication, configure credentials for it.\n\npoetry config http-basic.foo <username> <password>\n\nDepending on your system configuration, credentials might be saved in your command line history. Many shells do not save commands to history when they are prefixed by a space character. For more information, please refer to your shell’s documentation.\n\nOnce this is done, you can add dependencies to your project from this source.\n\npoetry add --source foo private-package\n\nPublishing to a private repository\n\nGreat, now all that is left is to publish your package. Assuming you’d want to share it privately with your team, you can configure the Upload API endpoint for your publishable repository.\n\npoetry config repositories.foo https://pypi.example.org/legacy/\n\n\nIf you need to use a different credential for your package source, then it is recommended to use a different name for your publishing repository.\n\npoetry config repositories.foo-pub https://pypi.example.org/legacy/\npoetry config http-basic.foo-pub <username> <password>\n\n\nNow, all the is left is to build and publish your project using the publish.\n\npoetry publish --build --repository foo-pub\n\nPackage Sources\n\nBy default, Poetry is configured to use the Python ecosystem’s canonical package index PyPI.\n\nWith the exception of the implicitly configured source for PyPI named pypi, package sources are local to a project and must be configured within the project’s pyproject.toml file. This is not the same configuration used when publishing a package.\nProject Configuration\n\nThese package sources may be managed using the source command for your project.\n\npoetry source add foo https://foo.bar/simple/\n\nIf your package source requires credentials or certificates, please refer to the relevant sections below.\n\nThis will generate the following configuration snippet in your pyproject.toml file.\n\n[[tool.poetry.source]]\nname = \"foo\"\nurl = \"https://foo.bar/simple/\"\npriority = \"primary\"\n\n\nIf priority is undefined, the source is considered a primary source that takes precedence over PyPI, secondary, supplemental and explicit sources.\n\nPackage sources are considered in the following order:\n\ndefault source,\nprimary sources,\nimplicit PyPI (unless disabled by another default source or configured explicitly),\nsecondary sources (DEPRECATED),\nsupplemental sources.\n\nExplicit sources are considered only for packages that explicitly indicate their source.\n\nWithin each priority class, package sources are considered in order of appearance in pyproject.toml.\n\nIf you want to change the priority of PyPI, you can set it explicitly, e.g.\n\npoetry source add --priority=primary PyPI\n\n\nIf you prefer to disable PyPI completely, you may choose to set one of your package sources to be the default or configure PyPI as explicit source.\n\nDefault Package Source\n\nBy default, Poetry configures PyPI as the default package source for your project. You can alter this behaviour and exclusively look up packages only from the configured package sources by adding a single source with priority = \"default\".\n\npoetry source add --priority=default foo https://foo.bar/simple/\n\n\nIn a future version of Poetry, PyPI will be disabled automatically if at least one custom primary source is configured. If you are using custom sources in addition to PyPI, you should configure PyPI explicitly with a certain priority, e.g.\n\npoetry source add --priority=primary PyPI\n\n\nThis way, the priority of PyPI can be set in a fine-granular way.\n\nThe equivalent specification in pyproject.toml is:\n\n[[tool.poetry.source]]\nname = \"pypi\"\npriority = \"primary\"\n\n\nOmit the url when specifying PyPI explicitly. Because PyPI is internally configured with Poetry, the PyPI repository cannot be configured with a given URL. Remember, you can always use poetry check to ensure the validity of the pyproject.toml file.\n\nConfiguring a custom package source as default, will effectively disable PyPI as a package source for your project.\nSecondary Package Sources (DEPRECATED)\n\nDeprecated in 1.5.0\n\nIf package sources are configured as secondary, all it means is that these will be given a lower priority when selecting compatible package distribution that also exists in your default and primary package sources. If the package source should instead be searched only if higher-priority repositories did not return results, please consider a supplemental source instead.\n\nYou can configure a package source as a secondary source with priority = \"secondary\" in your package source configuration.\n\npoetry source add --priority=secondary https://foo.bar/simple/\n\n\nThere can be more than one secondary package source.\n\nSecondary package sources are deprecated in favor of supplemental package sources.\nSupplemental Package Sources\n\nIntroduced in 1.5.0\n\nPackage sources configured as supplemental are only searched if no other (higher-priority) source yields a compatible package distribution. This is particularly convenient if the response time of the source is high and relatively few package distributions are to be fetched from this source.\n\nYou can configure a package source as a supplemental source with priority = \"supplemental\" in your package source configuration.\n\npoetry source add --priority=supplemental https://foo.bar/simple/\n\n\nThere can be more than one supplemental package source.\n\nExplicit Package Sources\n\nIntroduced in 1.5.0\n\nIf package sources are configured as explicit, these sources are only searched when a package configuration explicitly indicates that it should be found on this package source.\n\nYou can configure a package source as an explicit source with priority = \"explicit\" in your package source configuration.\n\npoetry source add --priority=explicit foo https://foo.bar/simple/\n\n\nThere can be more than one explicit package source.\n\nPackage Source Constraint\n\nAll package sources (including secondary and possibly supplemental sources) will be searched during the package lookup process. These network requests will occur for all sources, regardless of if the package is found at one or more sources.\n\nIn order to limit the search for a specific package to a particular package repository, you can specify the source explicitly.\n\npoetry add --source internal-pypi httpx\n\n\nThis results in the following configuration in pyproject.toml:\n\n[tool.poetry.dependencies]\n...\nhttpx = { version = \"^0.22\", source = \"internal-pypi\" }\n\n[[tool.poetry.source]]\nname = \"internal-pypi\"\nurl = ...\npriority = ...\n\nA repository that is configured to be the only source for retrieving a certain package can itself have any priority. In particular, it does not need to have priority \"explicit\". If a repository is configured to be the source of a package, it will be the only source that is considered for that package and the repository priority will have no effect on the resolution.\n\nPackage source keys are not inherited by their dependencies. In particular, if package-A is configured to be found in source = internal-pypi, and package-A depends on package-B that is also to be found on internal-pypi, then package-B needs to be configured as such in pyproject.toml. The easiest way to achieve this is to add package-B with a wildcard constraint:\n\npoetry add --source internal-pypi package-B@*\n\n\nThis will ensure that package-B is searched only in the internal-pypi package source. The version constraints on package-B are derived from package-A (and other client packages), as usual.\n\nIf you want to avoid additional main dependencies, you can add package-B to a dedicated dependency group:\n\npoetry add --group explicit --source internal-pypi package-B@*\n\nPackage source constraints are strongly suggested for all packages that are expected to be provided only by one specific source to avoid dependency confusion attacks.\nSupported Package Sources\nPython Package Index (PyPI)\n\nPoetry interacts with PyPI via its JSON API. This is used to retrieve a requested package’s versions, metadata, files, etc.\n\nIf the the package’s published metadata is invalid, Poetry will download the available bdist/sdist to inspect it locally to identify the relevant metadata.\n\nIf you want to explicitly select a package from PyPI you can use the --source option with the add command, like shown below.\n\npoetry add --source pypi httpx@^0.22.0\n\n\nThis will generate the following configuration snippet in your pyproject.toml file.\n\nhttpx = {version = \"^0.22.0\", source = \"pypi\"}\n\nIf any source within a project is configured with priority = \"default\", The implicit pypi source will be disabled and not used for any packages.\nSimple API Repository\n\nPoetry can fetch and install package dependencies from public or private custom repositories that implement the simple repository API as described in PEP 503.\n\nWhen using sources that distributes large wheels without providing file checksum in file URLs, Poetry will download each candidate wheel at least once in order to generate the checksum. This can manifest as long dependency resolution times when adding packages from this source.\n\nThese package sources may be configured via the following command in your project.\n\npoetry source add testpypi https://test.pypi.org/simple/\n\nNote the trailing /simple/. This is important when configuring PEP 503 compliant package sources.\n\nIn addition to PEP 503, Poetry can also handle simple API repositories that implement PEP 658 (Introduced in 1.2.0). This is helpful in reducing dependency resolution time for packages from these sources as Poetry can avoid having to download each candidate distribution, in order to determine associated metadata.\n\nWhy does Poetry insist on downloading all candidate distributions for all platforms when metadata is not available?\n\nThe need for this stems from the fact that Poetry’s lock file is platform-agnostic. This means, in order to resolve dependencies for a project, Poetry needs metadata for all platform specific distributions. And when this metadata is not readily available, downloading the distribution and inspecting it locally is the only remaining option.\n\nSingle Page Link Source\n\nIntroduced in 1.2.0\n\nSome projects choose to release their binary distributions via a single page link source that partially follows the structure of a package page in PEP 503.\n\nThese package sources may be configured via the following command in your project.\n\npoetry source add jax https://storage.googleapis.com/jax-releases/jax_releases.html\n\nAll caveats regarding slower resolution times described for simple API repositories do apply here as well.\nPublishable Repositories\n\nPoetry treats repositories to which you publish packages as user specific and not project specific configuration unlike package sources. Poetry, today, only supports the Legacy Upload API when publishing your project.\n\nThese are configured using the config command, under the repositories key.\n\npoetry config repositories.testpypi https://test.pypi.org/legacy/\n\nLegacy Upload API URLs are typically different to the same one provided by the repository for the simple API. You’ll note that in the example of Test PyPI, both the host (test.pypi.org) as well as the path (/legacy) are different to it’s simple API (https://test.pypi.org/simple).\nConfiguring Credentials\n\nIf you want to store your credentials for a specific repository, you can do so easily:\n\npoetry config http-basic.foo <username> <password>\n\n\nIf you do not specify the password you will be prompted to write it.\n\nTo publish to PyPI, you can set your credentials for the repository named pypi.\n\nNote that it is recommended to use API tokens when uploading packages to PyPI. Once you have created a new token, you can tell Poetry to use it:\n\npoetry config pypi-token.pypi <my-token>\n\n\nIf you still want to use your username and password, you can do so with the following call to config.\n\npoetry config http-basic.pypi <username> <password>\n\n\nYou can also specify the username and password when using the publish command with the --username and --password options.\n\nIf a system keyring is available and supported, the password is stored to and retrieved from the keyring. In the above example, the credential will be stored using the name poetry-repository-pypi. If access to keyring fails or is unsupported, this will fall back to writing the password to the auth.toml file along with the username.\n\nKeyring support is enabled using the keyring library. For more information on supported backends refer to the library documentation.\n\nPoetry will fallback to Pip style use of keyring so that backends like Microsoft’s artifacts-keyring get a chance to retrieve valid credentials. It will need to be properly installed into Poetry’s virtualenv, preferably by installing a plugin.\n\nIf you are letting Poetry manage your virtual environments you will want a virtualenv seeder installed in Poetry’s virtualenv that installs the desired keyring backend during poetry install. To again use Azure DevOps as an example: azure-devops-artifacts-helpers provides such a seeder. This would of course best achieved by installing a Poetry plugin if it exists for you use case instead of doing it yourself.\n\nAlternatively, you can use environment variables to provide the credentials:\n\nexport POETRY_PYPI_TOKEN_PYPI=my-token\nexport POETRY_HTTP_BASIC_PYPI_USERNAME=<username>\nexport POETRY_HTTP_BASIC_PYPI_PASSWORD=<password>\n\n\nSee Using environment variables for more information on how to configure Poetry with environment variables.\n\nIf your password starts with a dash (e.g. randomly generated tokens in a CI environment), it will be parsed as a command line option instead of a password. You can prevent this by adding double dashes to prevent any following argument from being parsed as an option.\n\npoetry config -- http-basic.pypi myUsername -myPasswordStartingWithDash\n\nCertificates\nCustom certificate authority and mutual TLS authentication\n\nPoetry supports repositories that are secured by a custom certificate authority as well as those that require certificate-based client authentication. The following will configure the “foo” repository to validate the repository’s certificate using a custom certificate authority and use a client certificate (note that these config variables do not both need to be set):\n\npoetry config certificates.foo.cert /path/to/ca.pem\npoetry config certificates.foo.client-cert /path/to/client.pem\n\n\nThe value of certificates.<repository>.cert can be set to false if certificate verification is required to be skipped. This is useful for cases where a package source with self-signed certificates are used.\n\npoetry config certificates.foo.cert false\n\nDisabling certificate verification is not recommended as it is does not conform to security best practices.\nCaches\n\nPoetry employs multiple caches for package sources in order to improve user experience and avoid duplicate network requests.\n\nThe first level cache is a Cache-Control header based cache for almost all HTTP requests.\n\nFurther, every HTTP backed package source caches metadata associated with a package once it is fetched or generated. Additionally, downloaded files (package distributions) are also cached.\n\nDebugging Issues\n\nIf you encounter issues with package sources, one of the simplest steps you might take to debug an issue is rerunning your command with the --no-cache flag.\n\npoetry --no-cache add pycowsay\n\n\nIf this solves your issue, you can consider clearing your cache using the cache command.\n\nAlternatively, you could also consider enabling very verbose logging -vvv along with the --no-cache to see network requests being made in the logs.\n\nFooter\n\nPython packaging and dependency management made easy.\n\nGitHub\nDiscord\nDOCUMENTATION\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\n GITHUB\nProject\nIssues\nDiscussions\nOTHER PROJECTS\npoetry-core\ninstall.python-poetry.org\nBundle plugin\nExport plugin\n\nCopyright © 2018-2024. All Rights Reserved.\nPowered by"
  },
  {
    "title": "Configuration | 1.7 | Documentation | Poetry - Python dependency management and packaging made easy",
    "url": "https://python-poetry.org/docs/1.7/configuration/",
    "html": "Home\nSearch\n1.7\nUse dark mode\nDOCUMENTATION\nBLOG\nHISTORY\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nLocal configuration\nListing the current configuration\nDisplaying a single configuration setting\nAdding or updating a configuration setting\nRemoving a specific setting\nUsing environment variables\nDefault Directories\nConfig Directory\nData Directory\nCache Directory\nAvailable settings\ncache-dir\nexperimental.system-git-client\ninstaller.max-workers\ninstaller.modern-installation\ninstaller.no-binary\ninstaller.parallel\nvirtualenvs.create\nvirtualenvs.in-project\nvirtualenvs.options.always-copy\nvirtualenvs.options.no-pip\nvirtualenvs.options.no-setuptools\nvirtualenvs.options.system-site-packages\nvirtualenvs.path\nvirtualenvs.prefer-active-python (experimental)\nvirtualenvs.prompt\nrepositories.<name>.url\nhttp-basic.<name>.[username|password]:\npypi-token.<name>:\ncertificates.<name>.cert:\ncertificates.<name>.client-cert:\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\nConfiguration\n\nPoetry can be configured via the config command (see more about its usage here) or directly in the config.toml file that will be automatically created when you first run that command. This file can typically be found in one of the following directories:\n\nmacOS: ~/Library/Application Support/pypoetry\nWindows: %APPDATA%\\pypoetry\n\nFor Unix, we follow the XDG spec and support $XDG_CONFIG_HOME. That means, by default ~/.config/pypoetry.\n\nLocal configuration\n\nPoetry also provides the ability to have settings that are specific to a project by passing the --local option to the config command.\n\npoetry config virtualenvs.create false --local\n\nYour local configuration of Poetry application is stored in the poetry.toml file, which is separate from pyproject.toml.\nBe mindful about checking in this file into your repository since it may contain user-specific or sensitive information.\nListing the current configuration\n\nTo list the current configuration you can use the --list option of the config command:\n\npoetry config --list\n\n\nwhich will give you something similar to this:\n\ncache-dir = \"/path/to/cache/directory\"\nvirtualenvs.create = true\nvirtualenvs.in-project = null\nvirtualenvs.options.always-copy = true\nvirtualenvs.options.no-pip = false\nvirtualenvs.options.no-setuptools = false\nvirtualenvs.options.system-site-packages = false\nvirtualenvs.path = \"{cache-dir}/virtualenvs\"  # /path/to/cache/directory/virtualenvs\nvirtualenvs.prefer-active-python = false\nvirtualenvs.prompt = \"{project_name}-py{python_version}\"\n\nDisplaying a single configuration setting\n\nIf you want to see the value of a specific setting, you can give its name to the config command\n\npoetry config virtualenvs.path\n\n\nFor a full list of the supported settings see Available settings.\n\nAdding or updating a configuration setting\n\nTo change or otherwise add a new configuration setting, you can pass a value after the setting’s name:\n\npoetry config virtualenvs.path /path/to/cache/directory/virtualenvs\n\n\nFor a full list of the supported settings see Available settings.\n\nRemoving a specific setting\n\nIf you want to remove a previously set setting, you can use the --unset option:\n\npoetry config virtualenvs.path --unset\n\n\nThe setting will then retrieve its default value.\n\nUsing environment variables\n\nSometimes, in particular when using Poetry with CI tools, it’s easier to use environment variables and not have to execute configuration commands.\n\nPoetry supports this and any setting can be set by using environment variables.\n\nThe environment variables must be prefixed by POETRY_ and are comprised of the uppercase name of the setting and with dots and dashes replaced by underscore, here is an example:\n\nexport POETRY_VIRTUALENVS_PATH=/path/to/virtualenvs/directory\n\n\nThis also works for secret settings, like credentials:\n\nexport POETRY_HTTP_BASIC_MY_REPOSITORY_PASSWORD=secret\n\nDefault Directories\n\nPoetry uses the following default directories:\n\nConfig Directory\nLinux: $XDG_CONFIG_HOME/pypoetry or ~/.config/pypoetry\nWindows: %APPDATA%\\pypoetry\nMacOS: ~/Library/Application Support/pypoetry\n\nYou can override the Config directory by setting the POETRY_CONFIG_DIR environment variable.\n\nData Directory\nLinux: $XDG_DATA_HOME/pypoetry or ~/.local/share/pypoetry\nWindows: %APPDATA%\\pypoetry\nMacOS: ~/Library/Application Support/pypoetry\n\nYou can override the Data directory by setting the POETRY_DATA_DIR or POETRY_HOME environment variables. If POETRY_HOME is set, it will be given higher priority.\n\nCache Directory\nLinux: $XDG_CACHE_HOME/pypoetry or ~/.cache/pypoetry\nWindows: %LOCALAPPDATA%\\pypoetry\nMacOS: ~/Library/Caches/pypoetry\n\nYou can override the Cache directory by setting the POETRY_CACHE_DIR environment variable.\n\nAvailable settings\ncache-dir\n\nType: string\n\nEnvironment Variable: POETRY_CACHE_DIR\n\nThe path to the cache directory used by Poetry.\n\nDefaults to one of the following directories:\n\nmacOS: ~/Library/Caches/pypoetry\nWindows: C:\\Users\\<username>\\AppData\\Local\\pypoetry\\Cache\nUnix: ~/.cache/pypoetry\nexperimental.system-git-client\n\nType: boolean\n\nDefault: false\n\nEnvironment Variable: POETRY_EXPERIMENTAL_SYSTEM_GIT_CLIENT\n\nIntroduced in 1.2.0\n\nUse system git client backend for git related tasks.\n\nPoetry uses dulwich by default for git related tasks to not rely on the availability of a git client.\n\nIf you encounter any problems with it, set to true to use the system git backend.\n\ninstaller.max-workers\n\nType: int\n\nDefault: number_of_cores + 4\n\nEnvironment Variable: POETRY_INSTALLER_MAX_WORKERS\n\nIntroduced in 1.2.0\n\nSet the maximum number of workers while using the parallel installer. The number_of_cores is determined by os.cpu_count(). If this raises a NotImplementedError exception, number_of_cores is assumed to be 1.\n\nIf this configuration parameter is set to a value greater than number_of_cores + 4, the number of maximum workers is still limited at number_of_cores + 4.\n\nThis configuration is ignored when installer.parallel is set to false.\ninstaller.modern-installation\n\nType: boolean\n\nDefault: true\n\nEnvironment Variable: POETRY_INSTALLER_MODERN_INSTALLATION\n\nIntroduced in 1.4.0\n\nUse a more modern and faster method for package installation.\n\nIf this causes issues, you can disable it by setting it to false and report the problems you encounter on the issue tracker.\n\ninstaller.no-binary\n\nType: string | boolean\n\nDefault: false\n\nEnvironment Variable: POETRY_INSTALLER_NO_BINARY\n\nIntroduced in 1.2.0\n\nWhen set this configuration allows users to configure package distribution format policy for all or specific packages.\n\nCONFIGURATION\tDESCRIPTION\n:all: or true\tDisallow binary distributions for all packages.\n:none: or false\tAllow binary distributions for all packages.\npackage[,package,..]\tDisallow binary distributions for specified packages only.\nAs with all configurations described here, this is a user specific configuration. This means that this is not taken into consideration when a lockfile is generated or dependencies are resolved. This is applied only when selecting which distribution for dependency should be installed into a Poetry managed environment.\n\nFor project specific usage, it is recommended that this be configured with the --local.\n\npoetry config --local installer.no-binary :all:\n\n\nFor CI or container environments using environment variable to configure this might be useful.\n\nexport POETRY_INSTALLER_NO_BINARY=:all:\n\nUnless this is required system-wide, if configured globally, you could encounter slower install times across all your projects if incorrectly set.\ninstaller.parallel\n\nType: boolean\n\nDefault: true\n\nEnvironment Variable: POETRY_INSTALLER_PARALLEL\n\nIntroduced in 1.1.4\n\nUse parallel execution when using the new (>=1.1.0) installer.\n\nvirtualenvs.create\n\nType: boolean\n\nDefault: true\n\nEnvironment Variable: POETRY_VIRTUALENVS_CREATE\n\nCreate a new virtual environment if one doesn’t already exist.\n\nIf set to false, Poetry will not create a new virtual environment. If it detects an already enabled virtual environment or an existing one in {cache-dir}/virtualenvs or {project-dir}/.venv it will install dependencies into them, otherwise it will install dependencies into the systems python environment.\n\nIf Poetry detects it’s running within an activated virtual environment, it will never create a new virtual environment, regardless of the value set for virtualenvs.create.\n\nBe aware that installing dependencies into the system environment likely upgrade or uninstall existing packages and thus break other applications. Installing additional Python packages after installing the project might break the Poetry project in return.\n\nThis is why it is recommended to always create a virtual environment. This is also true in Docker containers, as they might contain additional Python packages as well.\n\nvirtualenvs.in-project\n\nType: boolean\n\nDefault: None\n\nEnvironment Variable: POETRY_VIRTUALENVS_IN_PROJECT\n\nCreate the virtualenv inside the project’s root directory.\n\nIf not set explicitly, poetry by default will create a virtual environment under {cache-dir}/virtualenvs or use the {project-dir}/.venv directory if one already exists.\n\nIf set to true, the virtualenv will be created and expected in a folder named .venv within the root directory of the project.\n\nIf a virtual environment has already been created for the project under {cache-dir}/virtualenvs, setting this variable to true will not cause poetry to create or use a local virtual environment.\n\nIn order for this setting to take effect for a project already in that state, you must delete the virtual environment folder located in {cache-dir}/virtualenvs.\n\nYou can find out where the current project’s virtual environment (if there is one) is stored with the command poetry env info --path.\n\nIf set to false, poetry will ignore any existing .venv directory.\n\nvirtualenvs.options.always-copy\n\nType: boolean\n\nDefault: false\n\nEnvironment Variable: POETRY_VIRTUALENVS_OPTIONS_ALWAYS_COPY\n\nIntroduced in 1.2.0\n\nIf set to true the --always-copy parameter is passed to virtualenv on creation of the virtual environment, so that all needed files are copied into it instead of symlinked.\n\nvirtualenvs.options.no-pip\n\nType: boolean\n\nDefault: false\n\nEnvironment Variable: POETRY_VIRTUALENVS_OPTIONS_NO_PIP\n\nIntroduced in 1.2.0\n\nIf set to true the --no-pip parameter is passed to virtualenv on creation of the virtual environment. This means when a new virtual environment is created, pip will not be installed in the environment.\n\nPoetry, for its internal operations, uses the pip wheel embedded in the virtualenv package installed as a dependency in Poetry’s runtime environment. If a user runs poetry run pip when this option is set to true, the pip the embedded instance of pip is used.\n\nYou can safely set this, along with no-setuptools, to true, if you desire a virtual environment with no additional packages. This is desirable for production environments.\n\nvirtualenvs.options.no-setuptools\n\nType: boolean\n\nDefault: false\n\nEnvironment Variable: POETRY_VIRTUALENVS_OPTIONS_NO_SETUPTOOLS\n\nIntroduced in 1.2.0\n\nIf set to true the --no-setuptools parameter is passed to virtualenv on creation of the virtual environment. This means when a new virtual environment is created, setuptools will not be installed in the environment. Poetry, for its internal operations, does not require setuptools and this can safely be set to true.\n\nFor environments using python 3.12 or later, virtualenv defaults to not installing setuptools when creating a virtual environment. In such environments this poetry configuration option therefore has no effect: setuptools is not installed either way. If your project relies on setuptools, you should declare it as a dependency.\n\nSome development tools like IDEs, make an assumption that setuptools (and other) packages are always present and available within a virtual environment. This can cause some features in these tools to not work as expected.\nvirtualenvs.options.system-site-packages\n\nType: boolean\n\nDefault: false\n\nEnvironment Variable: POETRY_VIRTUALENVS_OPTIONS_SYSTEM_SITE_PACKAGES\n\nGive the virtual environment access to the system site-packages directory. Applies on virtualenv creation.\n\nvirtualenvs.path\n\nType: string\n\nDefault: {cache-dir}/virtualenvs\n\nEnvironment Variable: POETRY_VIRTUALENVS_PATH\n\nDirectory where virtual environments will be created.\n\nThis setting controls the global virtual environment storage path. It most likely will not be useful at the local level. To store virtual environments in the project root, see virtualenvs.in-project.\nvirtualenvs.prefer-active-python (experimental)\n\nType: boolean\n\nDefault: false\n\nEnvironment Variable: POETRY_VIRTUALENVS_PREFER_ACTIVE_PYTHON\n\nIntroduced in 1.2.0\n\nUse currently activated Python version to create a new virtual environment. If set to false, Python version used during Poetry installation is used.\n\nvirtualenvs.prompt\n\nType: string\n\nDefault: {project_name}-py{python_version}\n\nEnvironment Variable: POETRY_VIRTUALENVS_PROMPT\n\nIntroduced in 1.2.0\n\nFormat string defining the prompt to be displayed when the virtual environment is activated. The variables project_name and python_version are available for formatting.\n\nrepositories.<name>.url\n\nType: string\n\nEnvironment Variable: POETRY_REPOSITORIES_<NAME>_URL\n\nSet the repository URL for <name>.\n\nSee Publishable Repositories for more information.\n\nhttp-basic.<name>.[username|password]:\n\nType: string\n\nEnvironment Variables: POETRY_HTTP_BASIC_<NAME>_USERNAME, POETRY_HTTP_BASIC_<NAME>_PASSWORD\n\nSet repository credentials (username and password) for <name>. See Repositories - Configuring credentials for more information.\n\npypi-token.<name>:\n\nType: string\n\nEnvironment Variable: POETRY_PYPI_TOKEN_<NAME>\n\nSet repository credentials (using an API token) for <name>. See Repositories - Configuring credentials for more information.\n\ncertificates.<name>.cert:\n\nType: string | boolean\n\nEnvironment Variable: POETRY_CERTIFICATES_<NAME>_CERT\n\nSet custom certificate authority for repository <name>. See Repositories - Configuring credentials - Custom certificate authority for more information.\n\nThis configuration can be set to false, if TLS certificate verification should be skipped for this repository.\n\ncertificates.<name>.client-cert:\n\nType: string\n\nEnvironment Variable: POETRY_CERTIFICATES_<NAME>_CLIENT_CERT\n\nSet client certificate for repository <name>. See Repositories - Configuring credentials - Custom certificate authority for more information.\n\nFooter\n\nPython packaging and dependency management made easy.\n\nGitHub\nDiscord\nDOCUMENTATION\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\n GITHUB\nProject\nIssues\nDiscussions\nOTHER PROJECTS\npoetry-core\ninstall.python-poetry.org\nBundle plugin\nExport plugin\n\nCopyright © 2018-2024. All Rights Reserved.\nPowered by"
  },
  {
    "title": "Commands | 1.7 | Documentation | Poetry - Python dependency management and packaging made easy",
    "url": "https://python-poetry.org/docs/1.7/cli/",
    "html": "Home\nSearch\n1.7\nUse dark mode\nDOCUMENTATION\nBLOG\nHISTORY\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nGlobal options\nnew\nOptions\ninit\nOptions\ninstall\nOptions\nupdate\nOptions\nadd\nOptions\nremove\nOptions\nshow\nOptions\nbuild\nOptions\npublish\nOptions\nconfig\nUsage\nOptions\nrun\nshell\ncheck\nOptions\nsearch\nlock\nOptions\nversion\nOptions\nexport\nOptions\nenv\ncache\ncache list\ncache clear\nsource\nsource add\nsource show\nsource remove\nabout\nhelp\nlist\nself\nself add\nself update\nself lock\nself show\nself show plugins\nself remove\nself install\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\nCommands\n\nYou’ve already learned how to use the command-line interface to do some things. This chapter documents all the available commands.\n\nTo get help from the command-line, simply call poetry to see the complete list of commands, then --help combined with any of those can give you more information.\n\nGlobal options\n--verbose (-v|vv|vvv): Increase the verbosity of messages: “-v” for normal output, “-vv” for more verbose output and “-vvv” for debug.\n--help (-h) : Display help information.\n--quiet (-q) : Do not output any message.\n--ansi: Force ANSI output.\n--no-ansi: Disable ANSI output.\n--version (-V): Display this application version.\n--no-interaction (-n): Do not ask any interactive question.\n--no-plugins: Disables plugins.\n--no-cache: Disables Poetry source caches.\n--directory=DIRECTORY (-C): The working directory for the Poetry command (defaults to the current working directory).\nnew\n\nThis command will help you kickstart your new Python project by creating a directory structure suitable for most projects.\n\npoetry new my-package\n\n\nwill create a folder as follows:\n\nmy-package\n├── pyproject.toml\n├── README.md\n├── my_package\n│   └── __init__.py\n└── tests\n    └── __init__.py\n\n\nIf you want to name your project differently than the folder, you can pass the --name option:\n\npoetry new my-folder --name my-package\n\n\nIf you want to use a src folder, you can use the --src option:\n\npoetry new --src my-package\n\n\nThat will create a folder structure as follows:\n\nmy-package\n├── pyproject.toml\n├── README.md\n├── src\n│   └── my_package\n│       └── __init__.py\n└── tests\n    └── __init__.py\n\n\nThe --name option is smart enough to detect namespace packages and create the required structure for you.\n\npoetry new --src --name my.package my-package\n\n\nwill create the following structure:\n\nmy-package\n├── pyproject.toml\n├── README.md\n├── src\n│   └── my\n│       └── package\n│           └── __init__.py\n└── tests\n    └── __init__.py\n\nOptions\n--name: Set the resulting package name.\n--src: Use the src layout for the project.\n--readme: Specify the readme file extension. Default is md. If you intend to publish to PyPI keep the recommendations for a PyPI-friendly README in mind.\ninit\n\nThis command will help you create a pyproject.toml file interactively by prompting you to provide basic information about your package.\n\nIt will interactively ask you to fill in the fields, while using some smart defaults.\n\npoetry init\n\nOptions\n--name: Name of the package.\n--description: Description of the package.\n--author: Author of the package.\n--python Compatible Python versions.\n--dependency: Package to require with a version constraint. Should be in format foo:1.0.0.\n--dev-dependency: Development requirements, see --dependency.\ninstall\n\nThe install command reads the pyproject.toml file from the current project, resolves the dependencies, and installs them.\n\npoetry install\n\n\nIf there is a poetry.lock file in the current directory, it will use the exact versions from there instead of resolving them. This ensures that everyone using the library will get the same versions of the dependencies.\n\nIf there is no poetry.lock file, Poetry will create one after dependency resolution.\n\nIf you want to exclude one or more dependency groups for the installation, you can use the --without option.\n\npoetry install --without test,docs\n\nThe --no-dev option is now deprecated. You should use the --without dev notation instead.\n\nYou can also select optional dependency groups with the --with option.\n\npoetry install --with test,docs\n\n\nIt’s also possible to only install specific dependency groups by using the only option.\n\npoetry install --only test,docs\n\n\nTo only install the project itself with no dependencies, use the --only-root flag.\n\npoetry install --only-root\n\n\nSee Dependency groups for more information about dependency groups.\n\nIf you want to synchronize your environment – and ensure it matches the lock file – use the --sync option.\n\npoetry install --sync\n\n\nThe --sync can be combined with group-related options:\n\npoetry install --without dev --sync\npoetry install --with docs --sync\npoetry install --only dev\n\n\nYou can also specify the extras you want installed by passing the -E|--extras option (See Extras for more info). Pass --all-extras to install all defined extras for a project.\n\npoetry install --extras \"mysql pgsql\"\npoetry install -E mysql -E pgsql\npoetry install --all-extras\n\n\nExtras are not sensitive to --sync. Any extras not specified will always be removed.\n\npoetry install --extras \"A B\"  # C is removed\n\n\nBy default poetry will install your project’s package every time you run install:\n\n$ poetry install\nInstalling dependencies from lock file\n\nNo dependencies to install or update\n\n  - Installing <your-package-name> (x.x.x)\n\n\nIf you want to skip this installation, use the --no-root option.\n\npoetry install --no-root\n\n\nSimilar to --no-root you can use --no-directory to skip directory path dependencies:\n\npoetry install --no-directory\n\n\nThis is mainly useful for caching in CI or when building Docker images. See the FAQ entry for more information on this option.\n\nBy default poetry does not compile Python source files to bytecode during installation. This speeds up the installation process, but the first execution may take a little more time because Python then compiles source files to bytecode automatically. If you want to compile source files to bytecode during installation, you can use the --compile option:\n\npoetry install --compile\n\nThe --compile option has no effect if installer.modern-installation is set to false because the old installer always compiles source files to bytecode.\nOptions\n--without: The dependency groups to ignore.\n--with: The optional dependency groups to include.\n--only: The only dependency groups to include.\n--only-root: Install only the root project, exclude all dependencies.\n--sync: Synchronize the environment with the locked packages and the specified groups.\n--no-root: Do not install the root package (your project).\n--no-directory: Skip all directory path dependencies (including transitive ones).\n--dry-run: Output the operations but do not execute anything (implicitly enables –verbose).\n--extras (-E): Features to install (multiple values allowed).\n--all-extras: Install all extra features (conflicts with –extras).\n--compile: Compile Python source files to bytecode.\n--no-dev: Do not install dev dependencies. (Deprecated, use --without dev or --only main instead)\n--remove-untracked: Remove dependencies not presented in the lock file. (Deprecated, use --sync instead)\nWhen --only is specified, --with and --without options are ignored.\nupdate\n\nIn order to get the latest versions of the dependencies and to update the poetry.lock file, you should use the update command.\n\npoetry update\n\n\nThis will resolve all dependencies of the project and write the exact versions into poetry.lock.\n\nIf you just want to update a few packages and not all, you can list them as such:\n\npoetry update requests toml\n\n\nNote that this will not update versions for dependencies outside their version constraints specified in the pyproject.toml file. In other terms, poetry update foo will be a no-op if the version constraint specified for foo is ~2.3 or 2.3 and 2.4 is available. In order for foo to be updated, you must update the constraint, for example ^2.3. You can do this using the add command.\n\nOptions\n--without: The dependency groups to ignore.\n--with: The optional dependency groups to include.\n--only: The only dependency groups to include.\n--dry-run : Outputs the operations but will not execute anything (implicitly enables –verbose).\n--no-dev : Do not update the development dependencies. (Deprecated, use --without dev or --only main instead)\n--lock : Do not perform install (only update the lockfile).\nWhen --only is specified, --with and --without options are ignored.\nadd\n\nThe add command adds required packages to your pyproject.toml and installs them.\n\nIf you do not specify a version constraint, poetry will choose a suitable one based on the available package versions.\n\npoetry add requests pendulum\n\n\nYou can also specify a constraint when adding a package:\n\n# Allow >=2.0.5, <3.0.0 versions\npoetry add pendulum@^2.0.5\n\n# Allow >=2.0.5, <2.1.0 versions\npoetry add pendulum@~2.0.5\n\n# Allow >=2.0.5 versions, without upper bound\npoetry add \"pendulum>=2.0.5\"\n\n# Allow only 2.0.5 version\npoetry add pendulum==2.0.5\n\nSee the Dependency specification page for more information about the @ operator.\n\nIf you try to add a package that is already present, you will get an error. However, if you specify a constraint, like above, the dependency will be updated by using the specified constraint.\n\nIf you want to get the latest version of an already present dependency, you can use the special latest constraint:\n\npoetry add pendulum@latest\n\nSee the Dependency specification for more information on setting the version constraints for a package.\n\nYou can also add git dependencies:\n\npoetry add git+https://github.com/sdispater/pendulum.git\n\n\nor use ssh instead of https:\n\npoetry add git+ssh://git@github.com/sdispater/pendulum.git\n\n# or alternatively:\npoetry add git+ssh://git@github.com:sdispater/pendulum.git\n\n\nIf you need to checkout a specific branch, tag or revision, you can specify it when using add:\n\npoetry add git+https://github.com/sdispater/pendulum.git#develop\npoetry add git+https://github.com/sdispater/pendulum.git#2.0.5\n\n# or using SSH instead:\npoetry add git+ssh://github.com/sdispater/pendulum.git#develop\npoetry add git+ssh://github.com/sdispater/pendulum.git#2.0.5\n\n\nor reference a subdirectory:\n\npoetry add git+https://github.com/myorg/mypackage_with_subdirs.git@main#subdirectory=subdir\n\n\nYou can also add a local directory or file:\n\npoetry add ./my-package/\npoetry add ../my-package/dist/my-package-0.1.0.tar.gz\npoetry add ../my-package/dist/my_package-0.1.0.whl\n\n\nIf you want the dependency to be installed in editable mode you can use the --editable option.\n\npoetry add --editable ./my-package/\npoetry add --editable git+ssh://github.com/sdispater/pendulum.git#develop\n\n\nAlternatively, you can specify it in the pyproject.toml file. It means that changes in the local directory will be reflected directly in environment.\n\n[tool.poetry.dependencies]\nmy-package = {path = \"../my/path\", develop = true}\n\nBefore poetry 1.1 path dependencies were installed in editable mode by default. You should always set the develop attribute explicitly, to make sure the behavior is the same for all poetry versions.\n\nIf the package(s) you want to install provide extras, you can specify them when adding the package:\n\npoetry add \"requests[security,socks]\"\npoetry add \"requests[security,socks]~=2.22.0\"\npoetry add \"git+https://github.com/pallets/flask.git@1.1.1[dotenv,dev]\"\n\nSome shells may treat square braces ([ and ]) as special characters. It is suggested to always quote arguments containing these characters to prevent unexpected shell expansion.\n\nIf you want to add a package to a specific group of dependencies, you can use the --group (-G) option:\n\npoetry add mkdocs --group docs\n\n\nSee Dependency groups for more information about dependency groups.\n\nOptions\n--group (-G): The group to add the dependency to.\n--dev (-D): Add package as development dependency. (Deprecated, use -G dev instead)\n--editable (-e): Add vcs/path dependencies as editable.\n--extras (-E): Extras to activate for the dependency. (multiple values allowed)\n--optional: Add as an optional dependency.\n--python: Python version for which the dependency must be installed.\n--platform: Platforms for which the dependency must be installed.\n--source: Name of the source to use to install the package.\n--allow-prereleases: Accept prereleases.\n--dry-run: Output the operations but do not execute anything (implicitly enables –verbose).\n--lock: Do not perform install (only update the lockfile).\nremove\n\nThe remove command removes a package from the current list of installed packages.\n\npoetry remove pendulum\n\n\nIf you want to remove a package from a specific group of dependencies, you can use the --group (-G) option:\n\npoetry remove mkdocs --group docs\n\n\nSee Dependency groups for more information about dependency groups.\n\nOptions\n--group (-G): The group to remove the dependency from.\n--dev (-D): Removes a package from the development dependencies. (Deprecated, use -G dev instead)\n--dry-run : Outputs the operations but will not execute anything (implicitly enables –verbose).\n--lock: Do not perform operations (only update the lockfile).\nshow\n\nTo list all the available packages, you can use the show command.\n\npoetry show\n\n\nIf you want to see the details of a certain package, you can pass the package name.\n\npoetry show pendulum\n\nname        : pendulum\nversion     : 1.4.2\ndescription : Python datetimes made easy\n\ndependencies\n - python-dateutil >=2.6.1\n - tzlocal >=1.4\n - pytzdata >=2017.2.2\n\nrequired by\n - calendar >=1.4.0\n\nOptions\n--without: The dependency groups to ignore.\n--why: When showing the full list, or a --tree for a single package, display why a package is included.\n--with: The optional dependency groups to include.\n--only: The only dependency groups to include.\n--no-dev: Do not list the dev dependencies. (Deprecated, use --without dev or --only main instead)\n--tree: List the dependencies as a tree.\n--latest (-l): Show the latest version.\n--outdated (-o): Show the latest version but only for packages that are outdated.\n--all (-a): Show all packages (even those not compatible with current system).\n--top-level (-T): Only show explicitly defined packages.\nWhen --only is specified, --with and --without options are ignored.\nbuild\n\nThe build command builds the source and wheels archives.\n\npoetry build\n\n\nNote that, at the moment, only pure python wheels are supported.\n\nOptions\n--format (-f): Limit the format to either wheel or sdist.\npublish\n\nThis command publishes the package, previously built with the build command, to the remote repository.\n\nIt will automatically register the package before uploading if this is the first time it is submitted.\n\npoetry publish\n\n\nIt can also build the package if you pass it the --build option.\n\nSee Publishable Repositories for more information on how to configure and use publishable repositories.\nOptions\n--repository (-r): The repository to register the package to (default: pypi). Should match a repository name set by the config command.\n--username (-u): The username to access the repository.\n--password (-p): The password to access the repository.\n--cert: Certificate authority to access the repository.\n--client-cert: Client certificate to access the repository.\n--build: Build the package before publishing.\n--dry-run: Perform all actions except upload the package.\n--skip-existing: Ignore errors from files already existing in the repository.\nconfig\n\nThe config command allows you to edit poetry config settings and repositories.\n\npoetry config --list\n\nUsage\npoetry config [options] [setting-key] [setting-value1] ... [setting-valueN]\n\n\nsetting-key is a configuration option name and setting-value1 is a configuration value. See Configuration for all available settings.\n\nOptions\n--unset: Remove the configuration element named by setting-key.\n--list: Show the list of current config variables.\n--local: Set/Get settings that are specific to a project (in the local configuration file poetry.toml).\nrun\n\nThe run command executes the given command inside the project’s virtualenv.\n\npoetry run python -V\n\n\nIt can also execute one of the scripts defined in pyproject.toml.\n\nSo, if you have a script defined like this:\n\n[tool.poetry.scripts]\nmy-script = \"my_module:main\"\n\n\nYou can execute it like so:\n\npoetry run my-script\n\n\nNote that this command has no option.\n\nshell\n\nThe shell command spawns a shell, according to the $SHELL environment variable, within the virtual environment. If one doesn’t exist yet, it will be created.\n\npoetry shell\n\n\nNote that this command starts a new shell and activates the virtual environment.\n\nAs such, exit should be used to properly exit the shell and the virtual environment instead of deactivate.\n\ncheck\n\nThe check command validates the content of the pyproject.toml file and its consistency with the poetry.lock file. It returns a detailed report if there are any errors.\n\nThis command is also available as a pre-commit hook. See pre-commit hooks for more information.\npoetry check\n\nOptions\n--lock: Verifies that poetry.lock exists for the current pyproject.toml.\nsearch\n\nThis command searches for packages on a remote index.\n\npoetry search requests pendulum\n\nlock\n\nThis command locks (without installing) the dependencies specified in pyproject.toml.\n\nBy default, this will lock all dependencies to the latest available compatible versions. To only refresh the lock file, use the --no-update option. This command is also available as a pre-commit hook. See pre-commit hooks for more information.\npoetry lock\n\nOptions\n--check: Verify that poetry.lock is consistent with pyproject.toml. (Deprecated) Use poetry check --lock instead.\n--no-update: Do not update locked versions, only refresh lock file.\nversion\n\nThis command shows the current version of the project or bumps the version of the project and writes the new version back to pyproject.toml if a valid bump rule is provided.\n\nThe new version should be a valid PEP 440 string or a valid bump rule: patch, minor, major, prepatch, preminor, premajor, prerelease.\n\nIf you would like to use semantic versioning for your project, please see here.\n\nThe table below illustrates the effect of these rules with concrete examples.\n\nRULE\tBEFORE\tAFTER\nmajor\t1.3.0\t2.0.0\nminor\t2.1.4\t2.2.0\npatch\t4.1.1\t4.1.2\npremajor\t1.0.2\t2.0.0a0\npreminor\t1.0.2\t1.1.0a0\nprepatch\t1.0.2\t1.0.3a0\nprerelease\t1.0.2\t1.0.3a0\nprerelease\t1.0.3a0\t1.0.3a1\nprerelease\t1.0.3b0\t1.0.3b1\n\nThe option --next-phase allows the increment of prerelease phase versions.\n\nRULE\tBEFORE\tAFTER\nprerelease –next-phase\t1.0.3a0\t1.0.3b0\nprerelease –next-phase\t1.0.3b0\t1.0.3rc0\nprerelease –next-phase\t1.0.3rc0\t1.0.3\nOptions\n--next-phase: Increment the phase of the current version.\n--short (-s): Output the version number only.\n--dry-run: Do not update pyproject.toml file.\nexport\n\nThis command exports the lock file to other formats.\n\npoetry export -f requirements.txt --output requirements.txt\n\nThis command is provided by the Export Poetry Plugin. In a future version of Poetry this plugin will not be installed by default anymore. In order to avoid a breaking change and make your automation forward-compatible, please install poetry-plugin-export explicitly. See Using plugins for details on how to install a plugin.\nThis command is also available as a pre-commit hook. See pre-commit hooks for more information.\nUnlike the install command, this command only includes the project’s dependencies defined in the implicit main group defined in tool.poetry.dependencies when used without specifying any options.\nOptions\n--format (-f): The format to export to (default: requirements.txt). Currently, only constraints.txt and requirements.txt are supported.\n--output (-o): The name of the output file. If omitted, print to standard output.\n--dev: Include development dependencies. (Deprecated, use --with dev instead)\n--extras (-E): Extra sets of dependencies to include.\n--without: The dependency groups to ignore.\n--with: The optional dependency groups to include.\n--only: The only dependency groups to include.\n--without-hashes: Exclude hashes from the exported file.\n--without-urls: Exclude source repository urls from the exported file.\n--with-credentials: Include credentials for extra indices.\nenv\n\nThe env command regroups sub commands to interact with the virtualenvs associated with a specific project.\n\nSee Managing environments for more information about these commands.\n\ncache\n\nThe cache command regroups sub commands to interact with Poetry’s cache.\n\ncache list\n\nThe cache list command lists Poetry’s available caches.\n\npoetry cache list\n\ncache clear\n\nThe cache clear command removes packages from a cached repository.\n\nFor example, to clear the whole cache of packages from the pypi repository, run:\n\npoetry cache clear pypi --all\n\n\nTo only remove a specific package from a cache, you have to specify the cache entry in the following form cache:package:version:\n\npoetry cache clear pypi:requests:2.24.0\n\nsource\n\nThe source namespace regroups sub commands to manage repository sources for a Poetry project.\n\nsource add\n\nThe source add command adds source configuration to the project.\n\nFor example, to add the pypi-test source, you can run:\n\npoetry source add pypi-test https://test.pypi.org/simple/\n\n\nYou cannot use the name pypi for a custom repository as it is reserved for use by the default PyPI source. However, you can set the priority of PyPI:\n\npoetry source add --priority=explicit pypi\n\nOptions\n--default: Set this source as the default (disable PyPI). Deprecated in favor of --priority.\n--secondary: Set this source as a secondary source. Deprecated in favor of --priority.\n--priority: Set the priority of this source. Accepted values are: default, secondary, supplemental, and explicit. Refer to the dedicated sections in Repositories for more information.\nAt most one of the options above can be provided. See package sources for more information.\nsource show\n\nThe source show command displays information on all configured sources for the project.\n\npoetry source show\n\n\nOptionally, you can show information of one or more sources by specifying their names.\n\npoetry source show pypi-test\n\nThis command will only show sources configured via the pyproject.toml and does not include the implicit default PyPI.\nsource remove\n\nThe source remove command removes a configured source from your pyproject.toml.\n\npoetry source remove pypi-test\n\nabout\n\nThe about command displays global information about Poetry, including the current version and version of poetry-core.\n\npoetry about\n\nhelp\n\nThe help command displays global help, or help for a specific command.\n\nTo display global help:\n\npoetry help\n\n\nTo display help for a specific command, for instance show:\n\npoetry help show\n\n\nThe --help option can also be passed to any command to get help for a specific command.\n\nFor instance:\n\npoetry show --help\n\nlist\n\nThe list command displays all the available Poetry commands.\n\npoetry list\n\nself\n\nThe self namespace regroups sub commands to manage the Poetry installation itself.\n\nUse of these commands will create the required pyproject.toml and poetry.lock files in your configuration directory.\nEspecially on Windows, self commands that update or remove packages may be problematic so that other methods for installing plugins and updating Poetry are recommended. See Using plugins and Installing Poetry for more information.\nself add\n\nThe self add command installs Poetry plugins and make them available at runtime. Additionally, it can also be used to upgrade Poetry’s own dependencies or inject additional packages into the runtime environment\n\nThe self add command works exactly like the add command. However, is different in that the packages managed are for Poetry’s runtime environment.\n\nThe package specification formats supported by the self add command are the same as the ones supported by the add command.\n\nFor example, to install the poetry-plugin-export plugin, you can run:\n\npoetry self add poetry-plugin-export\n\n\nTo update to the latest poetry-core version, you can run:\n\npoetry self add poetry-core@latest\n\n\nTo add a keyring provider artifacts-keyring, you can run:\n\npoetry self add artifacts-keyring\n\nOptions\n--editable (-e): Add vcs/path dependencies as editable.\n--extras (-E): Extras to activate for the dependency. (multiple values allowed)\n--allow-prereleases: Accept prereleases.\n--source: Name of the source to use to install the package.\n--dry-run: Output the operations but do not execute anything (implicitly enables –verbose).\nself update\n\nThe self update command updates Poetry version in its current runtime environment.\n\nThe self update command works exactly like the update command. However, is different in that the packages managed are for Poetry’s runtime environment.\npoetry self update\n\nOptions\n--preview: Allow the installation of pre-release versions.\n--dry-run: Output the operations but do not execute anything (implicitly enables –verbose).\nself lock\n\nThe self lock command reads this Poetry installation’s system pyproject.toml file. The system dependencies are locked in the corresponding poetry.lock file.\n\npoetry self lock\n\nOptions\n--check: Verify that poetry.lock is consistent with pyproject.toml. (Deprecated)\n--no-update: Do not update locked versions, only refresh lock file.\nself show\n\nThe self show command behaves similar to the show command, but working within Poetry’s runtime environment. This lists all packages installed within the Poetry install environment.\n\nTo show only additional packages that have been added via self add and their dependencies use self show --addons.\n\npoetry self show\n\nOptions\n--addons: List only add-on packages installed.\n--tree: List the dependencies as a tree.\n--latest (-l): Show the latest version.\n--outdated (-o): Show the latest version but only for packages that are outdated.\nself show plugins\n\nThe self show plugins command lists all the currently installed plugins.\n\npoetry self show plugins\n\nself remove\n\nThe self remove command removes an installed addon package.\n\npoetry self remove poetry-plugin-export\n\nOptions\n--dry-run: Outputs the operations but will not execute anything (implicitly enables –verbose).\nself install\n\nThe self install command ensures all additional packages specified are installed in the current runtime environment.\n\nThe self install command works similar to the install command. However, is different in that the packages managed are for Poetry’s runtime environment.\npoetry self install --sync\n\nOptions\n--sync: Synchronize the environment with the locked packages and the specified groups.\n--dry-run: Output the operations but do not execute anything (implicitly enables –verbose).\nFooter\n\nPython packaging and dependency management made easy.\n\nGitHub\nDiscord\nDOCUMENTATION\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\n GITHUB\nProject\nIssues\nDiscussions\nOTHER PROJECTS\npoetry-core\ninstall.python-poetry.org\nBundle plugin\nExport plugin\n\nCopyright © 2018-2024. All Rights Reserved.\nPowered by"
  },
  {
    "title": "Libraries | 1.7 | Documentation | Poetry - Python dependency management and packaging made easy",
    "url": "https://python-poetry.org/docs/1.7/libraries/",
    "html": "Home\nSearch\n1.7\nUse dark mode\nDOCUMENTATION\nBLOG\nHISTORY\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nVersioning\nLock file\nPackaging\nPublishing to PyPI\nPublishing to a private repository\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\nLibraries\n\nThis chapter will tell you how to make your library installable through Poetry.\n\nVersioning\n\nPoetry requires PEP 440-compliant versions for all projects.\n\nWhile Poetry does not enforce any release convention, it used to encourage the use of semantic versioning within the scope of PEP 440 and supports version constraints that are especially suitable for semver.\n\nAs an example, 1.0.0-hotfix.1 is not compatible with PEP 440. You can instead choose to use 1.0.0-post1 or 1.0.0.post1.\nLock file\n\nFor your library, you may commit the poetry.lock file if you want to. This can help your team to always test against the same dependency versions. However, this lock file will not have any effect on other projects that depend on it. It only has an effect on the main project.\n\nIf you do not want to commit the lock file and you are using git, add it to the .gitignore.\n\nPackaging\n\nBefore you can actually publish your library, you will need to package it.\n\npoetry build\n\n\nThis command will package your library in two different formats: sdist which is the source format, and wheel which is a compiled package.\n\nPoetry will automatically include some metadata files when building a package. When building a wheel, the following files are included in the .dist-info directory:\n\nLICENSE\nLICENSE.*\nCOPYING\nCOPYING.*\nLICENSES/**\n\nWhen building an sdist, the following files will be included in the root folder:\n\nLICENSE*\n\nOnce building is done you are ready to publish your library.\n\nPublishing to PyPI\n\nAlright, so now you can publish packages.\n\nPoetry will publish to PyPI by default. Anything that is published to PyPI is available automatically through Poetry. Since pendulum is on PyPI we can depend on it without having to specify any additional repositories.\n\nIf we wanted to share poetry-demo with the Python community, we would publish on PyPI as well. Doing so is really easy.\n\npoetry publish\n\n\nThis will package and publish the library to PyPI, at the condition that you are a registered user and you have configured your credentials properly.\n\nThe publish command does not execute build by default.\n\nIf you want to build and publish your packages together, just pass the --build option.\n\nOnce this is done, your library will be available to anyone.\n\nPublishing to a private repository\n\nSometimes, you may want to keep your library private but also being accessible to your team.\n\nIn this case, you will need to use a private repository.\n\nIn order to publish to a private repository, you will need to add it to your global list of repositories. See Adding a repository for more information.\n\nOnce this is done, you can actually publish to it like so:\n\npoetry publish -r my-repository\n\nFooter\n\nPython packaging and dependency management made easy.\n\nGitHub\nDiscord\nDOCUMENTATION\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\n GITHUB\nProject\nIssues\nDiscussions\nOTHER PROJECTS\npoetry-core\ninstall.python-poetry.org\nBundle plugin\nExport plugin\n\nCopyright © 2018-2024. All Rights Reserved.\nPowered by"
  },
  {
    "title": "Managing dependencies | 1.7 | Documentation | Poetry - Python dependency management and packaging made easy",
    "url": "https://python-poetry.org/docs/1.7/managing-dependencies/",
    "html": "Home\nSearch\n1.7\nUse dark mode\nDOCUMENTATION\nBLOG\nHISTORY\nIntroduction\nBasic usage\nManaging dependencies\nDependency groups\nOptional groups\nAdding a dependency to a group\nInstalling group dependencies\nRemoving dependencies from a group\nSynchronizing dependencies\nLayering optional groups\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\nManaging dependencies\nDependency groups\n\nPoetry provides a way to organize your dependencies by groups. For instance, you might have dependencies that are only needed to test your project or to build the documentation.\n\nTo declare a new dependency group, use a tool.poetry.group.<group> section where <group> is the name of your dependency group (for instance, test):\n\n[tool.poetry.group.test]  # This part can be left out\n\n[tool.poetry.group.test.dependencies]\npytest = \"^6.0.0\"\npytest-mock = \"*\"\n\n\nAll dependencies must be compatible with each other across groups since they will be resolved regardless of whether they are required for installation or not (see Installing group dependencies).\n\nThink of dependency groups as labels associated with your dependencies: they don’t have any bearings on whether their dependencies will be resolved and installed by default, they are simply a way to organize the dependencies logically.\n\nThe dependencies declared in tool.poetry.dependencies are part of an implicit main group.\n\n[tool.poetry.dependencies]  # main dependency group\nhttpx = \"*\"\npendulum = \"*\"\n\n\n[tool.poetry.group.test.dependencies]\npytest = \"^6.0.0\"\npytest-mock = \"*\"\n\n\nDependency groups, other than the implicit main group, must only contain dependencies you need in your development process. Installing them is only possible by using Poetry.\n\nTo declare a set of dependencies, which add additional functionality to the project during runtime, use extras instead. Extras can be installed by the end user using pip.\n\nA note about defining a dev dependencies group\n\nThe proper way to define a dev dependencies group since Poetry 1.2.0 is the following:\n\n[tool.poetry.group.dev.dependencies]\npytest = \"^6.0.0\"\npytest-mock = \"*\"\n\n\nThis group notation is preferred since Poetry 1.2.0 and not usable in earlier versions. For backwards compatibility with older versions of Poetry, any dependency declared in the dev-dependencies section will automatically be added to the dev group. So the above and following notations are equivalent:\n\n# Poetry pre-1.2.x style, understood by Poetry 1.0–1.2\n[tool.poetry.dev-dependencies]\npytest = \"^6.0.0\"\npytest-mock = \"*\"\n\n\nPoetry will slowly transition away from the dev-dependencies notation which will soon be deprecated, so it’s advised to migrate your existing development dependencies to the new group notation.\n\nOptional groups\n\nA dependency group can be declared as optional. This makes sense when you have a group of dependencies that are only required in a particular environment or for a specific purpose.\n\n[tool.poetry.group.docs]\noptional = true\n\n[tool.poetry.group.docs.dependencies]\nmkdocs = \"*\"\n\n\nOptional groups can be installed in addition to the default dependencies by using the --with option of the install command.\n\npoetry install --with docs\n\nOptional group dependencies will still be resolved alongside other dependencies, so special care should be taken to ensure they are compatible with each other.\nAdding a dependency to a group\n\nThe add command is the preferred way to add dependencies to a group. This is done by using the --group (-G) option.\n\npoetry add pytest --group test\n\n\nIf the group does not already exist, it will be created automatically.\n\nInstalling group dependencies\n\nBy default, dependencies across all non-optional groups will be installed when executing poetry install.\n\nThe default set of dependencies for a project includes the implicit main group defined in tool.poetry.dependencies as well as all groups that are not explicitly marked as an optional group.\n\nYou can exclude one or more groups with the --without option:\n\npoetry install --without test,docs\n\n\nYou can also opt in optional groups by using the --with option:\n\npoetry install --with docs\n\n\nWhen used together, --without takes precedence over --with. For example, the following command will only install the dependencies specified in the optional test group.\n\npoetry install --with test,docs --without docs\n\n\nFinally, in some case you might want to install only specific groups of dependencies without installing the default set of dependencies. For that purpose, you can use the --only option.\n\npoetry install --only docs\n\n\nIf you only want to install the project’s runtime dependencies, you can do so with the --only main notation:\n\npoetry install --only main\n\n\nIf you want to install the project root, and no other dependencies, you can use the --only-root option.\n\npoetry install --only-root\n\nRemoving dependencies from a group\n\nThe remove command supports a --group option to remove packages from a specific group:\n\npoetry remove mkdocs --group docs\n\nSynchronizing dependencies\n\nPoetry supports what’s called dependency synchronization. Dependency synchronization ensures that the locked dependencies in the poetry.lock file are the only ones present in the environment, removing anything that’s not necessary.\n\nThis is done by using the --sync option of the install command:\n\npoetry install --sync\n\n\nThe --sync option can be combined with any dependency groups related options to synchronize the environment with specific groups. Note that extras are separate. Any extras not selected for install are always removed, regardless of --sync.\n\npoetry install --without dev --sync\npoetry install --with docs --sync\npoetry install --only dev\n\nThe --sync option replaces the --remove-untracked option which is now deprecated.\nLayering optional groups\n\nWhen you omit the --sync option, you can install any subset of optional groups without removing those that are already installed. This is very useful, for example, in multi-stage Docker builds, where you run poetry install multiple times in different build stages.\n\nFooter\n\nPython packaging and dependency management made easy.\n\nGitHub\nDiscord\nDOCUMENTATION\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\n GITHUB\nProject\nIssues\nDiscussions\nOTHER PROJECTS\npoetry-core\ninstall.python-poetry.org\nBundle plugin\nExport plugin\n\nCopyright © 2018-2024. All Rights Reserved.\nPowered by"
  },
  {
    "title": "Basic usage | 1.7 | Documentation | Poetry - Python dependency management and packaging made easy",
    "url": "https://python-poetry.org/docs/1.7/basic-usage/",
    "html": "Home\nSearch\n1.7\nUse dark mode\nDOCUMENTATION\nBLOG\nHISTORY\nIntroduction\nBasic usage\nProject setup\nInitialising a pre-existing project\nSpecifying dependencies\nUsing your virtual environment\nUsing poetry run\nActivating the virtual environment\nVersion constraints\nInstalling dependencies\nInstalling without poetry.lock\nInstalling with poetry.lock\nCommitting your poetry.lock file to version control\nInstalling dependencies only\nUpdating dependencies to their latest versions\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\nBasic usage\n\nFor the basic usage introduction we will be installing pendulum, a datetime library. If you have not yet installed Poetry, refer to the Introduction chapter.\n\nProject setup\n\nFirst, let’s create our new project, let’s call it poetry-demo:\n\npoetry new poetry-demo\n\n\nThis will create the poetry-demo directory with the following content:\n\npoetry-demo\n├── pyproject.toml\n├── README.md\n├── poetry_demo\n│   └── __init__.py\n└── tests\n    └── __init__.py\n\n\nThe pyproject.toml file is what is the most important here. This will orchestrate your project and its dependencies. For now, it looks like this:\n\n[tool.poetry]\nname = \"poetry-demo\"\nversion = \"0.1.0\"\ndescription = \"\"\nauthors = [\"Sébastien Eustace <sebastien@eustace.io>\"]\nreadme = \"README.md\"\npackages = [{include = \"poetry_demo\"}]\n\n[tool.poetry.dependencies]\npython = \"^3.7\"\n\n\n[build-system]\nrequires = [\"poetry-core\"]\nbuild-backend = \"poetry.core.masonry.api\"\n\n\nPoetry assumes your package contains a package with the same name as tool.poetry.name located in the root of your project. If this is not the case, populate tool.poetry.packages to specify your packages and their locations.\n\nSimilarly, the traditional MANIFEST.in file is replaced by the tool.poetry.readme, tool.poetry.include, and tool.poetry.exclude sections. tool.poetry.exclude is additionally implicitly populated by your .gitignore. For full documentation on the project format, see the pyproject section of the documentation.\n\nPoetry will require you to explicitly specify what versions of Python you intend to support, and its universal locking will guarantee that your project is installable (and all dependencies claim support for) all supported Python versions.\n\nInitialising a pre-existing project\n\nInstead of creating a new project, Poetry can be used to ‘initialise’ a pre-populated directory. To interactively create a pyproject.toml file in directory pre-existing-project:\n\ncd pre-existing-project\npoetry init\n\nSpecifying dependencies\n\nIf you want to add dependencies to your project, you can specify them in the tool.poetry.dependencies section.\n\n[tool.poetry.dependencies]\npendulum = \"^2.1\"\n\n\nAs you can see, it takes a mapping of package names and version constraints.\n\nPoetry uses this information to search for the right set of files in package “repositories” that you register in the tool.poetry.source section, or on PyPI by default.\n\nAlso, instead of modifying the pyproject.toml file by hand, you can use the add command.\n\n$ poetry add pendulum\n\n\nIt will automatically find a suitable version constraint and install the package and sub-dependencies.\n\nPoetry supports a rich dependency specification syntax, including caret, tilde, wildcard, inequality and multiple constraints requirements.\n\nUsing your virtual environment\n\nBy default, Poetry creates a virtual environment in {cache-dir}/virtualenvs. You can change the cache-dir value by editing the Poetry configuration. Additionally, you can use the virtualenvs.in-project configuration variable to create virtual environments within your project directory.\n\nThere are several ways to run commands within this virtual environment.\n\nExternal virtual environment management\n\nPoetry will detect and respect an existing virtual environment that has been externally activated. This is a powerful mechanism that is intended to be an alternative to Poetry’s built-in, simplified environment management.\n\nTo take advantage of this, simply activate a virtual environment using your preferred method or tooling, before running any Poetry commands that expect to manipulate an environment.\n\nUsing poetry run\n\nTo run your script simply use poetry run python your_script.py. Likewise if you have command line tools such as pytest or black you can run them using poetry run pytest.\n\nActivating the virtual environment\n\nThe easiest way to activate the virtual environment is to create a nested shell with poetry shell.\n\nTo deactivate the virtual environment and exit this new shell type exit. To deactivate the virtual environment without leaving the shell use deactivate.\n\nWhy a nested shell?\n\nChild processes inherit their environment from their parents, but do not share them. As such, any modifications made by a child process is not persisted after the child process exits. A Python application (Poetry), being a child process, cannot modify the environment of the shell that it has been called from such that an activated virtual environment remains active after the Poetry command has completed execution.\n\nTherefore, Poetry has to create a sub-shell with the virtual environment activated in order for the subsequent commands to run from within the virtual environment.\n\nIf you’d like to prevent poetry shell from modifying your shell prompt on virtual environment activation, you should set VIRTUAL_ENV_DISABLE_PROMPT=1 as an environment variable before running the command.\n\nAlternatively, to avoid creating a new shell, you can manually activate the virtual environment by running source {path_to_venv}/bin/activate ({path_to_venv}\\Scripts\\activate.ps1 in PowerShell). To get the path to your virtual environment run poetry env info --path. You can also combine these into a one-liner, such as source $(poetry env info --path)/bin/activate (& ((poetry env info --path) + \"\\Scripts\\activate.ps1\") in Powershell).\n\nTo deactivate this virtual environment simply use deactivate.\n\n\tPOSIX SHELL\tWINDOWS (POWERSHELL)\tEXIT/DEACTIVATE\nSub-shell\tpoetry shell\tpoetry shell\texit\nManual Activation\tsource {path_to_venv}/bin/activate\t{path_to_venv}\\Scripts\\activate.ps1\tdeactivate\nOne-liner\tsource $(poetry env info --path)/bin/activate\t& ((poetry env info --path) + \"\\Scripts\\activate.ps1\")\tdeactivate\nVersion constraints\n\nIn our example, we are requesting the pendulum package with the version constraint ^2.1. This means any version greater or equal to 2.1.0 and less than 3.0.0 (>=2.1.0 <3.0.0).\n\nPlease read Dependency specification for more in-depth information on versions, how versions relate to each other, and on the different ways you can specify dependencies.\n\nHow does Poetry download the right files?\n\nWhen you specify a dependency in pyproject.toml, Poetry first takes the name of the package that you have requested and searches for it in any repository you have registered using the repositories key. If you have not registered any extra repositories, or it does not find a package with that name in the repositories you have specified, it falls back to PyPI.\n\nWhen Poetry finds the right package, it then attempts to find the best match for the version constraint you have specified.\n\nInstalling dependencies\n\nTo install the defined dependencies for your project, just run the install command.\n\npoetry install\n\n\nWhen you run this command, one of two things may happen:\n\nInstalling without poetry.lock\n\nIf you have never run the command before and there is also no poetry.lock file present, Poetry simply resolves all dependencies listed in your pyproject.toml file and downloads the latest version of their files.\n\nWhen Poetry has finished installing, it writes all the packages and their exact versions that it downloaded to the poetry.lock file, locking the project to those specific versions. You should commit the poetry.lock file to your project repo so that all people working on the project are locked to the same versions of dependencies (more below).\n\nInstalling with poetry.lock\n\nThis brings us to the second scenario. If there is already a poetry.lock file as well as a pyproject.toml file when you run poetry install, it means either you ran the install command before, or someone else on the project ran the install command and committed the poetry.lock file to the project (which is good).\n\nEither way, running install when a poetry.lock file is present resolves and installs all dependencies that you listed in pyproject.toml, but Poetry uses the exact versions listed in poetry.lock to ensure that the package versions are consistent for everyone working on your project. As a result you will have all dependencies requested by your pyproject.toml file, but they may not all be at the very latest available versions (some dependencies listed in the poetry.lock file may have released newer versions since the file was created). This is by design, it ensures that your project does not break because of unexpected changes in dependencies.\n\nCommitting your poetry.lock file to version control\nAs an application developer\n\nApplication developers commit poetry.lock to get more reproducible builds.\n\nCommitting this file to VC is important because it will cause anyone who sets up the project to use the exact same versions of the dependencies that you are using. Your CI server, production machines, other developers in your team, everything and everyone runs on the same dependencies, which mitigates the potential for bugs affecting only some parts of the deployments. Even if you develop alone, in six months when reinstalling the project you can feel confident the dependencies installed are still working even if your dependencies released many new versions since then. (See note below about using the update command.)\n\nIf you have added the recommended [build-system] section to your project’s pyproject.toml then you can successfully install your project and its dependencies into a virtual environment using a command like pip install -e .. However, pip will not use the lock file to determine dependency versions as the poetry-core build system is intended for library developers (see next section).\nAs a library developer\n\nLibrary developers have more to consider. Your users are application developers, and your library will run in a Python environment you don’t control.\n\nThe application ignores your library’s lock file. It can use whatever dependency version meets the constraints in your pyproject.toml. The application will probably use the latest compatible dependency version. If your library’s poetry.lock falls behind some new dependency version that breaks things for your users, you’re likely to be the last to find out about it.\n\nA simple way to avoid such a scenario is to omit the poetry.lock file. However, by doing so, you sacrifice reproducibility and performance to a certain extent. Without a lockfile, it can be difficult to find the reason for failing tests, because in addition to obvious code changes an unnoticed library update might be the culprit. Further, Poetry will have to lock before installing a dependency if poetry.lock has been omitted. Depending on the number of dependencies, locking may take a significant amount of time.\n\nIf you do not want to give up the reproducibility and performance benefits, consider a regular refresh of poetry.lock to stay up-to-date and reduce the risk of sudden breakage for users.\n\nInstalling dependencies only\n\nThe current project is installed in editable mode by default.\n\nIf you want to install the dependencies only, run the install command with the --no-root flag:\n\npoetry install --no-root\n\nUpdating dependencies to their latest versions\n\nAs mentioned above, the poetry.lock file prevents you from automatically getting the latest versions of your dependencies. To update to the latest versions, use the update command. This will fetch the latest matching versions (according to your pyproject.toml file) and update the lock file with the new versions. (This is equivalent to deleting the poetry.lock file and running install again.)\n\nPoetry will display a Warning when executing an install command if poetry.lock and pyproject.toml are not synchronized.\nFooter\n\nPython packaging and dependency management made easy.\n\nGitHub\nDiscord\nDOCUMENTATION\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\n GITHUB\nProject\nIssues\nDiscussions\nOTHER PROJECTS\npoetry-core\ninstall.python-poetry.org\nBundle plugin\nExport plugin\n\nCopyright © 2018-2024. All Rights Reserved.\nPowered by"
  },
  {
    "title": "pre-commit hooks | main | Documentation | Poetry - Python dependency management and packaging made easy",
    "url": "https://python-poetry.org/docs/main/pre-commit-hooks/",
    "html": "Home\nSearch\nmain\nUse dark mode\nDOCUMENTATION\nBLOG\nHISTORY\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\npoetry-check\nArguments\npoetry-lock\nArguments\npoetry-export\nArguments\npoetry-install\nArguments\nUsage\nFAQ\nWhy does pre-commit autoupdate not update to the latest version?\npre-commit hooks\n\npre-commit is a framework for building and running git hooks. See the official documentation for more information: pre-commit.com\n\nThis document provides a list of available pre-commit hooks provided by Poetry.\n\nIf you specify the args: for a hook in your .pre-commit-config.yaml, the defaults are overwritten. You must fully specify all arguments for your hook if you make use of args:.\nIf the pyproject.toml file is not in the root directory, you can specify args: [\"-C\", \"./subdirectory\"].\npoetry-check\n\nThe poetry-check hook calls the poetry check command to make sure the poetry configuration does not get committed in a broken state.\n\nArguments\n\nThe hook takes the same arguments as the poetry command. For more information see the check command.\n\npoetry-lock\n\nThe poetry-lock hook calls the poetry lock command to make sure the lock file is up-to-date when committing changes.\n\nArguments\n\nThe hook takes the same arguments as the poetry command. For more information see the lock command.\n\npoetry-export\n\nThe poetry-export hook calls the poetry export command to sync your requirements.txt file with your current dependencies.\n\nThis hook is provided by the Export Poetry Plugin.\nIt is recommended to run the poetry-lock hook or poetry-check with argument --lock prior to this one.\nArguments\n\nThe hook takes the same arguments as the poetry command. For more information see the export command.\n\nThe default arguments are args: [\"-f\", \"requirements.txt\", \"-o\", \"requirements.txt\"], which will create/update the requirements.txt file in the current working directory.\n\nYou may add verbose: true in your .pre-commit-config.yaml in order to output to the console:\n\nhooks:\n-   id: poetry-export\n    args: [\"-f\", \"requirements.txt\"]\n    verbose: true\n\n\nAlso, --dev can be added to args to write dev-dependencies to requirements.txt:\n\nhooks:\n-   id: poetry-export\n    args: [\"--dev\", \"-f\", \"requirements.txt\", \"-o\", \"requirements.txt\"]\n\npoetry-install\n\nThe poetry-install hook calls the poetry install command to make sure all locked packages are installed. In order to install this hook, you either need to specify default_install_hook_types, or you have to install it via pre-commit install --install-hooks -t post-checkout -t post-merge.\n\nArguments\n\nThe hook takes the same arguments as the poetry command. For more information see the install command.\n\nUsage\n\nFor more information on how to use pre-commit please see the official documentation.\n\nA minimalistic .pre-commit-config.yaml example:\n\nrepos:\n-   repo: https://github.com/python-poetry/poetry\n    rev: ''  # add version here\n    hooks:\n    -   id: poetry-check\n    -   id: poetry-lock\n    -   id: poetry-export\n    -   id: poetry-install\n\n\nA .pre-commit-config.yaml example for a monorepo setup or if the pyproject.toml file is not in the root directory:\n\nrepos:\n-   repo: https://github.com/python-poetry/poetry\n    rev: ''  # add version here\n    hooks:\n    -   id: poetry-check\n        args: [\"-C\", \"./subdirectory\"]\n    -   id: poetry-lock\n        args: [\"-C\", \"./subdirectory\"]\n    -   id: poetry-export\n        args: [\"-C\", \"./subdirectory\", \"-f\", \"requirements.txt\", \"-o\", \"./subdirectory/requirements.txt\"]\n    -   id: poetry-install\n        args: [\"-C\", \"./subdirectory\"]\n\nFAQ\nWhy does pre-commit autoupdate not update to the latest version?\n\npre-commit autoupdate updates the rev for each repository defined in your .pre-commit-config.yaml to the latest available tag in the default branch.\n\nPoetry follows a branching strategy where the default branch is the active development branch, and fixes get backported to stable branches. New tags are assigned in these stable branches.\n\npre-commit does not support such a branching strategy and has decided to not implement an option, either on the user’s side or the hook author’s side, to define a branch for looking up the latest available tag.\n\nThus, pre-commit autoupdate is not usable for the hooks described here.\n\nYou can avoid changing the rev to an unexpected value by using the --repo parameter (may be specified multiple times), to explicitly list repositories that should be updated. An option to explicitly exclude repositories will not be implemented into pre-commit.\n\nFooter\n\nPython packaging and dependency management made easy.\n\nGitHub\nDiscord\nDOCUMENTATION\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\n GITHUB\nProject\nIssues\nDiscussions\nOTHER PROJECTS\npoetry-core\ninstall.python-poetry.org\nBundle plugin\nExport plugin\n\nCopyright © 2018-2024. All Rights Reserved.\nPowered by"
  },
  {
    "title": "FAQ | main | Documentation | Poetry - Python dependency management and packaging made easy",
    "url": "https://python-poetry.org/docs/main/faq/",
    "html": "Home\nSearch\nmain\nUse dark mode\nDOCUMENTATION\nBLOG\nHISTORY\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\nWhy is the dependency resolution process slow?\nWhat kind of versioning scheme does Poetry use for itself?\nWhy does Poetry not adhere to semantic versioning?\nAre unbound version constraints a bad idea?\nIs tox supported?\nIs Nox supported?\nI don’t want Poetry to manage my virtual environments. Can I disable it?\nWhy is Poetry telling me that the current project’s supported Python range is not compatible with one or more packages' Python requirements?\nWhy does Poetry enforce PEP 440 versions?\nPoetry busts my Docker cache because it requires me to COPY my source files in before installing 3rd party dependencies\nMy requests are timing out!\npre-commit hooks\nFAQ\nWhy is the dependency resolution process slow?\n\nWhile the dependency resolver at the heart of Poetry is highly optimized and should be fast enough for most cases, with certain sets of dependencies it can take time to find a valid solution.\n\nThis is due to the fact that not all libraries on PyPI have properly declared their metadata and, as such, they are not available via the PyPI JSON API. At this point, Poetry has no choice but to download the packages and inspect them to get the necessary information. This is an expensive operation, both in bandwidth and time, which is why it seems this is a long process.\n\nAt the moment there is no way around it. However, if you notice that Poetry is downloading many versions of a single package, you can lessen the workload by constraining that one package in your pyproject.toml more narrowly. That way Poetry does not have to sift through so many versions of it, which may speed up the locking process considerably in some cases.\n\nOnce Poetry has cached the releases' information on your machine, the dependency resolution process will be much faster.\nWhat kind of versioning scheme does Poetry use for itself?\n\nPoetry uses “major.minor.micro” version identifiers as mentioned in PEP 440.\n\nVersion bumps are done similar to Python’s versioning:\n\nA major version bump (incrementing the first number) is only done for breaking changes if a deprecation cycle is not possible and many users have to perform some manual steps to migrate from one version to the next one.\nA minor version bump (incrementing the second number) may include new features as well as new deprecations and drop features deprecated in an earlier minor release.\nA micro version bump (incrementing the third number) usually only includes bug fixes. Deprecated features will not be dropped in a micro release.\nWhy does Poetry not adhere to semantic versioning?\n\nBecause of its large user base, even small changes not considered relevant by most users can turn out to be a breaking change for some users in hindsight. Sticking to strict semantic versioning and (almost) always bumping the major version instead of the minor version does not seem desirable since the minor version will not carry any meaning anymore.\n\nAre unbound version constraints a bad idea?\n\nA version constraint without an upper bound such as * or >=3.4 will allow updates to any future version of the dependency. This includes major versions breaking backward compatibility.\n\nOnce a release of your package is published, you cannot tweak its dependencies anymore in case a dependency breaks BC – you have to do a new release but the previous one stays broken. (Users can still work around the broken dependency by restricting it by themselves.)\n\nTo avoid such issues you can define an upper bound on your constraints, which you can increase in a new release after testing that your package is compatible with the new major version of your dependency.\n\nFor example instead of using >=3.4 you can use ^3.4 which allows all versions <4.0. The ^ operator works very well with libraries following semantic versioning.\n\nHowever, when defining an upper bound, users of your package are not able to update a dependency beyond the upper bound even if it does not break anything and is fully compatible with your package. You have to release a new version of your package with an increased upper bound first.\n\nIf your package will be used as a library in other packages, it might be better to avoid upper bounds and thus unnecessary dependency conflicts (unless you already know for sure that the next release of the dependency will break your package). If your package will be used as an application, it might be worth to define an upper bound.\n\nIs tox supported?\n\nYes. Provided that you are using tox >= 4, you can use it in combination with the PEP 517 compliant build system provided by Poetry. (With tox 3, you have to set the isolated build option.)\n\nSo, in your pyproject.toml file, add this section if it does not already exist:\n\n[build-system]\nrequires = [\"poetry-core>=1.0.0\"]\nbuild-backend = \"poetry.core.masonry.api\"\n\n\ntox can be configured in multiple ways. It depends on what should be the code under test and which dependencies should be installed.\n\nUse case #1\n[tox]\n\n[testenv]\ndeps =\n    pytest\ncommands =\n    pytest tests/ --import-mode importlib\n\n\ntox will create an sdist package of the project and uses pip to install it in a fresh environment. Thus, dependencies are resolved by pip.\n\nUse case #2\n[tox]\n\n[testenv]\nallowlist_externals = poetry\ncommands_pre =\n    poetry install --no-root --sync\ncommands =\n    poetry run pytest tests/ --import-mode importlib\n\n\ntox will create an sdist package of the project and uses pip to install it in a fresh environment. Thus, dependencies are resolved by pip in the first place. But afterward we run Poetry, which will install the locked dependencies into the environment.\n\nUse case #3\n[tox]\n\n[testenv]\nskip_install = true\nallowlist_externals = poetry\ncommands_pre =\n    poetry install\ncommands =\n    poetry run pytest tests/ --import-mode importlib\n\n\ntox will not do any install. Poetry installs all the dependencies and the current package in editable mode. Thus, tests are running against the local files and not the built and installed package.\n\nNote about credentials\n\nNote that tox does not forward the environment variables of your current shell session by default. This may cause Poetry to not be able to install dependencies in the tox environments if you have configured credentials using the system keyring on Linux systems or using environment variables in general. You can use the passenv configuration option to forward the required variables explicitly or passenv = \"*\" to forward all of them. Linux systems may require forwarding the DBUS_SESSION_BUS_ADDRESS variable to allow access to the system keyring, though this may vary between desktop environments.\n\nAlternatively, you can disable the keyring completely:\n\npoetry config keyring.enabled false\n\n\nBe aware that this will cause Poetry to write passwords to plaintext config files. You will need to set the credentials again after changing this setting.\n\nIs Nox supported?\n\nUse the nox-poetry package to install locked versions of dependencies specified in poetry.lock into Nox sessions.\n\nI don’t want Poetry to manage my virtual environments. Can I disable it?\n\nWhile Poetry automatically creates virtual environments to always work isolated from the global Python installation, there are rare scenarios where the use a Poetry managed virtual environment is not possible or preferred.\n\nIn this case, you can disable this feature by setting the virtualenvs.create setting to false:\n\npoetry config virtualenvs.create false\n\n\nThe recommended best practice, including when installing an application within a container, is to make use of a virtual environment. This can also be managed by another tool.\n\nThe Poetry team strongly encourages the use of a virtual environment.\n\nWhy is Poetry telling me that the current project’s supported Python range is not compatible with one or more packages' Python requirements?\n\nUnlike pip, Poetry doesn’t resolve for just the Python in the current environment. Instead it makes sure that a dependency is resolvable within the given Python version range in pyproject.toml.\n\nAssume you have the following pyproject.toml:\n\n[tool.poetry.dependencies]\npython = \"^3.7\"\n\n\nThis means your project aims to be compatible with any Python version >=3.7,<4.0. Whenever you try to add a dependency whose Python requirement doesn’t match the whole range Poetry will tell you this, e.g.:\n\nThe current project's supported Python range (>=3.7.0,<4.0.0) is not compatible with some of the required packages Python requirement:\n    - scipy requires Python >=3.7,<3.11, so it will not be satisfied for Python >=3.11,<4.0.0\n\n\nUsually you will want to match the supported Python range of your project with the upper bound of the failing dependency. Alternatively you can tell Poetry to install this dependency only for a specific range of Python versions, if you know that it’s not needed in all versions.\n\nWhy does Poetry enforce PEP 440 versions?\n\nThis is done to be compliant with the broader Python ecosystem.\n\nFor example, if Poetry builds a distribution for a project that uses a version that is not valid according to PEP 440, third party tools will be unable to parse the version correctly.\n\nPoetry busts my Docker cache because it requires me to COPY my source files in before installing 3rd party dependencies\n\nBy default, running poetry install ... requires you to have your source files present (both the “root” package and any directory path dependencies you might have). This interacts poorly with Docker’s caching mechanisms because any change to a source file will make any layers (subsequent commands in your Dockerfile) re-run. For example, you might have a Dockerfile that looks something like this:\n\nFROM python\nCOPY pyproject.toml poetry.lock .\nCOPY src/ ./src\nRUN pip install poetry && poetry install --only main\n\n\nAs soon as any source file changes, the cache for the RUN layer will be invalidated, which forces all 3rd party dependencies (likely the slowest step out of these) to be installed again if you changed any files in src/.\n\nTo avoid this cache busting you can split this into two steps:\n\nInstall 3rd party dependencies.\nCopy over your source code and install just the source code.\n\nThis might look something like this:\n\nFROM python\nCOPY pyproject.toml poetry.lock .\nRUN pip install poetry && poetry install --only main --no-root --no-directory\nCOPY src/ ./src\nRUN poetry install --only main\n\n\nThe two key options we are using here are --no-root (skips installing the project source) and --no-directory (skips installing any local directory path dependencies, you can omit this if you don’t have any). More information on the options available for poetry install.\n\nMy requests are timing out!\n\nPoetry’s default HTTP request timeout is 15 seconds, the same as pip. Similar to PIP_REQUESTS_TIMEOUT, the experimental environment variable POETRY_REQUESTS_TIMEOUT can be set to alter this value.\n\nFooter\n\nPython packaging and dependency management made easy.\n\nGitHub\nDiscord\nDOCUMENTATION\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\n GITHUB\nProject\nIssues\nDiscussions\nOTHER PROJECTS\npoetry-core\ninstall.python-poetry.org\nBundle plugin\nExport plugin\n\nCopyright © 2018-2024. All Rights Reserved.\nPowered by"
  },
  {
    "title": "Community | main | Documentation | Poetry - Python dependency management and packaging made easy",
    "url": "https://python-poetry.org/docs/main/community/",
    "html": "Home\nSearch\nmain\nUse dark mode\nDOCUMENTATION\nBLOG\nHISTORY\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nBadge\nFAQ\npre-commit hooks\nCommunity\nBadge\n\nFor any projects using Poetry, you may add its official badge somewhere prominent like the README.\n\nMarkdown\n\n[![Poetry](https://img.shields.io/endpoint?url=https://python-poetry.org/badge/v0.json)](https://python-poetry.org/)\n\n\nreStructuredText\n\n.. image:: https://img.shields.io/endpoint?url=https://python-poetry.org/badge/v0.json\n   :alt: Poetry\n   :target: https://python-poetry.org/\n\nFooter\n\nPython packaging and dependency management made easy.\n\nGitHub\nDiscord\nDOCUMENTATION\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\n GITHUB\nProject\nIssues\nDiscussions\nOTHER PROJECTS\npoetry-core\ninstall.python-poetry.org\nBundle plugin\nExport plugin\n\nCopyright © 2018-2024. All Rights Reserved.\nPowered by"
  },
  {
    "title": "The pyproject.toml file | main | Documentation | Poetry - Python dependency management and packaging made easy",
    "url": "https://python-poetry.org/docs/main/pyproject/",
    "html": "Home\nSearch\nmain\nUse dark mode\nDOCUMENTATION\nBLOG\nHISTORY\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\npackage-mode\nname\nversion\ndescription\nlicense\nauthors\nmaintainers\nreadme\nhomepage\nrepository\ndocumentation\nkeywords\nclassifiers\npackages\ninclude and exclude\ndependencies and dependency groups\nscripts\nextras\nplugins\nurls\nPoetry and PEP-517\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\nThe pyproject.toml file\n\nThe tool.poetry section of the pyproject.toml file is composed of multiple sections.\n\npackage-mode\n\nWhether Poetry operates in package mode (default) or not. Optional\n\nSee basic usage for more information.\n\npackage-mode = false\n\nname\n\nThe name of the package. Required in package mode\n\nThis should be a valid name as defined by PEP 508.\n\nname = \"my-package\"\n\nversion\n\nThe version of the package. Required in package mode\n\nThis should be a valid PEP 440 string.\n\nversion = \"0.1.0\"\n\nIf you would like to use semantic versioning for your project, please see here.\ndescription\n\nA short description of the package. Required in package mode\n\ndescription = \"A short description of the package.\"\n\nlicense\n\nThe license of the package.\n\nThe recommended notation for the most common licenses is (alphabetical):\n\nApache-2.0\nBSD-2-Clause\nBSD-3-Clause\nBSD-4-Clause\nGPL-2.0-only\nGPL-2.0-or-later\nGPL-3.0-only\nGPL-3.0-or-later\nLGPL-2.1-only\nLGPL-2.1-or-later\nLGPL-3.0-only\nLGPL-3.0-or-later\nMIT\n\nOptional, but it is highly recommended to supply this. More identifiers are listed at the SPDX Open Source License Registry.\n\nlicense = \"MIT\"\n\nIf your project is proprietary and does not use a specific licence, you can set this value as Proprietary.\nauthors\n\nThe authors of the package. Required in package mode\n\nThis is a list of authors and should contain at least one author. Authors must be in the form name <email>.\n\nauthors = [\n    \"Sébastien Eustace <sebastien@eustace.io>\",\n]\n\nmaintainers\n\nThe maintainers of the package. Optional\n\nThis is a list of maintainers and should be distinct from authors. Maintainers may contain an email and be in the form name <email>.\n\nmaintainers = [\n    \"John Smith <johnsmith@example.org>\",\n    \"Jane Smith <janesmith@example.org>\",\n]\n\nreadme\n\nA path, or list of paths corresponding to the README file(s) of the package. Optional\n\nThe file(s) can be of any format, but if you intend to publish to PyPI keep the recommendations for a PyPI-friendly README in mind. README paths are implicitly relative to pyproject.toml.\n\nWhether paths are case-sensitive follows platform defaults, but it is recommended to keep cases.\n\nTo be specific, you can set readme = \"rEaDmE.mD\" for README.md on macOS and Windows, but Linux users can’t poetry install after cloning your repo. This is because macOS and Windows are case-insensitive and case-preserving.\n\nThe contents of the README file(s) are used to populate the Description field of your distribution’s metadata (similar to long_description in setuptools). When multiple files are specified they are concatenated with newlines.\n\n[tool.poetry]\n# ...\nreadme = \"README.md\"\n\n[tool.poetry]\n# ...\nreadme = [\"docs/README1.md\", \"docs/README2.md\"]\n\nhomepage\n\nAn URL to the website of the project. Optional\n\nhomepage = \"https://python-poetry.org/\"\n\nrepository\n\nAn URL to the repository of the project. Optional\n\nrepository = \"https://github.com/python-poetry/poetry\"\n\ndocumentation\n\nAn URL to the documentation of the project. Optional\n\ndocumentation = \"https://python-poetry.org/docs/\"\n\nkeywords\n\nA list of keywords that the package is related to. Optional\n\nkeywords = [\"packaging\", \"poetry\"]\n\nclassifiers\n\nA list of PyPI trove classifiers that describe the project. Optional\n\n[tool.poetry]\n# ...\nclassifiers = [\n    \"Topic :: Software Development :: Build Tools\",\n    \"Topic :: Software Development :: Libraries :: Python Modules\"\n]\n\n\nNote that Python classifiers are still automatically added for you and are determined by your python requirement.\n\nThe license property will also set the License classifier automatically.\n\npackages\n\nA list of packages and modules to include in the final distribution.\n\nIf your project structure differs from the standard one supported by poetry, you can specify the packages you want to include in the final distribution.\n\n[tool.poetry]\n# ...\npackages = [\n    { include = \"my_package\" },\n    { include = \"extra_package/**/*.py\" },\n]\n\n\nIf your package is stored inside a “lib” directory, you must specify it:\n\n[tool.poetry]\n# ...\npackages = [\n    { include = \"my_package\", from = \"lib\" },\n]\n\n\nThe to parameter is designed to specify the relative destination path where the package will be located upon installation. This allows for greater control over the organization of packages within your project’s structure.\n\n[tool.poetry]\n# ...\npackages = [\n    { include = \"my_package\", from = \"lib\", to = \"target_package\" },\n]\n\n\nIf you want to restrict a package to a specific build format you can specify it by using format:\n\n[tool.poetry]\n# ...\npackages = [\n    { include = \"my_package\" },\n    { include = \"my_other_package\", format = \"sdist\" },\n]\n\n\nFrom now on, only the sdist build archive will include the my_other_package package.\n\nUsing packages disables the package auto-detection feature meaning you have to explicitly specify the “default” package.\n\nFor instance, if you have a package named my_package and you want to also include another package named extra_package, you will need to specify my_package explicitly:\n\npackages = [\n    { include = \"my_package\" },\n    { include = \"extra_package\" },\n]\n\n\nPoetry is clever enough to detect Python subpackages.\n\nThus, you only have to specify the directory where your root package resides.\n\ninclude and exclude\n\nA list of patterns that will be included in the final package.\n\nYou can explicitly specify to Poetry that a set of globs should be ignored or included for the purposes of packaging. The globs specified in the exclude field identify a set of files that are not included when a package is built.\n\nIf a VCS is being used for a package, the exclude field will be seeded with the VCS’ ignore settings (.gitignore for git for example).\n\nExplicitly declaring entries in include will negate VCS' ignore settings.\n[tool.poetry]\n# ...\ninclude = [\"CHANGELOG.md\"]\n\n\nYou can also specify the formats for which these patterns have to be included, as shown here:\n\n[tool.poetry]\n# ...\ninclude = [\n    { path = \"tests\", format = \"sdist\" },\n    { path = \"for_wheel.txt\", format = [\"sdist\", \"wheel\"] }\n]\n\n\nIf no format is specified, include defaults to only sdist.\n\nIn contrast, exclude defaults to both sdist and wheel.\n\nexclude = [\"my_package/excluded.py\"]\n\ndependencies and dependency groups\n\nPoetry is configured to look for dependencies on PyPI by default. Only the name and a version string are required in this case.\n\n[tool.poetry.dependencies]\nrequests = \"^2.13.0\"\n\n\nIf you want to use a private repository, you can add it to your pyproject.toml file, like so:\n\n[[tool.poetry.source]]\nname = \"private\"\nurl = \"http://example.com/simple\"\n\n\nIf you have multiple repositories configured, you can explicitly tell poetry where to look for a specific package:\n\n[tool.poetry.dependencies]\nrequests = { version = \"^2.13.0\", source = \"private\" }\n\n\nBe aware that declaring the python version for which your package is compatible is mandatory:\n\n[tool.poetry.dependencies]\npython = \"^3.7\"\n\n\nYou can organize your dependencies in groups to manage them in a more granular way.\n\n[tool.poetry.group.test.dependencies]\npytest = \"*\"\n\n[tool.poetry.group.docs.dependencies]\nmkdocs = \"*\"\n\n\nSee Dependency groups for a more in-depth look at how to manage dependency groups and Dependency specification for more information on other keys and specifying version ranges.\n\nscripts\n\nThis section describes the scripts or executables that will be installed when installing the package\n\n[tool.poetry.scripts]\nmy_package_cli = 'my_package.console:run'\n\n\nHere, we will have the my_package_cli script installed which will execute the run function in the console module in the my_package package.\n\nWhen a script is added or updated, run poetry install to make them available in the project’s virtualenv.\nextras\n\nPoetry supports extras to allow expression of:\n\noptional dependencies, which enhance a package, but are not required; and\nclusters of optional dependencies.\n[tool.poetry]\nname = \"awesome\"\n\n[tool.poetry.dependencies]\n# These packages are mandatory and form the core of this package’s distribution.\nmandatory = \"^1.0\"\n\n# A list of all of the optional dependencies, some of which are included in the\n# below `extras`. They can be opted into by apps.\npsycopg2 = { version = \"^2.9\", optional = true }\nmysqlclient = { version = \"^1.3\", optional = true }\n\n[tool.poetry.extras]\nmysql = [\"mysqlclient\"]\npgsql = [\"psycopg2\"]\ndatabases = [\"mysqlclient\", \"psycopg2\"]\n\n\nWhen installing packages with Poetry, you can specify extras by using the -E|--extras option:\n\npoetry install --extras \"mysql pgsql\"\npoetry install -E mysql -E pgsql\n\n\nAny extras you don’t specify will be removed. Note this behavior is different from optional dependency groups not selected for install, e.g. those not specified via install --with.\n\nYou can install all extras with the --all-extras option:\n\npoetry install --all-extras\n\n\nNote that install --extras and the variations mentioned above (--all-extras, --extras foo, etc.) only work on dependencies defined in the current project. If you want to install extras defined by dependencies, you’ll have to express that in the dependency itself:\n\n[tool.poetry.dependencies]\npandas = {version=\"^2.2.1\", extras=[\"computation\", \"performance\"]}\n\n[tool.poetry.group.dev.dependencies]\nfastapi = {version=\"^0.92.0\", extras=[\"all\"]}\n\n\nWhen installing or specifying Poetry-built packages, the extras defined in this section can be activated as described in PEP 508.\n\nFor example, when installing the package using pip, the dependencies required by the databases extra can be installed as shown below.\n\npip install awesome[databases]\n\n\nThe dependencies specified for each extra must already be defined as project dependencies.\n\nDependencies listed in dependency groups cannot be specified as extras.\n\nplugins\n\nPoetry supports arbitrary plugins, which are exposed as the ecosystem-standard entry points and discoverable using importlib.metadata. This is similar to (and compatible with) the entry points feature of setuptools. The syntax for registering a plugin is:\n\n[tool.poetry.plugins] # Optional super table\n\n[tool.poetry.plugins.\"A\"]\nB = \"C:D\"\n\n\nWhich are:\n\nA - type of the plugin, for example poetry.plugin or flake8.extension\nB - name of the plugin\nC - python module import path\nD - the entry point of the plugin (a function or class)\n\nExample (from poetry-plugin-export):\n\n[tool.poetry.plugins.\"poetry.application.plugin\"]\nexport = \"poetry_plugin_export.plugins:ExportApplicationPlugin\"\n\nurls\n\nIn addition to the basic urls (homepage, repository and documentation), you can specify any custom url in the urls section.\n\n[tool.poetry.urls]\n\"Bug Tracker\" = \"https://github.com/python-poetry/poetry/issues\"\n\n\nIf you publish your package on PyPI, they will appear in the Project Links section.\n\nPoetry and PEP-517\n\nPEP-517 introduces a standard way to define alternative build systems to build a Python project.\n\nPoetry is compliant with PEP-517, by providing a lightweight core library, so if you use Poetry to manage your Python project you should reference it in the build-system section of the pyproject.toml file like so:\n\n[build-system]\nrequires = [\"poetry-core>=1.0.0\"]\nbuild-backend = \"poetry.core.masonry.api\"\n\nWhen using the new or init command this section will be automatically added.\nIf your pyproject.toml file still references poetry directly as a build backend, you should update it to reference poetry-core instead.\nFooter\n\nPython packaging and dependency management made easy.\n\nGitHub\nDiscord\nDOCUMENTATION\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\n GITHUB\nProject\nIssues\nDiscussions\nOTHER PROJECTS\npoetry-core\ninstall.python-poetry.org\nBundle plugin\nExport plugin\n\nCopyright © 2018-2024. All Rights Reserved.\nPowered by"
  },
  {
    "title": "Contributing to Poetry | main | Documentation | Poetry - Python dependency management and packaging made easy",
    "url": "https://python-poetry.org/docs/main/contributing/",
    "html": "Home\nSearch\nmain\nUse dark mode\nDOCUMENTATION\nBLOG\nHISTORY\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nHow to contribute\nReporting bugs\nSuggesting enhancements\nDocumentation contributions\nCode contributions\nIssue triage\nCommunity\nFAQ\npre-commit hooks\nContributing to Poetry\n\nFirst off, thanks for taking the time to contribute!\n\nThe following is a set of guidelines for contributing to Poetry on GitHub. These are mostly guidelines, not rules. Use your best judgement, and feel free to propose changes to this document in a pull request.\n\nHow to contribute\nReporting bugs\n\nThis section guides you through submitting a bug report for Poetry. Following these guidelines helps maintainers and the community understand your report, reproduce the behavior, and find related reports.\n\nBefore submitting a bug report\nCheck the FAQ for a list of common questions and problems.\nCheck the blog for release notes from recent releases, including steps for upgrading and known issues.\nCheck that your issue does not already exist in the issue tracker.\nMake sure your issue is really a bug, and is not a support request or question better suited for Discussions or Discord.\nIf you find a Closed issue that seems like it is the same thing that you’re experiencing, open a new issue and include a link to the original issue in the body of your new one.\nHow do I submit a bug report?\n\nBugs concerning Poetry and poetry-core should be submitted to the main issue tracker, using the correct issue template.\n\nExplain the problem and make it easy for others to search for and understand:\n\nUse a clear and descriptive title for the issue to identify the problem.\nDescribe the exact steps which reproduce the problem in as many details as possible.\nDescribe the behavior you observed after following the steps and point out how this is a bug.\nExplain which behavior you expected to see instead and why.\nIf the problem involves an unexpected error being raised, execute the problematic command in debug mode (with -vvv flag).\n\nProvide detailed steps for reproduction of your issue:\n\nProvide your pyproject.toml file in a Gist, pastebin, or example repository after removing potential private information like private package repositories or names.\nProvide specific examples to demonstrate the steps to reproduce the issue. This could be an example repository, a sequence of steps run in a container, or just a pyproject.toml for very simple cases.\nAre you unable to reliably reproduce the issue? If so, provide details about how often the problem happens and under which conditions it normally happens.\n\nProvide more context by answering these questions:\n\nDid the problem start happening recently (e.g. after updating to a new version of Poetry) or was this always a problem?\nIf the problem started happening recently, can you reproduce the problem in an older version of Poetry? What’s the most recent version in which the problem does not happen?\nIs there anything exotic or unusual about your environment? This could include use of special container images, newer CPU architectures like Apple Silicon, or corporate proxies that intercept or modify your network traffic.\n\nInclude details about your configuration and environment:\n\nWhich version of Poetry are you using? You can get the exact version by running poetry --version.\nWhat version of Python is being used to run Poetry? Execute the poetry debug info to get this information.\nWhat’s the name and version of the OS you’re using? Examples include Ubuntu 22.04 or macOS 12.6.\n\nTo give others the best chance to understand and reproduce your issue, please be sure to put extra effort into your reproduction steps. You can both rule out local configuration issues on your end, and ensure others can cleanly reproduce your issue if attempt all reproductions in a pristine container (or VM), and provide the steps you performed inside that container/VM in your issue report.\n\nSuggesting enhancements\n\nThis section guides you through submitting an enhancement suggestion for Poetry, including completely new features as well as improvements to existing functionality. Following these guidelines helps maintainers and the community understand your suggestion and find related suggestions.\n\nBefore submitting a suggested enhancement\nCheck the FAQ for a list of common questions and problems.\nCheck that your issue does not already exist in the issue tracker.\nHow do I submit a suggested enhancement?\n\nSuggested enhancements concerning Poetry and poetry-core should be submitted to the main issue tracker, using the correct issue template.\n\nUse a clear and descriptive title for the issue to identify the suggestion.\nProvide a detailed description of the proposed enhancement, with specific steps or examples when possible.\nDescribe the current behavior and explain which behavior you would like to see instead, and why.\nDocumentation contributions\n\nOne of the simplest ways to get started contributing to a project is through improving documentation. Poetry is constantly evolving, and this means that sometimes our documentation has gaps. You can help by adding missing sections, editing the existing content to be more accessible, or creating new content such as tutorials, FAQs, etc.\n\nGithub Discussions and the kind/question label are excellent sources for FAQ candidates.\n\nIssues pertaining to the documentation are usually marked with the area/docs label, which will also trigger a preview of the changes as rendered by this website.\n\nCode contributions\nPicking an issue\nIf you are a first time contributor, and are looking for an issue to take on, you might want to look for at the contributing page for candidates. We do our best to curate good issues for first-time contributors there, but do fall behind – so if you don’t see anything good, feel free to ask.\n\nIf you would like to take on an issue, feel free to comment on the issue tagging @python-poetry/triage. We are more than happy to discuss solutions on the issue. If you would like help with navigating the code base, are looking for something to work on, or want feedback on a design or change, join us on our Discord server or start a Discussion.\n\nLocal development\n\nPoetry is developed using Poetry. Refer to the documentation to install Poetry in your local environment.\n\nPoetry’s development toolchain requires Python 3.8 or newer.\n\nYou should first fork the Poetry repository and then clone it locally, so that you can make pull requests against the project. If you are new to Git and pull request based development, GitHub provides a guide you will find helpful.\n\nNext, you should install Poetry’s dependencies, and run the test suite to make sure everything is working as expected:\n\npoetry install\npoetry run pytest\n\n\nWhen you contribute to Poetry, automated tools will be run to make sure your code is suitable to be merged. Besides pytest, you will need to make sure your code typechecks properly using mypy:\n\npoetry run mypy\n\n\nFinally, a great deal of linting tools are run on your code, to try and ensure consistent code style and root out common mistakes. The pre-commit tool is used to install and run these tools, and requires one-time setup:\n\npoetry run pre-commit install\n\n\npre-commit will now run and check your code every time you make a commit. By default, it will only run on changed files, but you can run it on all files manually (this may be useful if you altered the pre-commit config):\n\npoetry run pre-commit run --all-files\n\nPull requests\nFill out the pull request body completely and describe your changes as accurately as possible. The pull request body should be kept up to date as it will usually form the base for the final merge commit and the changelog entry.\nBe sure that your pull request contains tests that cover the changed or added code. Tests are generally required for code be to be considered mergeable, and code without passing tests will not be merged.\nEnsure your pull request passes the mypy and pre-commit checks. Remember that you can run these tools locally instead of relying on remote CI.\nIf your changes warrant a documentation change, the pull request must also update the documentation. Make sure to review the documentation preview generated by CI for any rendering issues.\nMake sure your branch is rebased against the latest base branch. A maintainer might ask you to ensure the branch is up-to-date prior to merging your pull request (especially if there have been CI changes on the base branch), and will also ask you to fix any conflicts.\n\nAll pull requests, unless otherwise instructed, need to be first accepted into the main branch. Maintainers will generally decide if any backports to other branches are required, and carry them out as needed.\n\nIssue triage\nIf you have an issue that hasn’t had any attention, you can ping us @python-poetry/triage on the issue. Please give us reasonable time to get to your issue first, and avoid pinging any individuals directly, especially if they are not part of the Poetry team.\n\nIf you are helping with the triage of reported issues, this section provides some useful information to assist you in your contribution.\n\nTriage steps\nDetermine what area and versions of Poetry the issue is related to, and set the appropriate labels (e.g. version/x.x.x, area/docs, area/venv), and remove the status/triage label.\nIf requested information (such as debug logs, pyproject.toml, etc.) is not provided and is relevant, request it from the author.\nSet the status/waiting-on-response label while waiting to hear back from the author.\nAttempt to reproduce the issue with the reported Poetry version or request further clarification from the author.\nEnsure the issue is not already resolved. Try reproducing it on the latest stable release, the latest prerelease (if present), and the development branch.\nIf the issue cannot be reproduced,\nrequest more reproduction steps and clarification from the issue’s author,\nset the status/needs-reproduction label,\nclose the issue if there is no reproduction forthcoming.\nIf the issue can be reproduced,\ncomment on the issue confirming so,\nset the status/confirmed label,\nif possible, identify the root cause of the issue,\nif interested, attempt to fix it via a pull request.\nMultiple versions\n\nWhen trying to reproduce issues, you often want to use multiple versions of Poetry at the same time. pipx makes this easy to do:\n\npipx install --suffix @1.2.1 'poetry==1.2.1'\npipx install --suffix @1.3.0rc1 'poetry==1.3.0rc1'\npipx install --suffix @main 'poetry @ git+https://github.com/python-poetry/poetry'\npipx install --suffix @local '/path/to/local/clone/of/poetry'\n\n# now you can use any of the chosen versions of Poetry with their configured suffix, e.g.\npoetry@main --version\n\nDo not forget to pipx upgrade poetry@main before using it, to make sure you have the latest changes.\n\nThis mechanism can also be used to test pull requests by using GitHub’s pull request remote refs:\n\npipx install --suffix @pr1234 git+https://github.com/python-poetry/poetry.git@refs/pull/1234/head\n\nFooter\n\nPython packaging and dependency management made easy.\n\nGitHub\nDiscord\nDOCUMENTATION\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\n GITHUB\nProject\nIssues\nDiscussions\nOTHER PROJECTS\npoetry-core\ninstall.python-poetry.org\nBundle plugin\nExport plugin\n\nCopyright © 2018-2024. All Rights Reserved.\nPowered by"
  },
  {
    "title": "Plugins | main | Documentation | Poetry - Python dependency management and packaging made easy",
    "url": "https://python-poetry.org/docs/main/plugins/",
    "html": "Home\nSearch\nmain\nUse dark mode\nDOCUMENTATION\nBLOG\nHISTORY\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nCreating a plugin\nPlugin package\nGeneric plugins\nApplication plugins\nEvent handler\nUsing plugins\nWith pipx inject\nWith pip\nThe self add command\nMaintaining a plugin\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\nPlugins\n\nPoetry supports using and building plugins if you wish to alter or expand Poetry’s functionality with your own.\n\nFor example if your environment poses special requirements on the behaviour of Poetry which do not apply to the majority of its users or if you wish to accomplish something with Poetry in a way that is not desired by most users.\n\nIn these cases you could consider creating a plugin to handle your specific logic.\n\nCreating a plugin\n\nA plugin is a regular Python package which ships its code as part of the package and may also depend on further packages.\n\nPlugin package\n\nThe plugin package must depend on Poetry and declare a proper plugin in the pyproject.toml file.\n\n[tool.poetry]\nname = \"my-poetry-plugin\"\nversion = \"1.0.0\"\n\n# ...\n[tool.poetry.dependencies]\npython = \"^3.7\"\npoetry = \"^1.2\"\n\n[tool.poetry.plugins.\"poetry.plugin\"]\ndemo = \"poetry_demo_plugin.plugin:MyPlugin\"\n\nGeneric plugins\n\nEvery plugin has to supply a class which implements the poetry.plugins.Plugin interface.\n\nThe activate() method of the plugin is called after the plugin is loaded and receives an instance of Poetry as well as an instance of cleo.io.io.IO.\n\nUsing these two objects all configuration can be read and all public internal objects and state can be manipulated as desired.\n\nExample:\n\nfrom cleo.io.io import IO\n\nfrom poetry.plugins.plugin import Plugin\nfrom poetry.poetry import Poetry\n\n\nclass MyPlugin(Plugin):\n\n    def activate(self, poetry: Poetry, io: IO):\n        io.write_line(\"Setting readme\")\n        poetry.package.readme = \"README.md\"\n        ...\n\nApplication plugins\n\nIf you want to add commands or options to the poetry script you need to create an application plugin which implements the poetry.plugins.ApplicationPlugin interface.\n\nThe activate() method of the application plugin is called after the plugin is loaded and receives an instance of poetry.console.Application.\n\nfrom cleo.commands.command import Command\nfrom poetry.plugins.application_plugin import ApplicationPlugin\n\n\nclass CustomCommand(Command):\n\n    name = \"my-command\"\n\n    def handle(self) -> int:\n        self.line(\"My command\")\n\n        return 0\n\n\ndef factory():\n    return CustomCommand()\n\n\nclass MyApplicationPlugin(ApplicationPlugin):\n    def activate(self, application):\n        application.command_loader.register_factory(\"my-command\", factory)\n\n\nIt’s possible to do the following to register the command:\n\napplication.add(MyCommand())\n\n\nHowever, it is strongly recommended to register a new factory in the command loader to defer the loading of the command when it’s actually called.\n\nThis will help keep the performances of Poetry good.\n\nThe plugin also must be declared in the pyproject.toml file of the plugin package as a poetry.application.plugin plugin:\n\n[tool.poetry.plugins.\"poetry.application.plugin\"]\nfoo-command = \"poetry_demo_plugin.plugin:MyApplicationPlugin\"\n\nA plugin must not remove or modify in any way the core commands of Poetry.\nEvent handler\n\nPlugins can also listen to specific events and act on them if necessary.\n\nThese events are fired by Cleo and are accessible from the cleo.events.console_events module.\n\nCOMMAND: this event allows attaching listeners before any command is executed.\nSIGNAL: this event allows some actions to be performed after the command execution is interrupted.\nTERMINATE: this event allows listeners to be attached after the command.\nERROR: this event occurs when an uncaught exception is raised.\n\nLet’s see how to implement an application event handler. For this example we will see how to load environment variables from a .env file before executing a command.\n\nfrom cleo.events.console_events import COMMAND\nfrom cleo.events.console_command_event import ConsoleCommandEvent\nfrom cleo.events.event_dispatcher import EventDispatcher\nfrom dotenv import load_dotenv\nfrom poetry.console.application import Application\nfrom poetry.console.commands.env_command import EnvCommand\nfrom poetry.plugins.application_plugin import ApplicationPlugin\n\n\nclass MyApplicationPlugin(ApplicationPlugin):\n    def activate(self, application: Application):\n        application.event_dispatcher.add_listener(\n            COMMAND, self.load_dotenv\n        )\n\n    def load_dotenv(\n        self,\n        event: ConsoleCommandEvent,\n        event_name: str,\n        dispatcher: EventDispatcher\n    ) -> None:\n        command = event.command\n        if not isinstance(command, EnvCommand):\n            return\n\n        io = event.io\n\n        if io.is_debug():\n            io.write_line(\n                \"<debug>Loading environment variables.</debug>\"\n            )\n\n        load_dotenv()\n\nUsing plugins\n\nInstalled plugin packages are automatically loaded when Poetry starts up.\n\nYou have multiple ways to install plugins for Poetry\n\nWith pipx inject\n\nIf you used pipx to install Poetry you can add the plugin packages via the pipx inject command.\n\npipx inject poetry poetry-plugin\n\n\nIf you want to uninstall a plugin, you can run:\n\npipx uninject poetry poetry-plugin          # For pipx versions >= 1.2.0\n\npipx runpip poetry uninstall poetry-plugin  # For pipx versions  < 1.2.0\n\nWith pip\n\nThe pip binary in Poetry’s virtual environment can also be used to install and remove plugins. The environment variable $POETRY_HOME here is used to represent the path to the virtual environment. The installation instructions can be referenced if you are not sure where Poetry has been installed.\n\nTo add a plugin, you can use pip install:\n\n$POETRY_HOME/bin/pip install --user poetry-plugin\n\n\nIf you want to uninstall a plugin, you can run:\n\n$POETRY_HOME/bin/pip uninstall poetry-plugin\n\nThe self add command\nEspecially on Windows, self add and self remove may be problematic so that other methods should be preferred.\npoetry self add poetry-plugin\n\n\nThe self add command will ensure that the plugin is compatible with the current version of Poetry and install the needed packages for the plugin to work.\n\nThe package specification formats supported by the self add command are the same as the ones supported by the add command.\n\nIf you no longer need a plugin and want to uninstall it, you can use the self remove command.\n\npoetry self remove poetry-plugin\n\n\nYou can also list all currently installed plugins by running:\n\npoetry self show plugins\n\nMaintaining a plugin\n\nWhen writing a plugin, you will probably access internals of Poetry, since there is no stable public API. Although we try our best to deprecate methods first, before removing them, sometimes the signature of an internal method has to be changed.\n\nAs the author of a plugin, you are probably testing your plugin against the latest release of Poetry. Additionally, you should consider testing against the latest release branch and the main branch of Poetry and schedule a CI job that runs regularly even if you did not make any changes to your plugin. This way, you will notice internal changes that break your plugin immediately and can prepare for the next Poetry release.\n\nFooter\n\nPython packaging and dependency management made easy.\n\nGitHub\nDiscord\nDOCUMENTATION\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\n GITHUB\nProject\nIssues\nDiscussions\nOTHER PROJECTS\npoetry-core\ninstall.python-poetry.org\nBundle plugin\nExport plugin\n\nCopyright © 2018-2024. All Rights Reserved.\nPowered by"
  },
  {
    "title": "Dependency specification | main | Documentation | Poetry - Python dependency management and packaging made easy",
    "url": "https://python-poetry.org/docs/main/dependency-specification/",
    "html": "Home\nSearch\nmain\nUse dark mode\nDOCUMENTATION\nBLOG\nHISTORY\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nVersion constraints\nCaret requirements\nTilde requirements\nWildcard requirements\nInequality requirements\nExact requirements\nUsing the @ operator\ngit dependencies\npath dependencies\nurl dependencies\nDependency extras\nsource dependencies\nPython restricted dependencies\nUsing environment markers\nMultiple constraints dependencies\nCombining git / url / path dependencies with source repositories\nExpanded dependency specification syntax\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\nDependency specification\n\nDependencies for a project can be specified in various forms, which depend on the type of the dependency and on the optional constraints that might be needed for it to be installed.\n\nVersion constraints\nCaret requirements\n\nCaret requirements allow SemVer compatible updates to a specified version. An update is allowed if the new version number does not modify the left-most non-zero digit in the major, minor, patch grouping. For instance, if we previously ran poetry add requests@^2.13.0 and wanted to update the library and ran poetry update requests, poetry would update us to version 2.14.0 if it was available, but would not update us to 3.0.0. If instead we had specified the version string as ^0.1.13, poetry would update to 0.1.14 but not 0.2.0. 0.0.x is not considered compatible with any other version.\n\nHere are some more examples of caret requirements and the versions that would be allowed with them:\n\nREQUIREMENT\tVERSIONS ALLOWED\n^1.2.3\t>=1.2.3 <2.0.0\n^1.2\t>=1.2.0 <2.0.0\n^1\t>=1.0.0 <2.0.0\n^0.2.3\t>=0.2.3 <0.3.0\n^0.0.3\t>=0.0.3 <0.0.4\n^0.0\t>=0.0.0 <0.1.0\n^0\t>=0.0.0 <1.0.0\nTilde requirements\n\nTilde requirements specify a minimal version with some ability to update. If you specify a major, minor, and patch version or only a major and minor version, only patch-level changes are allowed. If you only specify a major version, then minor- and patch-level changes are allowed.\n\n~1.2.3 is an example of a tilde requirement.\n\nREQUIREMENT\tVERSIONS ALLOWED\n~1.2.3\t>=1.2.3 <1.3.0\n~1.2\t>=1.2.0 <1.3.0\n~1\t>=1.0.0 <2.0.0\nWildcard requirements\n\nWildcard requirements allow for the latest (dependency dependent) version where the wildcard is positioned.\n\n*, 1.* and 1.2.* are examples of wildcard requirements.\n\nREQUIREMENT\tVERSIONS ALLOWED\n*\t>=0.0.0\n1.*\t>=1.0.0 <2.0.0\n1.2.*\t>=1.2.0 <1.3.0\nInequality requirements\n\nInequality requirements allow manually specifying a version range or an exact version to depend on.\n\nHere are some examples of inequality requirements:\n\n>= 1.2.0\n> 1\n< 2\n!= 1.2.3\n\nMultiple requirements\n\nMultiple version requirements can also be separated with a comma, e.g. >= 1.2, < 1.5.\n\nExact requirements\n\nYou can specify the exact version of a package.\n\n1.2.3 is an example of an exact version specification.\n\nThis will tell Poetry to install this version and this version only. If other dependencies require a different version, the solver will ultimately fail and abort any install or update procedures.\n\nExact versions can also be specified with == according to PEP 440.\n\n==1.2.3 is an example of this.\n\nUsing the @ operator\n\nWhen adding dependencies via poetry add, you can use the @ operator. This is understood similarly to the == syntax, but also allows prefixing any specifiers that are valid in pyproject.toml. For example:\n\npoetry add django@^4.0.0\n\n\nThe above would translate to the following entry in pyproject.toml:\n\nDjango = \"^4.0.0\"\n\n\nThe special keyword latest is also understood by the @ operator:\n\npoetry add django@latest\n\n\nThe above would translate to the following entry in pyproject.toml, assuming the latest release of django is 4.0.5:\n\nDjango = \"^4.0.5\"\n\nExtras\n\nExtras and @ can be combined as one might expect (package[extra]@version):\n\npoetry add django[bcrypt]@^4.0.0\n\ngit dependencies\n\nTo depend on a library located in a git repository, the minimum information you need to specify is the location of the repository with the git key:\n\n[tool.poetry.dependencies]\nrequests = { git = \"https://github.com/requests/requests.git\" }\n\n\nSince we haven’t specified any other information, Poetry assumes that we intend to use the latest commit on the main branch to build our project.\n\nYou can combine the git key with the branch key to use another branch. Alternatively, use rev or tag to pin a dependency to a specific commit hash or tagged ref, respectively. For example:\n\n[tool.poetry.dependencies]\n# Get the latest revision on the branch named \"next\"\nrequests = { git = \"https://github.com/kennethreitz/requests.git\", branch = \"next\" }\n# Get a revision by its commit hash\nflask = { git = \"https://github.com/pallets/flask.git\", rev = \"38eb5d3b\" }\n# Get a revision by its tag\nnumpy = { git = \"https://github.com/numpy/numpy.git\", tag = \"v0.13.2\" }\n\n\nIn cases where the package you want to install is located in a subdirectory of the VCS repository, you can use the subdirectory option, similarly to what pip provides:\n\n[tool.poetry.dependencies]\n# Install a package named `subdir_package` from a folder called `subdir` within the repository\nsubdir_package = { git = \"https://github.com/myorg/mypackage_with_subdirs.git\", subdirectory = \"subdir\" }\n\n\nwith the corresponding add call:\n\npoetry add \"git+https://github.com/myorg/mypackage_with_subdirs.git#subdirectory=subdir\"\n\n\nTo use an SSH connection, for example in the case of private repositories, use the following example syntax:\n\n[tool.poetry.dependencies]\nrequests = { git = \"git@github.com:requests/requests.git\" }\n\n\nTo use HTTP basic authentication with your git repositories, you can configure credentials similar to how repository credentials are configured.\n\npoetry config repositories.git-org-project https://github.com/org/project.git\npoetry config http-basic.git-org-project username token\npoetry add git+https://github.com/org/project.git\n\n\nWith Poetry 1.2 releases, the default git client used is Dulwich.\n\nWe fall back to legacy system git client implementation in cases where gitcredentials is used. This fallback will be removed in a future release where gitcredentials helpers can be better supported natively.\n\nIn cases where you encounter issues with the default implementation that used to work prior to Poetry 1.2, you may wish to explicitly configure the use of the system git client via a shell subprocess call.\n\npoetry config experimental.system-git-client true\n\n\nKeep in mind however, that doing so will surface bugs that existed in versions prior to 1.2 which were caused due to the use of the system git client.\n\npath dependencies\n\nTo depend on a library located in a local directory or file, you can use the path property:\n\n[tool.poetry.dependencies]\n# directory\nmy-package = { path = \"../my-package/\", develop = false }\n\n# file\nmy-package = { path = \"../my-package/dist/my-package-0.1.0.tar.gz\" }\n\nBefore poetry 1.1 directory path dependencies were installed in editable mode by default. You should set the develop attribute explicitly, to make sure the behavior is the same for all poetry versions.\nurl dependencies\n\nTo depend on a library located on a remote archive, you can use the url property:\n\n[tool.poetry.dependencies]\n# directory\nmy-package = { url = \"https://example.com/my-package-0.1.0.tar.gz\" }\n\n\nwith the corresponding add call:\n\npoetry add https://example.com/my-package-0.1.0.tar.gz\n\nDependency extras\n\nYou can specify PEP-508 Extras for a dependency as shown here.\n\n[tool.poetry.dependencies]\ngunicorn = { version = \"^20.1\", extras = [\"gevent\"] }\n\nThese activate extra defined for the dependency, to configure an optional dependency for extras in your project refer to extras.\nsource dependencies\n\nTo depend on a package from an alternate repository, you can use the source property:\n\n[[tool.poetry.source]]\nname = \"foo\"\nurl = \"https://foo.bar/simple/\"\npriority = \"supplemental\"\n\n[tool.poetry.dependencies]\nmy-cool-package = { version = \"*\", source = \"foo\" }\n\n\nwith the corresponding add call:\n\npoetry add my-cool-package --source foo\n\nIn this example, we expect foo to be configured correctly. See using a private repository for further information.\nPython restricted dependencies\n\nYou can also specify that a dependency should be installed only for specific Python versions:\n\n[tool.poetry.dependencies]\ntomli = { version = \"^2.0.1\", python = \"<3.11\" }\n\n[tool.poetry.dependencies]\npathlib2 = { version = \"^2.2\", python = \"^3.2\" }\n\nUsing environment markers\n\nIf you need more complex install conditions for your dependencies, Poetry supports environment markers via the markers property:\n\n[tool.poetry.dependencies]\npathlib2 = { version = \"^2.2\", markers = \"python_version <= '3.4' or sys_platform == 'win32'\" }\n\nMultiple constraints dependencies\n\nSometimes, one of your dependency may have different version ranges depending on the target Python versions.\n\nLet’s say you have a dependency on the package foo which is only compatible with Python 3.6-3.7 up to version 1.9, and compatible with Python 3.8+ from version 2.0: you would declare it like so:\n\n[tool.poetry.dependencies]\nfoo = [\n    {version = \"<=1.9\", python = \">=3.6,<3.8\"},\n    {version = \"^2.0\", python = \">=3.8\"}\n]\n\nThe constraints must have different requirements (like python) otherwise it will cause an error when resolving dependencies.\nCombining git / url / path dependencies with source repositories\n\nDirect origin (git/ url/ path) dependencies can satisfy the requirement of a dependency that doesn’t explicitly specify a source, even when mutually exclusive markers are used. For instance in the following example the url package will also be a valid solution for the second requirement:\n\nfoo = [\n    { platform = \"darwin\", url = \"https://example.com/example-1.0-py3-none-any.whl\" },\n    { platform = \"linux\", version = \"^1.0\" },\n]\n\n\nSometimes you may instead want to use a direct origin dependency for specific conditions (i.e. a compiled package that is not available on PyPI for a certain platform/architecture) while falling back on source repositories in other cases. In this case you should explicitly ask for your dependency to be satisfied by another source. For example:\n\nfoo = [\n    { platform = \"darwin\", url = \"https://example.com/foo-1.0.0-py3-none-macosx_11_0_arm64.whl\" },\n    { platform = \"linux\", version = \"^1.0\", source = \"pypi\" },\n]\n\nExpanded dependency specification syntax\n\nIn the case of more complex dependency specifications, you may find that you end up with lines which are very long and difficult to read. In these cases, you can shift from using “inline table” syntax, to the “standard table” syntax.\n\nAn example where this might be useful is the following:\n\n[tool.poetry.group.dev.dependencies]\nblack = {version = \"19.10b0\", allow-prereleases = true, python = \"^3.7\", markers = \"platform_python_implementation == 'CPython'\"}\n\n\nAs a single line, this is a lot to digest. To make this a bit easier to work with, you can do the following:\n\n[tool.poetry.group.dev.dependencies.black]\nversion = \"19.10b0\"\nallow-prereleases = true\npython = \"^3.7\"\nmarkers = \"platform_python_implementation == 'CPython'\"\n\n\nThe same information is still present, and ends up providing the exact same specification. It’s simply split into multiple, slightly more readable, lines.\n\nFooter\n\nPython packaging and dependency management made easy.\n\nGitHub\nDiscord\nDOCUMENTATION\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\n GITHUB\nProject\nIssues\nDiscussions\nOTHER PROJECTS\npoetry-core\ninstall.python-poetry.org\nBundle plugin\nExport plugin\n\nCopyright © 2018-2024. All Rights Reserved.\nPowered by"
  },
  {
    "title": "Repositories | main | Documentation | Poetry - Python dependency management and packaging made easy",
    "url": "https://python-poetry.org/docs/main/repositories/",
    "html": "Home\nSearch\nmain\nUse dark mode\nDOCUMENTATION\nBLOG\nHISTORY\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nPrivate Repository Example\nPackage Sources\nProject Configuration\nSupported Package Sources\nPublishable Repositories\nConfiguring Credentials\nCertificates\nCustom certificate authority and mutual TLS authentication\nCaches\nDebugging Issues\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\nRepositories\n\nPoetry supports the use of PyPI and private repositories for discovery of packages as well as for publishing your projects.\n\nBy default, Poetry is configured to use the PyPI repository, for package installation and publishing.\n\nSo, when you add dependencies to your project, Poetry will assume they are available on PyPI.\n\nThis represents most cases and will likely be enough for most users.\n\nPrivate Repository Example\nInstalling from private package sources\n\nBy default, Poetry discovers and installs packages from PyPI. But, you want to install a dependency to your project for a simple API repository? Let’s do it.\n\nFirst, configure the package source as a supplemental (or explicit) package source to your project.\n\npoetry source add --priority=supplemental foo https://pypi.example.org/simple/\n\n\nThen, assuming the repository requires authentication, configure credentials for it.\n\npoetry config http-basic.foo <username> <password>\n\nDepending on your system configuration, credentials might be saved in your command line history. Many shells do not save commands to history when they are prefixed by a space character. For more information, please refer to your shell’s documentation.\n\nIf you would like to provide the password interactively, you can simply omit <password> in your command. And Poetry will prompt you to enter the credential manually.\n\npoetry config http-basic.foo <username>\n\n\nOnce this is done, you can add dependencies to your project from this source.\n\npoetry add --source foo private-package\n\nPublishing to a private repository\n\nGreat, now all that is left is to publish your package. Assuming you’d want to share it privately with your team, you can configure the Upload API endpoint for your publishable repository.\n\npoetry config repositories.foo https://pypi.example.org/legacy/\n\n\nIf you need to use a different credential for your package source, then it is recommended to use a different name for your publishing repository.\n\npoetry config repositories.foo-pub https://pypi.example.org/legacy/\npoetry config http-basic.foo-pub <username> <password>\n\n\nWhen configuring a repository using environment variables, note that correct suffixes need to be used.\n\nexport POETRY_REPOSITORIES_FOO_URL=https://pypi.example.org/legacy/\nexport POETRY_HTTP_BASIC_FOO_USERNAME=<username>\nexport POETRY_HTTP_BASIC_FOO_PASSWORD=<password>\n\n\nNow, all the is left is to build and publish your project using the publish.\n\npoetry publish --build --repository foo-pub\n\nPackage Sources\n\nBy default, Poetry is configured to use the Python ecosystem’s canonical package index PyPI.\n\nWith the exception of the implicitly configured source for PyPI named pypi, package sources are local to a project and must be configured within the project’s pyproject.toml file. This is not the same configuration used when publishing a package.\nProject Configuration\n\nThese package sources may be managed using the source command for your project.\n\npoetry source add foo https://foo.bar/simple/\n\nIf your package source requires credentials or certificates, please refer to the relevant sections below.\n\nThis will generate the following configuration snippet in your pyproject.toml file.\n\n[[tool.poetry.source]]\nname = \"foo\"\nurl = \"https://foo.bar/simple/\"\npriority = \"primary\"\n\n\nIf priority is undefined, the source is considered a primary source that takes precedence over PyPI, secondary, supplemental and explicit sources.\n\nPackage sources are considered in the following order:\n\ndefault source (DEPRECATED),\nprimary sources,\nimplicit PyPI (unless disabled by another primary source, default source or configured explicitly),\nsecondary sources (DEPRECATED),\nsupplemental sources.\n\nExplicit sources are considered only for packages that explicitly indicate their source.\n\nWithin each priority class, package sources are considered in order of appearance in pyproject.toml.\n\nIf you want to change the priority of PyPI, you can set it explicitly, e.g.\n\npoetry source add --priority=primary PyPI\n\n\nIf you prefer to disable PyPI completely, just add a primary source or configure PyPI as explicit source.\n\nDefault Package Source (DEPRECATED)\n\nDeprecated in 1.8.0\n\nConfiguring a default package source is deprecated because it is the same as the topmost primary source. Just configure a primary package source and put it first in the list of package sources.\n\nBy default, if you have not configured any primary source, Poetry will configure PyPI as the package source for your project. You can alter this behaviour and exclusively look up packages only from the configured package sources by adding at least one primary source (recommended) or a single source with priority = \"default\" (deprecated).\n\npoetry source add --priority=default foo https://foo.bar/simple/\n\nPrimary Package Sources\n\nAll primary package sources are searched for each dependency without a source constraint. If you configure at least one primary source, the implicit PyPI source is disabled.\n\npoetry source add --priority=primary foo https://foo.bar/simple/\n\n\nSources without a priority are considered primary sources, too.\n\npoetry source add foo https://foo.bar/simple/\n\n\nThe implicit PyPI source is disabled automatically if at least one primary source is configured. If you want to use PyPI in addition to a primary source, configure it explicitly with a certain priority, e.g.\n\npoetry source add --priority=primary PyPI\n\n\nThis way, the priority of PyPI can be set in a fine-granular way.\n\nThe equivalent specification in pyproject.toml is:\n\n[[tool.poetry.source]]\nname = \"pypi\"\npriority = \"primary\"\n\n\nOmit the url when specifying PyPI explicitly. Because PyPI is internally configured with Poetry, the PyPI repository cannot be configured with a given URL. Remember, you can always use poetry check to ensure the validity of the pyproject.toml file.\n\nSecondary Package Sources (DEPRECATED)\n\nDeprecated in 1.5.0\n\nIf package sources are configured as secondary, all it means is that these will be given a lower priority when selecting compatible package distribution that also exists in your default and primary package sources. If the package source should instead be searched only if higher-priority repositories did not return results, please consider a supplemental source instead.\n\nYou can configure a package source as a secondary source with priority = \"secondary\" in your package source configuration.\n\npoetry source add --priority=secondary foo https://foo.bar/simple/\n\n\nThere can be more than one secondary package source.\n\nSecondary package sources are deprecated in favor of supplemental package sources.\nSupplemental Package Sources\n\nIntroduced in 1.5.0\n\nPackage sources configured as supplemental are only searched if no other (higher-priority) source yields a compatible package distribution. This is particularly convenient if the response time of the source is high and relatively few package distributions are to be fetched from this source.\n\nYou can configure a package source as a supplemental source with priority = \"supplemental\" in your package source configuration.\n\npoetry source add --priority=supplemental foo https://foo.bar/simple/\n\n\nThere can be more than one supplemental package source.\n\nTake into account that someone could publish a new package to a primary source which matches a package in your supplemental source. They could coincidentally or intentionally replace your dependency with something you did not expect.\nExplicit Package Sources\n\nIntroduced in 1.5.0\n\nIf package sources are configured as explicit, these sources are only searched when a package configuration explicitly indicates that it should be found on this package source.\n\nYou can configure a package source as an explicit source with priority = \"explicit\" in your package source configuration.\n\npoetry source add --priority=explicit foo https://foo.bar/simple/\n\n\nThere can be more than one explicit package source.\n\nA real-world example where an explicit package source is useful, is for PyTorch GPU packages.\n\npoetry source add --priority=explicit pytorch-gpu-src https://download.pytorch.org/whl/cu118\npoetry add --source pytorch-gpu-src torch torchvision torchaudio\n\nPackage Source Constraint\n\nAll package sources (including secondary and possibly supplemental sources) will be searched during the package lookup process. These network requests will occur for all sources, regardless of if the package is found at one or more sources.\n\nIn order to limit the search for a specific package to a particular package repository, you can specify the source explicitly.\n\npoetry add --source internal-pypi httpx\n\n\nThis results in the following configuration in pyproject.toml:\n\n[tool.poetry.dependencies]\n...\nhttpx = { version = \"^0.22\", source = \"internal-pypi\" }\n\n[[tool.poetry.source]]\nname = \"internal-pypi\"\nurl = ...\npriority = ...\n\nA repository that is configured to be the only source for retrieving a certain package can itself have any priority. In particular, it does not need to have priority \"explicit\". If a repository is configured to be the source of a package, it will be the only source that is considered for that package and the repository priority will have no effect on the resolution.\n\nPackage source keys are not inherited by their dependencies. In particular, if package-A is configured to be found in source = internal-pypi, and package-A depends on package-B that is also to be found on internal-pypi, then package-B needs to be configured as such in pyproject.toml. The easiest way to achieve this is to add package-B with a wildcard constraint:\n\npoetry add --source internal-pypi package-B@*\n\n\nThis will ensure that package-B is searched only in the internal-pypi package source. The version constraints on package-B are derived from package-A (and other client packages), as usual.\n\nIf you want to avoid additional main dependencies, you can add package-B to a dedicated dependency group:\n\npoetry add --group explicit --source internal-pypi package-B@*\n\nPackage source constraints are strongly suggested for all packages that are expected to be provided only by one specific source to avoid dependency confusion attacks.\nSupported Package Sources\nPython Package Index (PyPI)\n\nPoetry interacts with PyPI via its JSON API. This is used to retrieve a requested package’s versions, metadata, files, etc.\n\nIf the the package’s published metadata is invalid, Poetry will download the available bdist/sdist to inspect it locally to identify the relevant metadata.\n\nIf you want to explicitly select a package from PyPI you can use the --source option with the add command, like shown below.\n\npoetry add --source pypi httpx@^0.22.0\n\n\nThis will generate the following configuration snippet in your pyproject.toml file.\n\nhttpx = {version = \"^0.22.0\", source = \"pypi\"}\n\nIf any source within a project is configured with priority = \"default\", The implicit pypi source will be disabled and not used for any packages.\nSimple API Repository\n\nPoetry can fetch and install package dependencies from public or private custom repositories that implement the simple repository API as described in PEP 503.\n\nWhen using sources that distributes large wheels without providing file checksum in file URLs, Poetry will download each candidate wheel at least once in order to generate the checksum. This can manifest as long dependency resolution times when adding packages from this source.\n\nThese package sources may be configured via the following command in your project.\n\npoetry source add testpypi https://test.pypi.org/simple/\n\nNote the trailing /simple/. This is important when configuring PEP 503 compliant package sources.\n\nIn addition to PEP 503, Poetry can also handle simple API repositories that implement PEP 658 (Introduced in 1.2.0). This is helpful in reducing dependency resolution time for packages from these sources as Poetry can avoid having to download each candidate distribution, in order to determine associated metadata.\n\nWhy does Poetry insist on downloading all candidate distributions for all platforms when metadata is not available?\n\nThe need for this stems from the fact that Poetry’s lock file is platform-agnostic. This means, in order to resolve dependencies for a project, Poetry needs metadata for all platform specific distributions. And when this metadata is not readily available, downloading the distribution and inspecting it locally is the only remaining option.\n\nSingle Page Link Source\n\nIntroduced in 1.2.0\n\nSome projects choose to release their binary distributions via a single page link source that partially follows the structure of a package page in PEP 503.\n\nThese package sources may be configured via the following command in your project.\n\npoetry source add jax https://storage.googleapis.com/jax-releases/jax_releases.html\n\nAll caveats regarding slower resolution times described for simple API repositories do apply here as well.\nPublishable Repositories\n\nPoetry treats repositories to which you publish packages as user specific and not project specific configuration unlike package sources. Poetry, today, only supports the Legacy Upload API when publishing your project.\n\nThese are configured using the config command, under the repositories key.\n\npoetry config repositories.testpypi https://test.pypi.org/legacy/\n\nLegacy Upload API URLs are typically different to the same one provided by the repository for the simple API. You’ll note that in the example of Test PyPI, both the host (test.pypi.org) as well as the path (/legacy) are different to its simple API (https://test.pypi.org/simple).\nConfiguring Credentials\n\nIf you want to store your credentials for a specific repository, you can do so easily:\n\npoetry config http-basic.foo <username> <password>\n\n\nIf you do not specify the password you will be prompted to write it.\n\nTo publish to PyPI, you can set your credentials for the repository named pypi.\n\nNote that it is recommended to use API tokens when uploading packages to PyPI. Once you have created a new token, you can tell Poetry to use it:\n\npoetry config pypi-token.pypi <my-token>\n\n\nIf you have configured testpypi as a Publishable Repository, the token can be set using\n\npoetry config pypi-token.testpypi <your-token>\n\n\nIf you still want to use your username and password, you can do so with the following call to config.\n\npoetry config http-basic.pypi <username> <password>\n\n\nYou can also specify the username and password when using the publish command with the --username and --password options.\n\nIf a system keyring is available and supported, the password is stored to and retrieved from the keyring. In the above example, the credential will be stored using the name poetry-repository-pypi. If access to keyring fails or is unsupported, this will fall back to writing the password to the auth.toml file along with the username.\n\nKeyring support is enabled using the keyring library. For more information on supported backends refer to the library documentation.\n\nIf you do not want to use the keyring, you can tell Poetry to disable it and store the credentials in plaintext config files:\n\npoetry config keyring.enabled false\n\nPoetry will fallback to Pip style use of keyring so that backends like Microsoft’s artifacts-keyring get a chance to retrieve valid credentials. It will need to be properly installed into Poetry’s virtualenv, preferably by installing a plugin.\n\nAlternatively, you can use environment variables to provide the credentials:\n\nexport POETRY_PYPI_TOKEN_FOO=my-token\nexport POETRY_HTTP_BASIC_FOO_USERNAME=<username>\nexport POETRY_HTTP_BASIC_FOO_PASSWORD=<password>\n\n\nwhere FOO is the name of the repository in uppercase (e.g. PYPI). See Using environment variables for more information on how to configure Poetry with environment variables.\n\nIf your password starts with a dash (e.g. randomly generated tokens in a CI environment), it will be parsed as a command line option instead of a password. You can prevent this by adding double dashes to prevent any following argument from being parsed as an option.\n\npoetry config -- http-basic.pypi myUsername -myPasswordStartingWithDash\n\nCertificates\nCustom certificate authority and mutual TLS authentication\n\nPoetry supports repositories that are secured by a custom certificate authority as well as those that require certificate-based client authentication. The following will configure the “foo” repository to validate the repository’s certificate using a custom certificate authority and use a client certificate (note that these config variables do not both need to be set):\n\npoetry config certificates.foo.cert /path/to/ca.pem\npoetry config certificates.foo.client-cert /path/to/client.pem\n\n\nThe value of certificates.<repository>.cert can be set to false if certificate verification is required to be skipped. This is useful for cases where a package source with self-signed certificates are used.\n\npoetry config certificates.foo.cert false\n\nDisabling certificate verification is not recommended as it is does not conform to security best practices.\nCaches\n\nPoetry employs multiple caches for package sources in order to improve user experience and avoid duplicate network requests.\n\nThe first level cache is a Cache-Control header based cache for almost all HTTP requests.\n\nFurther, every HTTP backed package source caches metadata associated with a package once it is fetched or generated. Additionally, downloaded files (package distributions) are also cached.\n\nDebugging Issues\n\nIf you encounter issues with package sources, one of the simplest steps you might take to debug an issue is rerunning your command with the --no-cache flag.\n\npoetry --no-cache add pycowsay\n\n\nIf this solves your issue, you can consider clearing your cache using the cache command.\n\nAlternatively, you could also consider enabling very verbose logging -vvv along with the --no-cache to see network requests being made in the logs.\n\nFooter\n\nPython packaging and dependency management made easy.\n\nGitHub\nDiscord\nDOCUMENTATION\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\n GITHUB\nProject\nIssues\nDiscussions\nOTHER PROJECTS\npoetry-core\ninstall.python-poetry.org\nBundle plugin\nExport plugin\n\nCopyright © 2018-2024. All Rights Reserved.\nPowered by"
  },
  {
    "title": "Managing environments | main | Documentation | Poetry - Python dependency management and packaging made easy",
    "url": "https://python-poetry.org/docs/main/managing-environments/",
    "html": "Home\nSearch\nmain\nUse dark mode\nDOCUMENTATION\nBLOG\nHISTORY\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nSwitching between environments\nDisplaying the environment information\nListing the environments associated with the project\nDeleting the environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\nManaging environments\n\nPoetry makes project environment isolation one of its core features.\n\nWhat this means is that it will always work isolated from your global Python installation. To achieve this, it will first check if it’s currently running inside a virtual environment. If it is, it will use it directly without creating a new one. But if it’s not, it will use one that it has already created or create a brand new one for you.\n\nBy default, Poetry will try to use the Python version used during Poetry’s installation to create the virtual environment for the current project.\n\nHowever, for various reasons, this Python version might not be compatible with the python range supported by the project. In this case, Poetry will try to find one that is and use it. If it’s unable to do so then you will be prompted to activate one explicitly, see Switching environments.\n\nIf you use a tool like pyenv to manage different Python versions, you can set the experimental virtualenvs.prefer-active-python option to true. Poetry will then try to find the current python of your shell.\n\nFor instance, if your project requires a newer Python than is available with your system, a standard workflow would be:\n\npyenv install 3.9.8\npyenv local 3.9.8  # Activate Python 3.9 for the current project\npoetry install\n\nSince version 1.2, Poetry no longer supports managing environments for Python 2.7.\nSwitching between environments\n\nSometimes this might not be feasible for your system, especially Windows where pyenv is not available, or you simply prefer to have a more explicit control over your environment. For this specific purpose, you can use the env use command to tell Poetry which Python version to use for the current project.\n\npoetry env use /full/path/to/python\n\n\nIf you have the python executable in your PATH you can use it:\n\npoetry env use python3.7\n\n\nYou can even just use the minor Python version in this case:\n\npoetry env use 3.7\n\n\nIf you want to disable the explicitly activated virtual environment, you can use the special system Python version to retrieve the default behavior:\n\npoetry env use system\n\nDisplaying the environment information\n\nIf you want to get basic information about the currently activated virtual environment, you can use the env info command:\n\npoetry env info\n\n\nwill output something similar to this:\n\nVirtualenv\nPython:         3.7.1\nImplementation: CPython\nPath:           /path/to/poetry/cache/virtualenvs/test-O3eWbxRl-py3.7\nValid:          True\n\nBase\nPlatform: darwin\nOS:       posix\nPython:   /path/to/main/python\n\n\nIf you only want to know the path to the virtual environment, you can pass the --path option to env info:\n\npoetry env info --path\n\n\nIf you only want to know the path to the python executable (useful for running mypy from a global environment without installing it in the virtual environment), you can pass the --executable option to env info:\n\npoetry env info --executable\n\nListing the environments associated with the project\n\nYou can also list all the virtual environments associated with the current project with the env list command:\n\npoetry env list\n\n\nwill output something like the following:\n\ntest-O3eWbxRl-py3.6\ntest-O3eWbxRl-py3.7 (Activated)\n\n\nYou can pass the option --full-path to display the full path to the environments:\n\npoetry env list --full-path\n\nDeleting the environments\n\nFinally, you can delete existing virtual environments by using env remove:\n\npoetry env remove /full/path/to/python\npoetry env remove python3.7\npoetry env remove 3.7\npoetry env remove test-O3eWbxRl-py3.7\n\n\nYou can delete more than one environment at a time.\n\npoetry env remove python3.6 python3.7 python3.8\n\n\nUse the --all option to delete all virtual environments at once.\n\npoetry env remove --all\n\n\nIf you remove the currently activated virtual environment, it will be automatically deactivated.\n\nIf you use the virtualenvs.in-project configuration, you can simply use the command as shown below.\n\npoetry env remove\n\nFooter\n\nPython packaging and dependency management made easy.\n\nGitHub\nDiscord\nDOCUMENTATION\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\n GITHUB\nProject\nIssues\nDiscussions\nOTHER PROJECTS\npoetry-core\ninstall.python-poetry.org\nBundle plugin\nExport plugin\n\nCopyright © 2018-2024. All Rights Reserved.\nPowered by"
  },
  {
    "title": "Commands | main | Documentation | Poetry - Python dependency management and packaging made easy",
    "url": "https://python-poetry.org/docs/main/cli/",
    "html": "Home\nSearch\nmain\nUse dark mode\nDOCUMENTATION\nBLOG\nHISTORY\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nGlobal options\nnew\nOptions\ninit\nOptions\ninstall\nOptions\nupdate\nOptions\nadd\nOptions\nremove\nOptions\nshow\nOptions\nbuild\nOptions\npublish\nOptions\nconfig\nUsage\nOptions\nrun\nshell\ncheck\nOptions\nsearch\nlock\nOptions\nversion\nOptions\nexport\nOptions\nenv\ncache\ncache list\ncache clear\nsource\nsource add\nsource show\nsource remove\nabout\nhelp\nlist\nself\nself add\nself update\nself lock\nself show\nself show plugins\nself remove\nself install\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\nCommands\n\nYou’ve already learned how to use the command-line interface to do some things. This chapter documents all the available commands.\n\nTo get help from the command-line, simply call poetry to see the complete list of commands, then --help combined with any of those can give you more information.\n\nGlobal options\n--verbose (-v|vv|vvv): Increase the verbosity of messages: “-v” for normal output, “-vv” for more verbose output and “-vvv” for debug.\n--help (-h) : Display help information.\n--quiet (-q) : Do not output any message.\n--ansi: Force ANSI output.\n--no-ansi: Disable ANSI output.\n--version (-V): Display this application version.\n--no-interaction (-n): Do not ask any interactive question.\n--no-plugins: Disables plugins.\n--no-cache: Disables Poetry source caches.\n--directory=DIRECTORY (-C): The working directory for the Poetry command (defaults to the current working directory).\nnew\n\nThis command will help you kickstart your new Python project by creating a directory structure suitable for most projects.\n\npoetry new my-package\n\n\nwill create a folder as follows:\n\nmy-package\n├── pyproject.toml\n├── README.md\n├── my_package\n│   └── __init__.py\n└── tests\n    └── __init__.py\n\n\nIf you want to name your project differently than the folder, you can pass the --name option:\n\npoetry new my-folder --name my-package\n\n\nIf you want to use a src folder, you can use the --src option:\n\npoetry new --src my-package\n\n\nThat will create a folder structure as follows:\n\nmy-package\n├── pyproject.toml\n├── README.md\n├── src\n│   └── my_package\n│       └── __init__.py\n└── tests\n    └── __init__.py\n\n\nThe --name option is smart enough to detect namespace packages and create the required structure for you.\n\npoetry new --src --name my.package my-package\n\n\nwill create the following structure:\n\nmy-package\n├── pyproject.toml\n├── README.md\n├── src\n│   └── my\n│       └── package\n│           └── __init__.py\n└── tests\n    └── __init__.py\n\nOptions\n--interactive (-i): Allow interactive specification of project configuration.\n--name: Set the resulting package name.\n--src: Use the src layout for the project.\n--readme: Specify the readme file extension. Default is md. If you intend to publish to PyPI keep the recommendations for a PyPI-friendly README in mind.\n--description: Description of the package.\n--author: Author of the package.\n--python Compatible Python versions.\n--dependency: Package to require with a version constraint. Should be in format foo:1.0.0.\n--dev-dependency: Development requirements, see --dependency.\ninit\n\nThis command will help you create a pyproject.toml file interactively by prompting you to provide basic information about your package.\n\nIt will interactively ask you to fill in the fields, while using some smart defaults.\n\npoetry init\n\nOptions\n--name: Name of the package.\n--description: Description of the package.\n--author: Author of the package.\n--python Compatible Python versions.\n--dependency: Package to require with a version constraint. Should be in format foo:1.0.0.\n--dev-dependency: Development requirements, see --dependency.\ninstall\n\nThe install command reads the pyproject.toml file from the current project, resolves the dependencies, and installs them.\n\npoetry install\n\n\nIf there is a poetry.lock file in the current directory, it will use the exact versions from there instead of resolving them. This ensures that everyone using the library will get the same versions of the dependencies.\n\nIf there is no poetry.lock file, Poetry will create one after dependency resolution.\n\nIf you want to exclude one or more dependency groups for the installation, you can use the --without option.\n\npoetry install --without test,docs\n\nThe --no-dev option is now deprecated. You should use the --only main or --without dev notation instead.\n\nYou can also select optional dependency groups with the --with option.\n\npoetry install --with test,docs\n\n\nIt’s also possible to only install specific dependency groups by using the only option.\n\npoetry install --only test,docs\n\n\nTo only install the project itself with no dependencies, use the --only-root flag.\n\npoetry install --only-root\n\n\nSee Dependency groups for more information about dependency groups.\n\nIf you want to synchronize your environment – and ensure it matches the lock file – use the --sync option.\n\npoetry install --sync\n\n\nThe --sync can be combined with group-related options:\n\npoetry install --without dev --sync\npoetry install --with docs --sync\npoetry install --only dev --sync\n\n\nYou can also specify the extras you want installed by passing the -E|--extras option (See Extras for more info). Pass --all-extras to install all defined extras for a project.\n\npoetry install --extras \"mysql pgsql\"\npoetry install -E mysql -E pgsql\npoetry install --all-extras\n\n\nExtras are not sensitive to --sync. Any extras not specified will always be removed.\n\npoetry install --extras \"A B\"  # C is removed\n\n\nBy default poetry will install your project’s package every time you run install:\n\n$ poetry install\nInstalling dependencies from lock file\n\nNo dependencies to install or update\n\n  - Installing <your-package-name> (x.x.x)\n\n\nIf you want to skip this installation, use the --no-root option.\n\npoetry install --no-root\n\n\nSimilar to --no-root you can use --no-directory to skip directory path dependencies:\n\npoetry install --no-directory\n\n\nThis is mainly useful for caching in CI or when building Docker images. See the FAQ entry for more information on this option.\n\nBy default poetry does not compile Python source files to bytecode during installation. This speeds up the installation process, but the first execution may take a little more time because Python then compiles source files to bytecode automatically. If you want to compile source files to bytecode during installation, you can use the --compile option:\n\npoetry install --compile\n\nThe --compile option has no effect if installer.modern-installation is set to false because the old installer always compiles source files to bytecode.\nOptions\n--without: The dependency groups to ignore.\n--with: The optional dependency groups to include.\n--only: The only dependency groups to include.\n--only-root: Install only the root project, exclude all dependencies.\n--sync: Synchronize the environment with the locked packages and the specified groups.\n--no-root: Do not install the root package (your project).\n--no-directory: Skip all directory path dependencies (including transitive ones).\n--dry-run: Output the operations but do not execute anything (implicitly enables –verbose).\n--extras (-E): Features to install (multiple values allowed).\n--all-extras: Install all extra features (conflicts with –extras).\n--compile: Compile Python source files to bytecode.\n--no-dev: Do not install dev dependencies. (Deprecated, use --only main or --without dev instead)\n--remove-untracked: Remove dependencies not presented in the lock file. (Deprecated, use --sync instead)\nWhen --only is specified, --with and --without options are ignored.\nupdate\n\nIn order to get the latest versions of the dependencies and to update the poetry.lock file, you should use the update command.\n\npoetry update\n\n\nThis will resolve all dependencies of the project and write the exact versions into poetry.lock.\n\nIf you just want to update a few packages and not all, you can list them as such:\n\npoetry update requests toml\n\n\nNote that this will not update versions for dependencies outside their version constraints specified in the pyproject.toml file. In other terms, poetry update foo will be a no-op if the version constraint specified for foo is ~2.3 or 2.3 and 2.4 is available. In order for foo to be updated, you must update the constraint, for example ^2.3. You can do this using the add command.\n\nOptions\n--without: The dependency groups to ignore.\n--with: The optional dependency groups to include.\n--only: The only dependency groups to include.\n--dry-run : Outputs the operations but will not execute anything (implicitly enables –verbose).\n--no-dev : Do not update the development dependencies. (Deprecated, use --only main or --without dev instead)\n--lock : Do not perform install (only update the lockfile).\n--sync: Synchronize the environment with the locked packages and the specified groups.\nWhen --only is specified, --with and --without options are ignored.\nadd\n\nThe add command adds required packages to your pyproject.toml and installs them.\n\nIf you do not specify a version constraint, poetry will choose a suitable one based on the available package versions.\n\npoetry add requests pendulum\n\n\nA package is looked up, by default, only from the Default Package Source. You can modify the default source (PyPI); or add and use Supplemental Package Sources or Explicit Package Sources.\n\nFor more information, refer to the Package Sources documentation.\n\nYou can also specify a constraint when adding a package:\n\n# Allow >=2.0.5, <3.0.0 versions\npoetry add pendulum@^2.0.5\n\n# Allow >=2.0.5, <2.1.0 versions\npoetry add pendulum@~2.0.5\n\n# Allow >=2.0.5 versions, without upper bound\npoetry add \"pendulum>=2.0.5\"\n\n# Allow only 2.0.5 version\npoetry add pendulum==2.0.5\n\nSee the Dependency specification page for more information about the @ operator.\n\nIf you try to add a package that is already present, you will get an error. However, if you specify a constraint, like above, the dependency will be updated by using the specified constraint.\n\nIf you want to get the latest version of an already present dependency, you can use the special latest constraint:\n\npoetry add pendulum@latest\n\nSee the Dependency specification for more information on setting the version constraints for a package.\n\nYou can also add git dependencies:\n\npoetry add git+https://github.com/sdispater/pendulum.git\n\n\nor use ssh instead of https:\n\npoetry add git+ssh://git@github.com/sdispater/pendulum.git\n\n# or alternatively:\npoetry add git+ssh://git@github.com:sdispater/pendulum.git\n\n\nIf you need to checkout a specific branch, tag or revision, you can specify it when using add:\n\npoetry add git+https://github.com/sdispater/pendulum.git#develop\npoetry add git+https://github.com/sdispater/pendulum.git#2.0.5\n\n# or using SSH instead:\npoetry add git+ssh://git@github.com:sdispater/pendulum.git#develop\npoetry add git+ssh://git@github.com:sdispater/pendulum.git#2.0.5\n\n\nor reference a subdirectory:\n\npoetry add git+https://github.com/myorg/mypackage_with_subdirs.git@main#subdirectory=subdir\n\n\nYou can also add a local directory or file:\n\npoetry add ./my-package/\npoetry add ../my-package/dist/my-package-0.1.0.tar.gz\npoetry add ../my-package/dist/my_package-0.1.0.whl\n\n\nIf you want the dependency to be installed in editable mode you can use the --editable option.\n\npoetry add --editable ./my-package/\npoetry add --editable git+ssh://github.com/sdispater/pendulum.git#develop\n\n\nAlternatively, you can specify it in the pyproject.toml file. It means that changes in the local directory will be reflected directly in environment.\n\n[tool.poetry.dependencies]\nmy-package = {path = \"../my/path\", develop = true}\n\nBefore poetry 1.1 path dependencies were installed in editable mode by default. You should always set the develop attribute explicitly, to make sure the behavior is the same for all poetry versions.\nThe develop attribute is a Poetry-specific feature, so it is not included in the package distribution metadata. In other words, it is only considered when using Poetry to install the project.\n\nIf the package(s) you want to install provide extras, you can specify them when adding the package:\n\npoetry add \"requests[security,socks]\"\npoetry add \"requests[security,socks]~=2.22.0\"\npoetry add \"git+https://github.com/pallets/flask.git@1.1.1[dotenv,dev]\"\n\nSome shells may treat square braces ([ and ]) as special characters. It is suggested to always quote arguments containing these characters to prevent unexpected shell expansion.\n\nIf you want to add a package to a specific group of dependencies, you can use the --group (-G) option:\n\npoetry add mkdocs --group docs\n\n\nSee Dependency groups for more information about dependency groups.\n\nOptions\n--group (-G): The group to add the dependency to.\n--dev (-D): Add package as development dependency. (Deprecated, use -G dev instead)\n--editable (-e): Add vcs/path dependencies as editable.\n--extras (-E): Extras to activate for the dependency. (multiple values allowed)\n--optional: Add as an optional dependency.\n--python: Python version for which the dependency must be installed.\n--platform: Platforms for which the dependency must be installed.\n--source: Name of the source to use to install the package.\n--allow-prereleases: Accept prereleases.\n--dry-run: Output the operations but do not execute anything (implicitly enables –verbose).\n--lock: Do not perform install (only update the lockfile).\nremove\n\nThe remove command removes a package from the current list of installed packages.\n\npoetry remove pendulum\n\n\nIf you want to remove a package from a specific group of dependencies, you can use the --group (-G) option:\n\npoetry remove mkdocs --group docs\n\n\nSee Dependency groups for more information about dependency groups.\n\nOptions\n--group (-G): The group to remove the dependency from.\n--dev (-D): Removes a package from the development dependencies. (Deprecated, use -G dev instead)\n--dry-run : Outputs the operations but will not execute anything (implicitly enables –verbose).\n--lock: Do not perform operations (only update the lockfile).\nshow\n\nTo list all the available packages, you can use the show command.\n\npoetry show\n\n\nIf you want to see the details of a certain package, you can pass the package name.\n\npoetry show pendulum\n\nname        : pendulum\nversion     : 1.4.2\ndescription : Python datetimes made easy\n\ndependencies\n - python-dateutil >=2.6.1\n - tzlocal >=1.4\n - pytzdata >=2017.2.2\n\nrequired by\n - calendar >=1.4.0\n\nOptions\n--without: The dependency groups to ignore.\n--why: When showing the full list, or a --tree for a single package, display whether they are a direct dependency or required by other packages.\n--with: The optional dependency groups to include.\n--only: The only dependency groups to include.\n--no-dev: Do not list the dev dependencies. (Deprecated, use --only main or --without dev instead)\n--tree: List the dependencies as a tree.\n--latest (-l): Show the latest version.\n--outdated (-o): Show the latest version but only for packages that are outdated.\n--all (-a): Show all packages (even those not compatible with current system).\n--top-level (-T): Only show explicitly defined packages.\nWhen --only is specified, --with and --without options are ignored.\nbuild\n\nThe build command builds the source and wheels archives.\n\npoetry build\n\n\nNote that, at the moment, only pure python wheels are supported.\n\nOptions\n--format (-f): Limit the format to either wheel or sdist.\n--clean: Clean output directory before building.\n--local-version (-l): Add or replace a local version label to the build.\n--output (-o): Set output directory for build artifacts. Default is dist.\nWhen using --local-version, the identifier must be PEP 440 compliant. This is useful for adding build numbers, platform specificities etc. for private packages.\n\nLocal version identifiers SHOULD NOT be used when publishing upstream projects to a public index server, but MAY be used to identify private builds created directly from the project source.\n\nSee PEP 440 for more information.\n\npublish\n\nThis command publishes the package, previously built with the build command, to the remote repository.\n\nIt will automatically register the package before uploading if this is the first time it is submitted.\n\npoetry publish\n\n\nIt can also build the package if you pass it the --build option.\n\nSee Publishable Repositories for more information on how to configure and use publishable repositories.\nOptions\n--repository (-r): The repository to register the package to (default: pypi). Should match a repository name set by the config command.\n--username (-u): The username to access the repository.\n--password (-p): The password to access the repository.\n--cert: Certificate authority to access the repository.\n--client-cert: Client certificate to access the repository.\n--dist-dir: Dist directory where built artifact are stored. Default is dist.\n--build: Build the package before publishing.\n--dry-run: Perform all actions except upload the package.\n--skip-existing: Ignore errors from files already existing in the repository.\nSee Configuring Credentials for more information on how to configure credentials.\nconfig\n\nThe config command allows you to edit poetry config settings and repositories.\n\npoetry config --list\n\nUsage\npoetry config [options] [setting-key] [setting-value1] ... [setting-valueN]\n\n\nsetting-key is a configuration option name and setting-value1 is a configuration value. See Configuration for all available settings.\n\nUse -- to terminate option parsing if your values may start with a hyphen (-), e.g.\n\npoetry config http-basic.custom-repo gitlab-ci-token -- ${GITLAB_JOB_TOKEN}\n\n\nWithout -- this command will fail if ${GITLAB_JOB_TOKEN} starts with a hyphen.\n\nOptions\n--unset: Remove the configuration element named by setting-key.\n--list: Show the list of current config variables.\n--local: Set/Get settings that are specific to a project (in the local configuration file poetry.toml).\nrun\n\nThe run command executes the given command inside the project’s virtualenv.\n\npoetry run python -V\n\n\nIt can also execute one of the scripts defined in pyproject.toml.\n\nSo, if you have a script defined like this:\n\n[tool.poetry.scripts]\nmy-script = \"my_module:main\"\n\n\nYou can execute it like so:\n\npoetry run my-script\n\n\nNote that this command has no option.\n\nshell\n\nThe shell command spawns a shell within the project’s virtual environment.\n\nBy default, the current active shell is detected and used. Failing that, the shell defined via the environment variable SHELL (on *nix) or COMSPEC (on Windows) is used.\n\nIf a virtual environment does not exist, it will be created.\n\npoetry shell\n\n\nNote that this command starts a new shell and activates the virtual environment.\n\nAs such, exit should be used to properly exit the shell and the virtual environment instead of deactivate.\n\nPoetry internally uses the Shellingham project to detect current active shell.\ncheck\n\nThe check command validates the content of the pyproject.toml file and its consistency with the poetry.lock file. It returns a detailed report if there are any errors.\n\nThis command is also available as a pre-commit hook. See pre-commit hooks for more information.\npoetry check\n\nOptions\n--lock: Verifies that poetry.lock exists for the current pyproject.toml.\nsearch\n\nThis command searches for packages on a remote index.\n\npoetry search requests pendulum\n\nlock\n\nThis command locks (without installing) the dependencies specified in pyproject.toml.\n\nBy default, this will lock all dependencies to the latest available compatible versions. To only refresh the lock file, use the --no-update option. This command is also available as a pre-commit hook. See pre-commit hooks for more information.\npoetry lock\n\nOptions\n--check: Verify that poetry.lock is consistent with pyproject.toml. (Deprecated) Use poetry check --lock instead.\n--no-update: Do not update locked versions, only refresh lock file.\nversion\n\nThis command shows the current version of the project or bumps the version of the project and writes the new version back to pyproject.toml if a valid bump rule is provided.\n\nThe new version should be a valid PEP 440 string or a valid bump rule: patch, minor, major, prepatch, preminor, premajor, prerelease.\n\nIf you would like to use semantic versioning for your project, please see here.\n\nThe table below illustrates the effect of these rules with concrete examples.\n\nRULE\tBEFORE\tAFTER\nmajor\t1.3.0\t2.0.0\nminor\t2.1.4\t2.2.0\npatch\t4.1.1\t4.1.2\npremajor\t1.0.2\t2.0.0a0\npreminor\t1.0.2\t1.1.0a0\nprepatch\t1.0.2\t1.0.3a0\nprerelease\t1.0.2\t1.0.3a0\nprerelease\t1.0.3a0\t1.0.3a1\nprerelease\t1.0.3b0\t1.0.3b1\n\nThe option --next-phase allows the increment of prerelease phase versions.\n\nRULE\tBEFORE\tAFTER\nprerelease –next-phase\t1.0.3a0\t1.0.3b0\nprerelease –next-phase\t1.0.3b0\t1.0.3rc0\nprerelease –next-phase\t1.0.3rc0\t1.0.3\nOptions\n--next-phase: Increment the phase of the current version.\n--short (-s): Output the version number only.\n--dry-run: Do not update pyproject.toml file.\nexport\n\nThis command exports the lock file to other formats.\n\npoetry export -f requirements.txt --output requirements.txt\n\nThis command is provided by the Export Poetry Plugin. In a future version of Poetry this plugin will not be installed by default anymore. In order to avoid a breaking change and make your automation forward-compatible, please install poetry-plugin-export explicitly. See Using plugins for details on how to install a plugin.\nThis command is also available as a pre-commit hook. See pre-commit hooks for more information.\nUnlike the install command, this command only includes the project’s dependencies defined in the implicit main group defined in tool.poetry.dependencies when used without specifying any options.\nOptions\n--format (-f): The format to export to (default: requirements.txt). Currently, only constraints.txt and requirements.txt are supported.\n--output (-o): The name of the output file. If omitted, print to standard output.\n--dev: Include development dependencies. (Deprecated, use --with dev instead)\n--extras (-E): Extra sets of dependencies to include.\n--without: The dependency groups to ignore.\n--with: The optional dependency groups to include.\n--only: The only dependency groups to include.\n--without-hashes: Exclude hashes from the exported file.\n--without-urls: Exclude source repository urls from the exported file.\n--with-credentials: Include credentials for extra indices.\nenv\n\nThe env command regroups sub commands to interact with the virtualenvs associated with a specific project.\n\nSee Managing environments for more information about these commands.\n\ncache\n\nThe cache command regroups sub commands to interact with Poetry’s cache.\n\ncache list\n\nThe cache list command lists Poetry’s available caches.\n\npoetry cache list\n\ncache clear\n\nThe cache clear command removes packages from a cached repository.\n\nFor example, to clear the whole cache of packages from the pypi repository, run:\n\npoetry cache clear pypi --all\n\n\nTo only remove a specific package from a cache, you have to specify the cache entry in the following form cache:package:version:\n\npoetry cache clear pypi:requests:2.24.0\n\nsource\n\nThe source namespace regroups sub commands to manage repository sources for a Poetry project.\n\nsource add\n\nThe source add command adds source configuration to the project.\n\nFor example, to add the pypi-test source, you can run:\n\npoetry source add pypi-test https://test.pypi.org/simple/\n\n\nYou cannot use the name pypi for a custom repository as it is reserved for use by the default PyPI source. However, you can set the priority of PyPI:\n\npoetry source add --priority=explicit pypi\n\nOptions\n--default: Set this source as the default (disable PyPI). Deprecated in favor of --priority.\n--secondary: Set this source as a secondary source. Deprecated in favor of --priority.\n--priority: Set the priority of this source. Accepted values are: default, secondary, supplemental, and explicit. Refer to the dedicated sections in Repositories for more information.\nAt most one of the options above can be provided. See package sources for more information.\nsource show\n\nThe source show command displays information on all configured sources for the project.\n\npoetry source show\n\n\nOptionally, you can show information of one or more sources by specifying their names.\n\npoetry source show pypi-test\n\nThis command will only show sources configured via the pyproject.toml and does not include the implicit default PyPI.\nsource remove\n\nThe source remove command removes a configured source from your pyproject.toml.\n\npoetry source remove pypi-test\n\nabout\n\nThe about command displays global information about Poetry, including the current version and version of poetry-core.\n\npoetry about\n\nhelp\n\nThe help command displays global help, or help for a specific command.\n\nTo display global help:\n\npoetry help\n\n\nTo display help for a specific command, for instance show:\n\npoetry help show\n\n\nThe --help option can also be passed to any command to get help for a specific command.\n\nFor instance:\n\npoetry show --help\n\nlist\n\nThe list command displays all the available Poetry commands.\n\npoetry list\n\nself\n\nThe self namespace regroups sub commands to manage the Poetry installation itself.\n\nUse of these commands will create the required pyproject.toml and poetry.lock files in your configuration directory.\nEspecially on Windows, self commands that update or remove packages may be problematic so that other methods for installing plugins and updating Poetry are recommended. See Using plugins and Installing Poetry for more information.\nself add\n\nThe self add command installs Poetry plugins and make them available at runtime. Additionally, it can also be used to upgrade Poetry’s own dependencies or inject additional packages into the runtime environment\n\nThe self add command works exactly like the add command. However, is different in that the packages managed are for Poetry’s runtime environment.\n\nThe package specification formats supported by the self add command are the same as the ones supported by the add command.\n\nFor example, to install the poetry-plugin-export plugin, you can run:\n\npoetry self add poetry-plugin-export\n\n\nTo update to the latest poetry-core version, you can run:\n\npoetry self add poetry-core@latest\n\n\nTo add a keyring provider artifacts-keyring, you can run:\n\npoetry self add artifacts-keyring\n\nOptions\n--editable (-e): Add vcs/path dependencies as editable.\n--extras (-E): Extras to activate for the dependency. (multiple values allowed)\n--allow-prereleases: Accept prereleases.\n--source: Name of the source to use to install the package.\n--dry-run: Output the operations but do not execute anything (implicitly enables –verbose).\nself update\n\nThe self update command updates Poetry version in its current runtime environment.\n\nThe self update command works exactly like the update command. However, is different in that the packages managed are for Poetry’s runtime environment.\npoetry self update\n\nOptions\n--preview: Allow the installation of pre-release versions.\n--dry-run: Output the operations but do not execute anything (implicitly enables –verbose).\nself lock\n\nThe self lock command reads this Poetry installation’s system pyproject.toml file. The system dependencies are locked in the corresponding poetry.lock file.\n\npoetry self lock\n\nOptions\n--check: Verify that poetry.lock is consistent with pyproject.toml. (Deprecated)\n--no-update: Do not update locked versions, only refresh lock file.\nself show\n\nThe self show command behaves similar to the show command, but working within Poetry’s runtime environment. This lists all packages installed within the Poetry install environment.\n\nTo show only additional packages that have been added via self add and their dependencies use self show --addons.\n\npoetry self show\n\nOptions\n--addons: List only add-on packages installed.\n--tree: List the dependencies as a tree.\n--latest (-l): Show the latest version.\n--outdated (-o): Show the latest version but only for packages that are outdated.\nself show plugins\n\nThe self show plugins command lists all the currently installed plugins.\n\npoetry self show plugins\n\nself remove\n\nThe self remove command removes an installed addon package.\n\npoetry self remove poetry-plugin-export\n\nOptions\n--dry-run: Outputs the operations but will not execute anything (implicitly enables –verbose).\nself install\n\nThe self install command ensures all additional packages specified are installed in the current runtime environment.\n\nThe self install command works similar to the install command. However, is different in that the packages managed are for Poetry’s runtime environment.\npoetry self install --sync\n\nOptions\n--sync: Synchronize the environment with the locked packages and the specified groups.\n--dry-run: Output the operations but do not execute anything (implicitly enables –verbose).\nFooter\n\nPython packaging and dependency management made easy.\n\nGitHub\nDiscord\nDOCUMENTATION\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\n GITHUB\nProject\nIssues\nDiscussions\nOTHER PROJECTS\npoetry-core\ninstall.python-poetry.org\nBundle plugin\nExport plugin\n\nCopyright © 2018-2024. All Rights Reserved.\nPowered by"
  },
  {
    "title": "Configuration | main | Documentation | Poetry - Python dependency management and packaging made easy",
    "url": "https://python-poetry.org/docs/main/configuration/",
    "html": "Home\nSearch\nmain\nUse dark mode\nDOCUMENTATION\nBLOG\nHISTORY\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nLocal configuration\nListing the current configuration\nDisplaying a single configuration setting\nAdding or updating a configuration setting\nRemoving a specific setting\nUsing environment variables\nDefault Directories\nConfig Directory\nData Directory\nCache Directory\nAvailable settings\ncache-dir\nexperimental.system-git-client\ninstaller.max-workers\ninstaller.modern-installation\ninstaller.no-binary\ninstaller.only-binary\ninstaller.parallel\nsolver.lazy-wheel\nvirtualenvs.create\nvirtualenvs.in-project\nvirtualenvs.options.always-copy\nvirtualenvs.options.no-pip\nvirtualenvs.options.no-setuptools\nvirtualenvs.options.system-site-packages\nvirtualenvs.path\nvirtualenvs.prefer-active-python (experimental)\nvirtualenvs.prompt\nrepositories.<name>.url\nhttp-basic.<name>.[username|password]:\npypi-token.<name>:\ncertificates.<name>.cert:\ncertificates.<name>.client-cert:\nkeyring.enabled:\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\nConfiguration\n\nPoetry can be configured via the config command (see more about its usage here) or directly in the config.toml file that will be automatically created when you first run that command. This file can typically be found in one of the following directories:\n\nmacOS: ~/Library/Application Support/pypoetry\nWindows: %APPDATA%\\pypoetry\n\nFor Unix, we follow the XDG spec and support $XDG_CONFIG_HOME. That means, by default ~/.config/pypoetry.\n\nLocal configuration\n\nPoetry also provides the ability to have settings that are specific to a project by passing the --local option to the config command.\n\npoetry config virtualenvs.create false --local\n\nYour local configuration of Poetry application is stored in the poetry.toml file, which is separate from pyproject.toml.\nBe mindful about checking in this file into your repository since it may contain user-specific or sensitive information.\nListing the current configuration\n\nTo list the current configuration you can use the --list option of the config command:\n\npoetry config --list\n\n\nwhich will give you something similar to this:\n\ncache-dir = \"/path/to/cache/directory\"\nvirtualenvs.create = true\nvirtualenvs.in-project = null\nvirtualenvs.options.always-copy = true\nvirtualenvs.options.no-pip = false\nvirtualenvs.options.no-setuptools = false\nvirtualenvs.options.system-site-packages = false\nvirtualenvs.path = \"{cache-dir}/virtualenvs\"  # /path/to/cache/directory/virtualenvs\nvirtualenvs.prefer-active-python = false\nvirtualenvs.prompt = \"{project_name}-py{python_version}\"\n\nDisplaying a single configuration setting\n\nIf you want to see the value of a specific setting, you can give its name to the config command\n\npoetry config virtualenvs.path\n\n\nFor a full list of the supported settings see Available settings.\n\nAdding or updating a configuration setting\n\nTo change or otherwise add a new configuration setting, you can pass a value after the setting’s name:\n\npoetry config virtualenvs.path /path/to/cache/directory/virtualenvs\n\n\nFor a full list of the supported settings see Available settings.\n\nRemoving a specific setting\n\nIf you want to remove a previously set setting, you can use the --unset option:\n\npoetry config virtualenvs.path --unset\n\n\nThe setting will then retrieve its default value.\n\nUsing environment variables\n\nSometimes, in particular when using Poetry with CI tools, it’s easier to use environment variables and not have to execute configuration commands.\n\nPoetry supports this and any setting can be set by using environment variables.\n\nThe environment variables must be prefixed by POETRY_ and are comprised of the uppercase name of the setting and with dots and dashes replaced by underscore, here is an example:\n\nexport POETRY_VIRTUALENVS_PATH=/path/to/virtualenvs/directory\n\n\nThis also works for secret settings, like credentials:\n\nexport POETRY_HTTP_BASIC_MY_REPOSITORY_PASSWORD=secret\n\nDefault Directories\n\nPoetry uses the following default directories:\n\nConfig Directory\nLinux: $XDG_CONFIG_HOME/pypoetry or ~/.config/pypoetry\nWindows: %APPDATA%\\pypoetry\nMacOS: ~/Library/Application Support/pypoetry\n\nYou can override the Config directory by setting the POETRY_CONFIG_DIR environment variable.\n\nData Directory\nLinux: $XDG_DATA_HOME/pypoetry or ~/.local/share/pypoetry\nWindows: %APPDATA%\\pypoetry\nMacOS: ~/Library/Application Support/pypoetry\n\nYou can override the Data directory by setting the POETRY_DATA_DIR or POETRY_HOME environment variables. If POETRY_HOME is set, it will be given higher priority.\n\nCache Directory\nLinux: $XDG_CACHE_HOME/pypoetry or ~/.cache/pypoetry\nWindows: %LOCALAPPDATA%\\pypoetry\nMacOS: ~/Library/Caches/pypoetry\n\nYou can override the Cache directory by setting the POETRY_CACHE_DIR environment variable.\n\nAvailable settings\ncache-dir\n\nType: string\n\nEnvironment Variable: POETRY_CACHE_DIR\n\nThe path to the cache directory used by Poetry.\n\nDefaults to one of the following directories:\n\nmacOS: ~/Library/Caches/pypoetry\nWindows: C:\\Users\\<username>\\AppData\\Local\\pypoetry\\Cache\nUnix: ~/.cache/pypoetry\nexperimental.system-git-client\n\nType: boolean\n\nDefault: false\n\nEnvironment Variable: POETRY_EXPERIMENTAL_SYSTEM_GIT_CLIENT\n\nIntroduced in 1.2.0\n\nUse system git client backend for git related tasks.\n\nPoetry uses dulwich by default for git related tasks to not rely on the availability of a git client.\n\nIf you encounter any problems with it, set to true to use the system git backend.\n\ninstaller.max-workers\n\nType: int\n\nDefault: number_of_cores + 4\n\nEnvironment Variable: POETRY_INSTALLER_MAX_WORKERS\n\nIntroduced in 1.2.0\n\nSet the maximum number of workers while using the parallel installer. The number_of_cores is determined by os.cpu_count(). If this raises a NotImplementedError exception, number_of_cores is assumed to be 1.\n\nIf this configuration parameter is set to a value greater than number_of_cores + 4, the number of maximum workers is still limited at number_of_cores + 4.\n\nThis configuration is ignored when installer.parallel is set to false.\ninstaller.modern-installation\n\nType: boolean\n\nDefault: true\n\nEnvironment Variable: POETRY_INSTALLER_MODERN_INSTALLATION\n\nIntroduced in 1.4.0\n\nUse a more modern and faster method for package installation.\n\nIf this causes issues, you can disable it by setting it to false and report the problems you encounter on the issue tracker.\n\ninstaller.no-binary\n\nType: string | boolean\n\nDefault: false\n\nEnvironment Variable: POETRY_INSTALLER_NO_BINARY\n\nIntroduced in 1.2.0\n\nWhen set, this configuration allows users to disallow the use of binary distribution format for all, none or specific packages.\n\nCONFIGURATION\tDESCRIPTION\n:all: or true\tDisallow binary distributions for all packages.\n:none: or false\tAllow binary distributions for all packages.\npackage[,package,..]\tDisallow binary distributions for specified packages only.\nAs with all configurations described here, this is a user specific configuration. This means that this is not taken into consideration when a lockfile is generated or dependencies are resolved. This is applied only when selecting which distribution for dependency should be installed into a Poetry managed environment.\n\nFor project specific usage, it is recommended that this be configured with the --local.\n\npoetry config --local installer.no-binary :all:\n\n\nFor CI or container environments using environment variable to configure this might be useful.\n\nexport POETRY_INSTALLER_NO_BINARY=:all:\n\nUnless this is required system-wide, if configured globally, you could encounter slower install times across all your projects if incorrectly set.\ninstaller.only-binary\n\nType: string | boolean\n\nDefault: false\n\nEnvironment Variable: POETRY_INSTALLER_ONLY_BINARY\n\nIntroduced in 1.9.0\n\nWhen set, this configuration allows users to enforce the use of binary distribution format for all, none or specific packages.\n\nPlease refer to installer.no-binary for information on allowed values, usage instructions and warnings.\ninstaller.parallel\n\nType: boolean\n\nDefault: true\n\nEnvironment Variable: POETRY_INSTALLER_PARALLEL\n\nIntroduced in 1.1.4\n\nUse parallel execution when using the new (>=1.1.0) installer.\n\nsolver.lazy-wheel\n\nType: boolean\n\nDefault: true\n\nEnvironment Variable: POETRY_SOLVER_LAZY_WHEEL\n\nIntroduced in 1.8.0\n\nDo not download entire wheels to extract metadata but use HTTP range requests to only download the METADATA files of wheels. Especially with slow network connections this setting can speed up dependency resolution significantly. If the cache has already been filled or the server does not support HTTP range requests, this setting makes no difference.\n\nvirtualenvs.create\n\nType: boolean\n\nDefault: true\n\nEnvironment Variable: POETRY_VIRTUALENVS_CREATE\n\nCreate a new virtual environment if one doesn’t already exist.\n\nIf set to false, Poetry will not create a new virtual environment. If it detects an already enabled virtual environment or an existing one in {cache-dir}/virtualenvs or {project-dir}/.venv it will install dependencies into them, otherwise it will install dependencies into the systems python environment.\n\nIf Poetry detects it’s running within an activated virtual environment, it will never create a new virtual environment, regardless of the value set for virtualenvs.create.\n\nBe aware that installing dependencies into the system environment likely upgrade or uninstall existing packages and thus break other applications. Installing additional Python packages after installing the project might break the Poetry project in return.\n\nThis is why it is recommended to always create a virtual environment. This is also true in Docker containers, as they might contain additional Python packages as well.\n\nvirtualenvs.in-project\n\nType: boolean\n\nDefault: None\n\nEnvironment Variable: POETRY_VIRTUALENVS_IN_PROJECT\n\nCreate the virtualenv inside the project’s root directory.\n\nIf not set explicitly, poetry by default will create a virtual environment under {cache-dir}/virtualenvs or use the {project-dir}/.venv directory if one already exists.\n\nIf set to true, the virtualenv will be created and expected in a folder named .venv within the root directory of the project.\n\nIf a virtual environment has already been created for the project under {cache-dir}/virtualenvs, setting this variable to true will not cause poetry to create or use a local virtual environment.\n\nIn order for this setting to take effect for a project already in that state, you must delete the virtual environment folder located in {cache-dir}/virtualenvs.\n\nYou can find out where the current project’s virtual environment (if there is one) is stored with the command poetry env info --path.\n\nIf set to false, poetry will ignore any existing .venv directory.\n\nvirtualenvs.options.always-copy\n\nType: boolean\n\nDefault: false\n\nEnvironment Variable: POETRY_VIRTUALENVS_OPTIONS_ALWAYS_COPY\n\nIntroduced in 1.2.0\n\nIf set to true the --always-copy parameter is passed to virtualenv on creation of the virtual environment, so that all needed files are copied into it instead of symlinked.\n\nvirtualenvs.options.no-pip\n\nType: boolean\n\nDefault: false\n\nEnvironment Variable: POETRY_VIRTUALENVS_OPTIONS_NO_PIP\n\nIntroduced in 1.2.0\n\nIf set to true the --no-pip parameter is passed to virtualenv on creation of the virtual environment. This means when a new virtual environment is created, pip will not be installed in the environment.\n\nPoetry, for its internal operations, uses the pip wheel embedded in the virtualenv package installed as a dependency in Poetry’s runtime environment. If a user runs poetry run pip when this option is set to true, the pip the embedded instance of pip is used.\n\nYou can safely set this, along with no-setuptools, to true, if you desire a virtual environment with no additional packages. This is desirable for production environments.\n\nvirtualenvs.options.no-setuptools\n\nType: boolean\n\nDefault: false\n\nEnvironment Variable: POETRY_VIRTUALENVS_OPTIONS_NO_SETUPTOOLS\n\nIntroduced in 1.2.0\n\nIf set to true the --no-setuptools parameter is passed to virtualenv on creation of the virtual environment. This means when a new virtual environment is created, setuptools will not be installed in the environment. Poetry, for its internal operations, does not require setuptools and this can safely be set to true.\n\nFor environments using python 3.12 or later, virtualenv defaults to not installing setuptools when creating a virtual environment. In such environments this poetry configuration option therefore has no effect: setuptools is not installed either way. If your project relies on setuptools, you should declare it as a dependency.\n\nSome development tools like IDEs, make an assumption that setuptools (and other) packages are always present and available within a virtual environment. This can cause some features in these tools to not work as expected.\nvirtualenvs.options.system-site-packages\n\nType: boolean\n\nDefault: false\n\nEnvironment Variable: POETRY_VIRTUALENVS_OPTIONS_SYSTEM_SITE_PACKAGES\n\nGive the virtual environment access to the system site-packages directory. Applies on virtualenv creation.\n\nvirtualenvs.path\n\nType: string\n\nDefault: {cache-dir}/virtualenvs\n\nEnvironment Variable: POETRY_VIRTUALENVS_PATH\n\nDirectory where virtual environments will be created.\n\nThis setting controls the global virtual environment storage path. It most likely will not be useful at the local level. To store virtual environments in the project root, see virtualenvs.in-project.\nvirtualenvs.prefer-active-python (experimental)\n\nType: boolean\n\nDefault: false\n\nEnvironment Variable: POETRY_VIRTUALENVS_PREFER_ACTIVE_PYTHON\n\nIntroduced in 1.2.0\n\nUse currently activated Python version to create a new virtual environment. If set to false, Python version used during Poetry installation is used.\n\nvirtualenvs.prompt\n\nType: string\n\nDefault: {project_name}-py{python_version}\n\nEnvironment Variable: POETRY_VIRTUALENVS_PROMPT\n\nIntroduced in 1.2.0\n\nFormat string defining the prompt to be displayed when the virtual environment is activated. The variables project_name and python_version are available for formatting.\n\nrepositories.<name>.url\n\nType: string\n\nEnvironment Variable: POETRY_REPOSITORIES_<NAME>_URL\n\nSet the repository URL for <name>.\n\nSee Publishable Repositories for more information.\n\nhttp-basic.<name>.[username|password]:\n\nType: string\n\nEnvironment Variables: POETRY_HTTP_BASIC_<NAME>_USERNAME, POETRY_HTTP_BASIC_<NAME>_PASSWORD\n\nSet repository credentials (username and password) for <name>. See Repositories - Configuring credentials for more information.\n\npypi-token.<name>:\n\nType: string\n\nEnvironment Variable: POETRY_PYPI_TOKEN_<NAME>\n\nSet repository credentials (using an API token) for <name>. See Repositories - Configuring credentials for more information.\n\ncertificates.<name>.cert:\n\nType: string | boolean\n\nEnvironment Variable: POETRY_CERTIFICATES_<NAME>_CERT\n\nSet custom certificate authority for repository <name>. See Repositories - Configuring credentials - Custom certificate authority for more information.\n\nThis configuration can be set to false, if TLS certificate verification should be skipped for this repository.\n\ncertificates.<name>.client-cert:\n\nType: string\n\nEnvironment Variable: POETRY_CERTIFICATES_<NAME>_CLIENT_CERT\n\nSet client certificate for repository <name>. See Repositories - Configuring credentials - Custom certificate authority for more information.\n\nkeyring.enabled:\n\nType: boolean\n\nDefault: true\n\nEnvironment Variable: POETRY_KEYRING_ENABLED\n\nEnable the system keyring for storing credentials. See Repositories - Configuring credentials for more information.\n\nFooter\n\nPython packaging and dependency management made easy.\n\nGitHub\nDiscord\nDOCUMENTATION\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\n GITHUB\nProject\nIssues\nDiscussions\nOTHER PROJECTS\npoetry-core\ninstall.python-poetry.org\nBundle plugin\nExport plugin\n\nCopyright © 2018-2024. All Rights Reserved.\nPowered by"
  },
  {
    "title": "Libraries | main | Documentation | Poetry - Python dependency management and packaging made easy",
    "url": "https://python-poetry.org/docs/main/libraries/",
    "html": "Home\nSearch\nmain\nUse dark mode\nDOCUMENTATION\nBLOG\nHISTORY\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nVersioning\nLock file\nPackaging\nPublishing to PyPI\nPublishing to a private repository\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\nLibraries\n\nThis chapter will tell you how to make your library installable through Poetry.\n\nVersioning\n\nPoetry requires PEP 440-compliant versions for all projects.\n\nWhile Poetry does not enforce any release convention, it used to encourage the use of semantic versioning within the scope of PEP 440 and supports version constraints that are especially suitable for semver.\n\nAs an example, 1.0.0-hotfix.1 is not compatible with PEP 440. You can instead choose to use 1.0.0-post1 or 1.0.0.post1.\nLock file\n\nFor your library, you may commit the poetry.lock file if you want to. This can help your team to always test against the same dependency versions. However, this lock file will not have any effect on other projects that depend on it. It only has an effect on the main project.\n\nIf you do not want to commit the lock file and you are using git, add it to the .gitignore.\n\nPackaging\n\nBefore you can actually publish your library, you will need to package it.\n\npoetry build\n\n\nThis command will package your library in two different formats: sdist which is the source format, and wheel which is a compiled package.\n\nPoetry will automatically include some metadata files when building a package. When building a wheel, the following files are included in the .dist-info directory:\n\nLICENSE\nLICENSE.*\nCOPYING\nCOPYING.*\nLICENSES/**\n\nWhen building an sdist, the following files will be included in the root folder:\n\nLICENSE*\n\nOnce building is done you are ready to publish your library.\n\nPublishing to PyPI\n\nAlright, so now you can publish packages.\n\nPoetry will publish to PyPI by default. Anything that is published to PyPI is available automatically through Poetry. Since pendulum is on PyPI we can depend on it without having to specify any additional repositories.\n\nIf we wanted to share poetry-demo with the Python community, we would publish on PyPI as well. Doing so is really easy.\n\npoetry publish\n\n\nThis will package and publish the library to PyPI, at the condition that you are a registered user and you have configured your credentials properly.\n\nThe publish command does not execute build by default.\n\nIf you want to build and publish your packages together, just pass the --build option.\n\nOnce this is done, your library will be available to anyone.\n\nPublishing to a private repository\n\nSometimes, you may want to keep your library private but also being accessible to your team.\n\nIn this case, you will need to use a private repository.\n\nIn order to publish to a private repository, you will need to add it to your global list of repositories. See Adding a repository for more information.\n\nOnce this is done, you can actually publish to it like so:\n\npoetry publish -r my-repository\n\nFooter\n\nPython packaging and dependency management made easy.\n\nGitHub\nDiscord\nDOCUMENTATION\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\n GITHUB\nProject\nIssues\nDiscussions\nOTHER PROJECTS\npoetry-core\ninstall.python-poetry.org\nBundle plugin\nExport plugin\n\nCopyright © 2018-2024. All Rights Reserved.\nPowered by"
  },
  {
    "title": "Managing dependencies | main | Documentation | Poetry - Python dependency management and packaging made easy",
    "url": "https://python-poetry.org/docs/main/managing-dependencies/",
    "html": "Home\nSearch\nmain\nUse dark mode\nDOCUMENTATION\nBLOG\nHISTORY\nIntroduction\nBasic usage\nManaging dependencies\nDependency groups\nOptional groups\nAdding a dependency to a group\nInstalling group dependencies\nRemoving dependencies from a group\nSynchronizing dependencies\nLayering optional groups\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\nManaging dependencies\nDependency groups\n\nPoetry provides a way to organize your dependencies by groups. For instance, you might have dependencies that are only needed to test your project or to build the documentation.\n\nTo declare a new dependency group, use a tool.poetry.group.<group> section where <group> is the name of your dependency group (for instance, test):\n\n[tool.poetry.group.test]  # This part can be left out\n\n[tool.poetry.group.test.dependencies]\npytest = \"^6.0.0\"\npytest-mock = \"*\"\n\n\nAll dependencies must be compatible with each other across groups since they will be resolved regardless of whether they are required for installation or not (see Installing group dependencies).\n\nThink of dependency groups as labels associated with your dependencies: they don’t have any bearings on whether their dependencies will be resolved and installed by default, they are simply a way to organize the dependencies logically.\n\nThe dependencies declared in tool.poetry.dependencies are part of an implicit main group.\n\n[tool.poetry.dependencies]  # main dependency group\nhttpx = \"*\"\npendulum = \"*\"\n\n\n[tool.poetry.group.test.dependencies]\npytest = \"^6.0.0\"\npytest-mock = \"*\"\n\n\nDependency groups, other than the implicit main group, must only contain dependencies you need in your development process. Installing them is only possible by using Poetry.\n\nTo declare a set of dependencies, which add additional functionality to the project during runtime, use extras instead. Extras can be installed by the end user using pip.\n\nA note about defining a dev dependencies group\n\nThe proper way to define a dev dependencies group since Poetry 1.2.0 is the following:\n\n[tool.poetry.group.dev.dependencies]\npytest = \"^6.0.0\"\npytest-mock = \"*\"\n\n\nThis group notation is preferred since Poetry 1.2.0 and not usable in earlier versions. For backwards compatibility with older versions of Poetry, any dependency declared in the dev-dependencies section will automatically be added to the dev group. So the above and following notations are equivalent:\n\n# Poetry pre-1.2.x style, understood by Poetry 1.0–1.2\n[tool.poetry.dev-dependencies]\npytest = \"^6.0.0\"\npytest-mock = \"*\"\n\n\nPoetry will slowly transition away from the dev-dependencies notation which will soon be deprecated, so it’s advised to migrate your existing development dependencies to the new group notation.\n\nOptional groups\n\nA dependency group can be declared as optional. This makes sense when you have a group of dependencies that are only required in a particular environment or for a specific purpose.\n\n[tool.poetry.group.docs]\noptional = true\n\n[tool.poetry.group.docs.dependencies]\nmkdocs = \"*\"\n\n\nOptional groups can be installed in addition to the default dependencies by using the --with option of the install command.\n\npoetry install --with docs\n\nOptional group dependencies will still be resolved alongside other dependencies, so special care should be taken to ensure they are compatible with each other.\nAdding a dependency to a group\n\nThe add command is the preferred way to add dependencies to a group. This is done by using the --group (-G) option.\n\npoetry add pytest --group test\n\n\nIf the group does not already exist, it will be created automatically.\n\nInstalling group dependencies\n\nBy default, dependencies across all non-optional groups will be installed when executing poetry install.\n\nThe default set of dependencies for a project includes the implicit main group defined in tool.poetry.dependencies as well as all groups that are not explicitly marked as an optional group.\n\nYou can exclude one or more groups with the --without option:\n\npoetry install --without test,docs\n\n\nYou can also opt in optional groups by using the --with option:\n\npoetry install --with docs\n\n\nWhen used together, --without takes precedence over --with. For example, the following command will only install the dependencies specified in the optional test group.\n\npoetry install --with test,docs --without docs\n\n\nFinally, in some case you might want to install only specific groups of dependencies without installing the default set of dependencies. For that purpose, you can use the --only option.\n\npoetry install --only docs\n\n\nIf you only want to install the project’s runtime dependencies, you can do so with the --only main notation:\n\npoetry install --only main\n\n\nIf you want to install the project root, and no other dependencies, you can use the --only-root option.\n\npoetry install --only-root\n\nRemoving dependencies from a group\n\nThe remove command supports a --group option to remove packages from a specific group:\n\npoetry remove mkdocs --group docs\n\nSynchronizing dependencies\n\nPoetry supports what’s called dependency synchronization. Dependency synchronization ensures that the locked dependencies in the poetry.lock file are the only ones present in the environment, removing anything that’s not necessary.\n\nThis is done by using the --sync option of the install command:\n\npoetry install --sync\n\n\nThe --sync option can be combined with any dependency groups related options to synchronize the environment with specific groups. Note that extras are separate. Any extras not selected for install are always removed, regardless of --sync.\n\npoetry install --without dev --sync\npoetry install --with docs --sync\npoetry install --only dev\n\nThe --sync option replaces the --remove-untracked option which is now deprecated.\nLayering optional groups\n\nWhen you omit the --sync option, you can install any subset of optional groups without removing those that are already installed. This is very useful, for example, in multi-stage Docker builds, where you run poetry install multiple times in different build stages.\n\nFooter\n\nPython packaging and dependency management made easy.\n\nGitHub\nDiscord\nDOCUMENTATION\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\n GITHUB\nProject\nIssues\nDiscussions\nOTHER PROJECTS\npoetry-core\ninstall.python-poetry.org\nBundle plugin\nExport plugin\n\nCopyright © 2018-2024. All Rights Reserved.\nPowered by"
  },
  {
    "title": "Basic usage | main | Documentation | Poetry - Python dependency management and packaging made easy",
    "url": "https://python-poetry.org/docs/main/basic-usage/",
    "html": "Home\nSearch\nmain\nUse dark mode\nDOCUMENTATION\nBLOG\nHISTORY\nIntroduction\nBasic usage\nProject setup\nSetting a Python Version\nInitialising a pre-existing project\nOperating modes\nSpecifying dependencies\nUsing your virtual environment\nUsing poetry run\nActivating the virtual environment\nVersion constraints\nInstalling dependencies\nInstalling without poetry.lock\nInstalling with poetry.lock\nCommitting your poetry.lock file to version control\nInstalling dependencies only\nUpdating dependencies to their latest versions\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\nBasic usage\n\nFor the basic usage introduction we will be installing pendulum, a datetime library. If you have not yet installed Poetry, refer to the Introduction chapter.\n\nProject setup\n\nFirst, let’s create our new project, let’s call it poetry-demo:\n\npoetry new poetry-demo\n\n\nThis will create the poetry-demo directory with the following content:\n\npoetry-demo\n├── pyproject.toml\n├── README.md\n├── poetry_demo\n│   └── __init__.py\n└── tests\n    └── __init__.py\n\n\nThe pyproject.toml file is what is the most important here. This will orchestrate your project and its dependencies. For now, it looks like this:\n\n[tool.poetry]\nname = \"poetry-demo\"\nversion = \"0.1.0\"\ndescription = \"\"\nauthors = [\"Sébastien Eustace <sebastien@eustace.io>\"]\nreadme = \"README.md\"\npackages = [{include = \"poetry_demo\"}]\n\n[tool.poetry.dependencies]\npython = \"^3.7\"\n\n\n[build-system]\nrequires = [\"poetry-core\"]\nbuild-backend = \"poetry.core.masonry.api\"\n\n\nPoetry assumes your package contains a package with the same name as tool.poetry.name located in the root of your project. If this is not the case, populate tool.poetry.packages to specify your packages and their locations.\n\nSimilarly, the traditional MANIFEST.in file is replaced by the tool.poetry.readme, tool.poetry.include, and tool.poetry.exclude sections. tool.poetry.exclude is additionally implicitly populated by your .gitignore. For full documentation on the project format, see the pyproject section of the documentation.\n\nSetting a Python Version\nUnlike with other packages, Poetry will not automatically install a python interpreter for you. If you want to run Python files in your package like a script or application, you must bring your own python interpreter to run them.\n\nPoetry will require you to explicitly specify what versions of Python you intend to support, and its universal locking will guarantee that your project is installable (and all dependencies claim support for) all supported Python versions. Again, it’s important to remember that – unlike other dependencies – setting a Python version is merely specifying which versions of Python you intend to support.\n\nFor example, in this pyproject.toml file:\n\n[tool.poetry.dependencies]\npython = \"^3.7.0\"\n\n\nwe are allowing any version of Python 3 that is greater than 3.7.0.\n\nWhen you run poetry install, you must have access to some version of a Python inrepreter that satisfies this constraint available on your system. Poetry will not install a Python interpreter for you. If you use a tool like pyenv, you can use the experimental configuration value virtualenvs.prefer-active-python.\n\nInitialising a pre-existing project\n\nInstead of creating a new project, Poetry can be used to ‘initialise’ a pre-populated directory. To interactively create a pyproject.toml file in directory pre-existing-project:\n\ncd pre-existing-project\npoetry init\n\nOperating modes\n\nPoetry can be operated in two different modes. The default mode is the package mode, which is the right mode if you want to package your project into an sdist or a wheel and perhaps publish it to a package index. In this mode, some metadata such as name and version, which are required for packaging, are mandatory. Further, the project itself will be installed in editable mode when running poetry install.\n\nIf you want to use Poetry only for dependency management but not for packaging, you can use the non-package mode:\n\n[tool.poetry]\npackage-mode = false\n\n\nIn this mode, metadata such as name and version are optional. Therefore, it is not possible to build a distribution or publish the project to a package index. Further, when running poetry install, Poetry does not try to install the project itself, but only its dependencies (same as poetry install --no-root).\n\nIn the pyproject section you can see which fields are required in package mode.\nSpecifying dependencies\n\nIf you want to add dependencies to your project, you can specify them in the tool.poetry.dependencies section.\n\n[tool.poetry.dependencies]\npendulum = \"^2.1\"\n\n\nAs you can see, it takes a mapping of package names and version constraints.\n\nPoetry uses this information to search for the right set of files in package “repositories” that you register in the tool.poetry.source section, or on PyPI by default.\n\nAlso, instead of modifying the pyproject.toml file by hand, you can use the add command.\n\n$ poetry add pendulum\n\n\nIt will automatically find a suitable version constraint and install the package and sub-dependencies.\n\nPoetry supports a rich dependency specification syntax, including caret, tilde, wildcard, inequality and multiple constraints requirements.\n\nUsing your virtual environment\n\nBy default, Poetry creates a virtual environment in {cache-dir}/virtualenvs. You can change the cache-dir value by editing the Poetry configuration. Additionally, you can use the virtualenvs.in-project configuration variable to create virtual environments within your project directory.\n\nThere are several ways to run commands within this virtual environment.\n\nExternal virtual environment management\n\nPoetry will detect and respect an existing virtual environment that has been externally activated. This is a powerful mechanism that is intended to be an alternative to Poetry’s built-in, simplified environment management.\n\nTo take advantage of this, simply activate a virtual environment using your preferred method or tooling, before running any Poetry commands that expect to manipulate an environment.\n\nUsing poetry run\n\nTo run your script simply use poetry run python your_script.py. Likewise if you have command line tools such as pytest or black you can run them using poetry run pytest.\n\nIf managing your own virtual environment externally, you do not need to use poetry run or poetry shell since you will, presumably, already have activated that virtual environment and made available the correct python instance. For example, these commands should output the same python path:\n\nconda activate your_env_name\nwhich python\npoetry run which python\npoetry shell\nwhich python\n\nActivating the virtual environment\n\nThe easiest way to activate the virtual environment is to create a nested shell with poetry shell.\n\nTo deactivate the virtual environment and exit this new shell type exit. To deactivate the virtual environment without leaving the shell use deactivate.\n\nWhy a nested shell?\n\nChild processes inherit their environment from their parents, but do not share them. As such, any modifications made by a child process is not persisted after the child process exits. A Python application (Poetry), being a child process, cannot modify the environment of the shell that it has been called from such that an activated virtual environment remains active after the Poetry command has completed execution.\n\nTherefore, Poetry has to create a sub-shell with the virtual environment activated in order for the subsequent commands to run from within the virtual environment.\n\nIf you’d like to prevent poetry shell from modifying your shell prompt on virtual environment activation, you should set VIRTUAL_ENV_DISABLE_PROMPT=1 as an environment variable before running the command.\n\nAlternatively, to avoid creating a new shell, you can manually activate the virtual environment by running source {path_to_venv}/bin/activate ({path_to_venv}\\Scripts\\activate.ps1 in PowerShell). To get the path to your virtual environment run poetry env info --path. You can also combine these into a one-liner, such as source $(poetry env info --path)/bin/activate (& ((poetry env info --path) + \"\\Scripts\\activate.ps1\") in Powershell).\n\nTo deactivate this virtual environment simply use deactivate.\n\n\tPOSIX SHELL\tWINDOWS (POWERSHELL)\tEXIT/DEACTIVATE\nSub-shell\tpoetry shell\tpoetry shell\texit\nManual Activation\tsource {path_to_venv}/bin/activate\t{path_to_venv}\\Scripts\\activate.ps1\tdeactivate\nOne-liner\tsource $(poetry env info --path)/bin/activate\t& ((poetry env info --path) + \"\\Scripts\\activate.ps1\")\tdeactivate\nVersion constraints\n\nIn our example, we are requesting the pendulum package with the version constraint ^2.1. This means any version greater or equal to 2.1.0 and less than 3.0.0 (>=2.1.0 <3.0.0).\n\nPlease read Dependency specification for more in-depth information on versions, how versions relate to each other, and on the different ways you can specify dependencies.\n\nHow does Poetry download the right files?\n\nWhen you specify a dependency in pyproject.toml, Poetry first takes the name of the package that you have requested and searches for it in any repository you have registered using the repositories key. If you have not registered any extra repositories, or it does not find a package with that name in the repositories you have specified, it falls back to PyPI.\n\nWhen Poetry finds the right package, it then attempts to find the best match for the version constraint you have specified.\n\nInstalling dependencies\n\nTo install the defined dependencies for your project, just run the install command.\n\npoetry install\n\n\nWhen you run this command, one of two things may happen:\n\nInstalling without poetry.lock\n\nIf you have never run the command before and there is also no poetry.lock file present, Poetry simply resolves all dependencies listed in your pyproject.toml file and downloads the latest version of their files.\n\nWhen Poetry has finished installing, it writes all the packages and their exact versions that it downloaded to the poetry.lock file, locking the project to those specific versions. You should commit the poetry.lock file to your project repo so that all people working on the project are locked to the same versions of dependencies (more below).\n\nInstalling with poetry.lock\n\nThis brings us to the second scenario. If there is already a poetry.lock file as well as a pyproject.toml file when you run poetry install, it means either you ran the install command before, or someone else on the project ran the install command and committed the poetry.lock file to the project (which is good).\n\nEither way, running install when a poetry.lock file is present resolves and installs all dependencies that you listed in pyproject.toml, but Poetry uses the exact versions listed in poetry.lock to ensure that the package versions are consistent for everyone working on your project. As a result you will have all dependencies requested by your pyproject.toml file, but they may not all be at the very latest available versions (some dependencies listed in the poetry.lock file may have released newer versions since the file was created). This is by design, it ensures that your project does not break because of unexpected changes in dependencies.\n\nCommitting your poetry.lock file to version control\nAs an application developer\n\nApplication developers commit poetry.lock to get more reproducible builds.\n\nCommitting this file to VC is important because it will cause anyone who sets up the project to use the exact same versions of the dependencies that you are using. Your CI server, production machines, other developers in your team, everything and everyone runs on the same dependencies, which mitigates the potential for bugs affecting only some parts of the deployments. Even if you develop alone, in six months when reinstalling the project you can feel confident the dependencies installed are still working even if your dependencies released many new versions since then. (See note below about using the update command.)\n\nIf you have added the recommended [build-system] section to your project’s pyproject.toml then you can successfully install your project and its dependencies into a virtual environment using a command like pip install -e .. However, pip will not use the lock file to determine dependency versions as the poetry-core build system is intended for library developers (see next section).\nAs a library developer\n\nLibrary developers have more to consider. Your users are application developers, and your library will run in a Python environment you don’t control.\n\nThe application ignores your library’s lock file. It can use whatever dependency version meets the constraints in your pyproject.toml. The application will probably use the latest compatible dependency version. If your library’s poetry.lock falls behind some new dependency version that breaks things for your users, you’re likely to be the last to find out about it.\n\nA simple way to avoid such a scenario is to omit the poetry.lock file. However, by doing so, you sacrifice reproducibility and performance to a certain extent. Without a lockfile, it can be difficult to find the reason for failing tests, because in addition to obvious code changes an unnoticed library update might be the culprit. Further, Poetry will have to lock before installing a dependency if poetry.lock has been omitted. Depending on the number of dependencies, locking may take a significant amount of time.\n\nIf you do not want to give up the reproducibility and performance benefits, consider a regular refresh of poetry.lock to stay up-to-date and reduce the risk of sudden breakage for users.\n\nInstalling dependencies only\n\nThe current project is installed in editable mode by default.\n\nIf you want to install the dependencies only, run the install command with the --no-root flag:\n\npoetry install --no-root\n\nUpdating dependencies to their latest versions\n\nAs mentioned above, the poetry.lock file prevents you from automatically getting the latest versions of your dependencies. To update to the latest versions, use the update command. This will fetch the latest matching versions (according to your pyproject.toml file) and update the lock file with the new versions. (This is equivalent to deleting the poetry.lock file and running install again.)\n\nPoetry will display a Warning when executing an install command if poetry.lock and pyproject.toml are not synchronized.\nFooter\n\nPython packaging and dependency management made easy.\n\nGitHub\nDiscord\nDOCUMENTATION\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\n GITHUB\nProject\nIssues\nDiscussions\nOTHER PROJECTS\npoetry-core\ninstall.python-poetry.org\nBundle plugin\nExport plugin\n\nCopyright © 2018-2024. All Rights Reserved.\nPowered by"
  },
  {
    "title": "pre-commit hooks | Documentation | Poetry - Python dependency management and packaging made easy",
    "url": "https://python-poetry.org/docs/pre-commit-hooks/",
    "html": "Home\nSearch\n1.8\nUse dark mode\nDOCUMENTATION\nBLOG\nHISTORY\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\npoetry-check\nArguments\npoetry-lock\nArguments\npoetry-export\nArguments\npoetry-install\nArguments\nUsage\nFAQ\nWhy does pre-commit autoupdate not update to the latest version?\npre-commit hooks\n\npre-commit is a framework for building and running git hooks. See the official documentation for more information: pre-commit.com\n\nThis document provides a list of available pre-commit hooks provided by Poetry.\n\nIf you specify the args: for a hook in your .pre-commit-config.yaml, the defaults are overwritten. You must fully specify all arguments for your hook if you make use of args:.\nIf the pyproject.toml file is not in the root directory, you can specify args: [\"-C\", \"./subdirectory\"].\npoetry-check\n\nThe poetry-check hook calls the poetry check command to make sure the poetry configuration does not get committed in a broken state.\n\nArguments\n\nThe hook takes the same arguments as the poetry command. For more information see the check command.\n\npoetry-lock\n\nThe poetry-lock hook calls the poetry lock command to make sure the lock file is up-to-date when committing changes.\n\nArguments\n\nThe hook takes the same arguments as the poetry command. For more information see the lock command.\n\npoetry-export\n\nThe poetry-export hook calls the poetry export command to sync your requirements.txt file with your current dependencies.\n\nThis hook is provided by the Export Poetry Plugin.\nIt is recommended to run the poetry-lock hook or poetry-check with argument --lock prior to this one.\nArguments\n\nThe hook takes the same arguments as the poetry command. For more information see the export command.\n\nThe default arguments are args: [\"-f\", \"requirements.txt\", \"-o\", \"requirements.txt\"], which will create/update the requirements.txt file in the current working directory.\n\nYou may add verbose: true in your .pre-commit-config.yaml in order to output to the console:\n\nhooks:\n-   id: poetry-export\n    args: [\"-f\", \"requirements.txt\"]\n    verbose: true\n\n\nAlso, --dev can be added to args to write dev-dependencies to requirements.txt:\n\nhooks:\n-   id: poetry-export\n    args: [\"--dev\", \"-f\", \"requirements.txt\", \"-o\", \"requirements.txt\"]\n\npoetry-install\n\nThe poetry-install hook calls the poetry install command to make sure all locked packages are installed. In order to install this hook, you either need to specify default_install_hook_types, or you have to install it via pre-commit install --install-hooks -t post-checkout -t post-merge.\n\nArguments\n\nThe hook takes the same arguments as the poetry command. For more information see the install command.\n\nUsage\n\nFor more information on how to use pre-commit please see the official documentation.\n\nA minimalistic .pre-commit-config.yaml example:\n\nrepos:\n-   repo: https://github.com/python-poetry/poetry\n    rev: ''  # add version here\n    hooks:\n    -   id: poetry-check\n    -   id: poetry-lock\n    -   id: poetry-export\n    -   id: poetry-install\n\n\nA .pre-commit-config.yaml example for a monorepo setup or if the pyproject.toml file is not in the root directory:\n\nrepos:\n-   repo: https://github.com/python-poetry/poetry\n    rev: ''  # add version here\n    hooks:\n    -   id: poetry-check\n        args: [\"-C\", \"./subdirectory\"]\n    -   id: poetry-lock\n        args: [\"-C\", \"./subdirectory\"]\n    -   id: poetry-export\n        args: [\"-C\", \"./subdirectory\", \"-f\", \"requirements.txt\", \"-o\", \"./subdirectory/requirements.txt\"]\n    -   id: poetry-install\n        args: [\"-C\", \"./subdirectory\"]\n\nFAQ\nWhy does pre-commit autoupdate not update to the latest version?\n\npre-commit autoupdate updates the rev for each repository defined in your .pre-commit-config.yaml to the latest available tag in the default branch.\n\nPoetry follows a branching strategy where the default branch is the active development branch, and fixes get backported to stable branches. New tags are assigned in these stable branches.\n\npre-commit does not support such a branching strategy and has decided to not implement an option, either on the user’s side or the hook author’s side, to define a branch for looking up the latest available tag.\n\nThus, pre-commit autoupdate is not usable for the hooks described here.\n\nYou can avoid changing the rev to an unexpected value by using the --repo parameter (may be specified multiple times), to explicitly list repositories that should be updated. An option to explicitly exclude repositories will not be implemented into pre-commit.\n\nFooter\n\nPython packaging and dependency management made easy.\n\nGitHub\nDiscord\nDOCUMENTATION\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\n GITHUB\nProject\nIssues\nDiscussions\nOTHER PROJECTS\npoetry-core\ninstall.python-poetry.org\nBundle plugin\nExport plugin\n\nCopyright © 2018-2024. All Rights Reserved.\nPowered by"
  },
  {
    "title": "FAQ | Documentation | Poetry - Python dependency management and packaging made easy",
    "url": "https://python-poetry.org/docs/faq/",
    "html": "Home\nSearch\n1.8\nUse dark mode\nDOCUMENTATION\nBLOG\nHISTORY\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\nWhy is the dependency resolution process slow?\nWhat kind of versioning scheme does Poetry use for itself?\nWhy does Poetry not adhere to semantic versioning?\nAre unbound version constraints a bad idea?\nIs tox supported?\nIs Nox supported?\nI don’t want Poetry to manage my virtual environments. Can I disable it?\nWhy is Poetry telling me that the current project’s supported Python range is not compatible with one or more packages' Python requirements?\nWhy does Poetry enforce PEP 440 versions?\nPoetry busts my Docker cache because it requires me to COPY my source files in before installing 3rd party dependencies\nMy requests are timing out!\npre-commit hooks\nFAQ\nWhy is the dependency resolution process slow?\n\nWhile the dependency resolver at the heart of Poetry is highly optimized and should be fast enough for most cases, with certain sets of dependencies it can take time to find a valid solution.\n\nThis is due to the fact that not all libraries on PyPI have properly declared their metadata and, as such, they are not available via the PyPI JSON API. At this point, Poetry has no choice but to download the packages and inspect them to get the necessary information. This is an expensive operation, both in bandwidth and time, which is why it seems this is a long process.\n\nAt the moment there is no way around it. However, if you notice that Poetry is downloading many versions of a single package, you can lessen the workload by constraining that one package in your pyproject.toml more narrowly. That way Poetry does not have to sift through so many versions of it, which may speed up the locking process considerably in some cases.\n\nOnce Poetry has cached the releases' information on your machine, the dependency resolution process will be much faster.\nWhat kind of versioning scheme does Poetry use for itself?\n\nPoetry uses “major.minor.micro” version identifiers as mentioned in PEP 440.\n\nVersion bumps are done similar to Python’s versioning:\n\nA major version bump (incrementing the first number) is only done for breaking changes if a deprecation cycle is not possible and many users have to perform some manual steps to migrate from one version to the next one.\nA minor version bump (incrementing the second number) may include new features as well as new deprecations and drop features deprecated in an earlier minor release.\nA micro version bump (incrementing the third number) usually only includes bug fixes. Deprecated features will not be dropped in a micro release.\nWhy does Poetry not adhere to semantic versioning?\n\nBecause of its large user base, even small changes not considered relevant by most users can turn out to be a breaking change for some users in hindsight. Sticking to strict semantic versioning and (almost) always bumping the major version instead of the minor version does not seem desirable since the minor version will not carry any meaning anymore.\n\nAre unbound version constraints a bad idea?\n\nA version constraint without an upper bound such as * or >=3.4 will allow updates to any future version of the dependency. This includes major versions breaking backward compatibility.\n\nOnce a release of your package is published, you cannot tweak its dependencies anymore in case a dependency breaks BC – you have to do a new release but the previous one stays broken. (Users can still work around the broken dependency by restricting it by themselves.)\n\nTo avoid such issues you can define an upper bound on your constraints, which you can increase in a new release after testing that your package is compatible with the new major version of your dependency.\n\nFor example instead of using >=3.4 you can use ^3.4 which allows all versions <4.0. The ^ operator works very well with libraries following semantic versioning.\n\nHowever, when defining an upper bound, users of your package are not able to update a dependency beyond the upper bound even if it does not break anything and is fully compatible with your package. You have to release a new version of your package with an increased upper bound first.\n\nIf your package will be used as a library in other packages, it might be better to avoid upper bounds and thus unnecessary dependency conflicts (unless you already know for sure that the next release of the dependency will break your package). If your package will be used as an application, it might be worth to define an upper bound.\n\nIs tox supported?\n\nYes. Provided that you are using tox >= 4, you can use it in combination with the PEP 517 compliant build system provided by Poetry. (With tox 3, you have to set the isolated build option.)\n\nSo, in your pyproject.toml file, add this section if it does not already exist:\n\n[build-system]\nrequires = [\"poetry-core>=1.0.0\"]\nbuild-backend = \"poetry.core.masonry.api\"\n\n\ntox can be configured in multiple ways. It depends on what should be the code under test and which dependencies should be installed.\n\nUse case #1\n[tox]\n\n[testenv]\ndeps =\n    pytest\ncommands =\n    pytest tests/ --import-mode importlib\n\n\ntox will create an sdist package of the project and uses pip to install it in a fresh environment. Thus, dependencies are resolved by pip.\n\nUse case #2\n[tox]\n\n[testenv]\nallowlist_externals = poetry\ncommands_pre =\n    poetry install --no-root --sync\ncommands =\n    poetry run pytest tests/ --import-mode importlib\n\n\ntox will create an sdist package of the project and uses pip to install it in a fresh environment. Thus, dependencies are resolved by pip in the first place. But afterward we run Poetry, which will install the locked dependencies into the environment.\n\nUse case #3\n[tox]\n\n[testenv]\nskip_install = true\nallowlist_externals = poetry\ncommands_pre =\n    poetry install\ncommands =\n    poetry run pytest tests/ --import-mode importlib\n\n\ntox will not do any install. Poetry installs all the dependencies and the current package in editable mode. Thus, tests are running against the local files and not the built and installed package.\n\nNote about credentials\n\nNote that tox does not forward the environment variables of your current shell session by default. This may cause Poetry to not be able to install dependencies in the tox environments if you have configured credentials using the system keyring on Linux systems or using environment variables in general. You can use the passenv configuration option to forward the required variables explicitly or passenv = \"*\" to forward all of them. Linux systems may require forwarding the DBUS_SESSION_BUS_ADDRESS variable to allow access to the system keyring, though this may vary between desktop environments.\n\nAlternatively, you can disable the keyring completely:\n\npoetry config keyring.enabled false\n\n\nBe aware that this will cause Poetry to write passwords to plaintext config files. You will need to set the credentials again after changing this setting.\n\nIs Nox supported?\n\nUse the nox-poetry package to install locked versions of dependencies specified in poetry.lock into Nox sessions.\n\nI don’t want Poetry to manage my virtual environments. Can I disable it?\n\nWhile Poetry automatically creates virtual environments to always work isolated from the global Python installation, there are rare scenarios where the use a Poetry managed virtual environment is not possible or preferred.\n\nIn this case, you can disable this feature by setting the virtualenvs.create setting to false:\n\npoetry config virtualenvs.create false\n\n\nThe recommended best practice, including when installing an application within a container, is to make use of a virtual environment. This can also be managed by another tool.\n\nThe Poetry team strongly encourages the use of a virtual environment.\n\nWhy is Poetry telling me that the current project’s supported Python range is not compatible with one or more packages' Python requirements?\n\nUnlike pip, Poetry doesn’t resolve for just the Python in the current environment. Instead it makes sure that a dependency is resolvable within the given Python version range in pyproject.toml.\n\nAssume you have the following pyproject.toml:\n\n[tool.poetry.dependencies]\npython = \"^3.7\"\n\n\nThis means your project aims to be compatible with any Python version >=3.7,<4.0. Whenever you try to add a dependency whose Python requirement doesn’t match the whole range Poetry will tell you this, e.g.:\n\nThe current project's supported Python range (>=3.7.0,<4.0.0) is not compatible with some of the required packages Python requirement:\n    - scipy requires Python >=3.7,<3.11, so it will not be satisfied for Python >=3.11,<4.0.0\n\n\nUsually you will want to match the supported Python range of your project with the upper bound of the failing dependency. Alternatively you can tell Poetry to install this dependency only for a specific range of Python versions, if you know that it’s not needed in all versions.\n\nWhy does Poetry enforce PEP 440 versions?\n\nThis is done to be compliant with the broader Python ecosystem.\n\nFor example, if Poetry builds a distribution for a project that uses a version that is not valid according to PEP 440, third party tools will be unable to parse the version correctly.\n\nPoetry busts my Docker cache because it requires me to COPY my source files in before installing 3rd party dependencies\n\nBy default, running poetry install ... requires you to have your source files present (both the “root” package and any directory path dependencies you might have). This interacts poorly with Docker’s caching mechanisms because any change to a source file will make any layers (subsequent commands in your Dockerfile) re-run. For example, you might have a Dockerfile that looks something like this:\n\nFROM python\nCOPY pyproject.toml poetry.lock .\nCOPY src/ ./src\nRUN pip install poetry && poetry install --only main\n\n\nAs soon as any source file changes, the cache for the RUN layer will be invalidated, which forces all 3rd party dependencies (likely the slowest step out of these) to be installed again if you changed any files in src/.\n\nTo avoid this cache busting you can split this into two steps:\n\nInstall 3rd party dependencies.\nCopy over your source code and install just the source code.\n\nThis might look something like this:\n\nFROM python\nCOPY pyproject.toml poetry.lock .\nRUN pip install poetry && poetry install --only main --no-root --no-directory\nCOPY src/ ./src\nRUN poetry install --only main\n\n\nThe two key options we are using here are --no-root (skips installing the project source) and --no-directory (skips installing any local directory path dependencies, you can omit this if you don’t have any). More information on the options available for poetry install.\n\nMy requests are timing out!\n\nPoetry’s default HTTP request timeout is 15 seconds, the same as pip. Similar to PIP_REQUESTS_TIMEOUT, the experimental environment variable POETRY_REQUESTS_TIMEOUT can be set to alter this value.\n\nFooter\n\nPython packaging and dependency management made easy.\n\nGitHub\nDiscord\nDOCUMENTATION\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\n GITHUB\nProject\nIssues\nDiscussions\nOTHER PROJECTS\npoetry-core\ninstall.python-poetry.org\nBundle plugin\nExport plugin\n\nCopyright © 2018-2024. All Rights Reserved.\nPowered by"
  },
  {
    "title": "Community | Documentation | Poetry - Python dependency management and packaging made easy",
    "url": "https://python-poetry.org/docs/community/",
    "html": "Home\nSearch\n1.8\nUse dark mode\nDOCUMENTATION\nBLOG\nHISTORY\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nBadge\nFAQ\npre-commit hooks\nCommunity\nBadge\n\nFor any projects using Poetry, you may add its official badge somewhere prominent like the README.\n\nMarkdown\n\n[![Poetry](https://img.shields.io/endpoint?url=https://python-poetry.org/badge/v0.json)](https://python-poetry.org/)\n\n\nreStructuredText\n\n.. image:: https://img.shields.io/endpoint?url=https://python-poetry.org/badge/v0.json\n   :alt: Poetry\n   :target: https://python-poetry.org/\n\nFooter\n\nPython packaging and dependency management made easy.\n\nGitHub\nDiscord\nDOCUMENTATION\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\n GITHUB\nProject\nIssues\nDiscussions\nOTHER PROJECTS\npoetry-core\ninstall.python-poetry.org\nBundle plugin\nExport plugin\n\nCopyright © 2018-2024. All Rights Reserved.\nPowered by"
  },
  {
    "title": "Contributing to Poetry | Documentation | Poetry - Python dependency management and packaging made easy",
    "url": "https://python-poetry.org/docs/contributing/",
    "html": "Home\nSearch\n1.8\nUse dark mode\nDOCUMENTATION\nBLOG\nHISTORY\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nHow to contribute\nReporting bugs\nSuggesting enhancements\nDocumentation contributions\nCode contributions\nIssue triage\nCommunity\nFAQ\npre-commit hooks\nContributing to Poetry\n\nFirst off, thanks for taking the time to contribute!\n\nThe following is a set of guidelines for contributing to Poetry on GitHub. These are mostly guidelines, not rules. Use your best judgement, and feel free to propose changes to this document in a pull request.\n\nHow to contribute\nReporting bugs\n\nThis section guides you through submitting a bug report for Poetry. Following these guidelines helps maintainers and the community understand your report, reproduce the behavior, and find related reports.\n\nBefore submitting a bug report\nCheck the FAQ for a list of common questions and problems.\nCheck the blog for release notes from recent releases, including steps for upgrading and known issues.\nCheck that your issue does not already exist in the issue tracker.\nMake sure your issue is really a bug, and is not a support request or question better suited for Discussions or Discord.\nIf you find a Closed issue that seems like it is the same thing that you’re experiencing, open a new issue and include a link to the original issue in the body of your new one.\nHow do I submit a bug report?\n\nBugs concerning Poetry and poetry-core should be submitted to the main issue tracker, using the correct issue template.\n\nExplain the problem and make it easy for others to search for and understand:\n\nUse a clear and descriptive title for the issue to identify the problem.\nDescribe the exact steps which reproduce the problem in as many details as possible.\nDescribe the behavior you observed after following the steps and point out how this is a bug.\nExplain which behavior you expected to see instead and why.\nIf the problem involves an unexpected error being raised, execute the problematic command in debug mode (with -vvv flag).\n\nProvide detailed steps for reproduction of your issue:\n\nProvide your pyproject.toml file in a Gist, pastebin, or example repository after removing potential private information like private package repositories or names.\nProvide specific examples to demonstrate the steps to reproduce the issue. This could be an example repository, a sequence of steps run in a container, or just a pyproject.toml for very simple cases.\nAre you unable to reliably reproduce the issue? If so, provide details about how often the problem happens and under which conditions it normally happens.\n\nProvide more context by answering these questions:\n\nDid the problem start happening recently (e.g. after updating to a new version of Poetry) or was this always a problem?\nIf the problem started happening recently, can you reproduce the problem in an older version of Poetry? What’s the most recent version in which the problem does not happen?\nIs there anything exotic or unusual about your environment? This could include use of special container images, newer CPU architectures like Apple Silicon, or corporate proxies that intercept or modify your network traffic.\n\nInclude details about your configuration and environment:\n\nWhich version of Poetry are you using? You can get the exact version by running poetry --version.\nWhat version of Python is being used to run Poetry? Execute the poetry debug info to get this information.\nWhat’s the name and version of the OS you’re using? Examples include Ubuntu 22.04 or macOS 12.6.\n\nTo give others the best chance to understand and reproduce your issue, please be sure to put extra effort into your reproduction steps. You can both rule out local configuration issues on your end, and ensure others can cleanly reproduce your issue if attempt all reproductions in a pristine container (or VM), and provide the steps you performed inside that container/VM in your issue report.\n\nSuggesting enhancements\n\nThis section guides you through submitting an enhancement suggestion for Poetry, including completely new features as well as improvements to existing functionality. Following these guidelines helps maintainers and the community understand your suggestion and find related suggestions.\n\nBefore submitting a suggested enhancement\nCheck the FAQ for a list of common questions and problems.\nCheck that your issue does not already exist in the issue tracker.\nHow do I submit a suggested enhancement?\n\nSuggested enhancements concerning Poetry and poetry-core should be submitted to the main issue tracker, using the correct issue template.\n\nUse a clear and descriptive title for the issue to identify the suggestion.\nProvide a detailed description of the proposed enhancement, with specific steps or examples when possible.\nDescribe the current behavior and explain which behavior you would like to see instead, and why.\nDocumentation contributions\n\nOne of the simplest ways to get started contributing to a project is through improving documentation. Poetry is constantly evolving, and this means that sometimes our documentation has gaps. You can help by adding missing sections, editing the existing content to be more accessible, or creating new content such as tutorials, FAQs, etc.\n\nGithub Discussions and the kind/question label are excellent sources for FAQ candidates.\n\nIssues pertaining to the documentation are usually marked with the area/docs label, which will also trigger a preview of the changes as rendered by this website.\n\nCode contributions\nPicking an issue\nIf you are a first time contributor, and are looking for an issue to take on, you might want to look for at the contributing page for candidates. We do our best to curate good issues for first-time contributors there, but do fall behind – so if you don’t see anything good, feel free to ask.\n\nIf you would like to take on an issue, feel free to comment on the issue tagging @python-poetry/triage. We are more than happy to discuss solutions on the issue. If you would like help with navigating the code base, are looking for something to work on, or want feedback on a design or change, join us on our Discord server or start a Discussion.\n\nLocal development\n\nPoetry is developed using Poetry. Refer to the documentation to install Poetry in your local environment.\n\nPoetry’s development toolchain requires Python 3.8 or newer.\n\nYou should first fork the Poetry repository and then clone it locally, so that you can make pull requests against the project. If you are new to Git and pull request based development, GitHub provides a guide you will find helpful.\n\nNext, you should install Poetry’s dependencies, and run the test suite to make sure everything is working as expected:\n\npoetry install\npoetry run pytest\n\n\nWhen you contribute to Poetry, automated tools will be run to make sure your code is suitable to be merged. Besides pytest, you will need to make sure your code typechecks properly using mypy:\n\npoetry run mypy\n\n\nFinally, a great deal of linting tools are run on your code, to try and ensure consistent code style and root out common mistakes. The pre-commit tool is used to install and run these tools, and requires one-time setup:\n\npoetry run pre-commit install\n\n\npre-commit will now run and check your code every time you make a commit. By default, it will only run on changed files, but you can run it on all files manually (this may be useful if you altered the pre-commit config):\n\npoetry run pre-commit run --all-files\n\nPull requests\nFill out the pull request body completely and describe your changes as accurately as possible. The pull request body should be kept up to date as it will usually form the base for the final merge commit and the changelog entry.\nBe sure that your pull request contains tests that cover the changed or added code. Tests are generally required for code be to be considered mergeable, and code without passing tests will not be merged.\nEnsure your pull request passes the mypy and pre-commit checks. Remember that you can run these tools locally instead of relying on remote CI.\nIf your changes warrant a documentation change, the pull request must also update the documentation. Make sure to review the documentation preview generated by CI for any rendering issues.\nMake sure your branch is rebased against the latest base branch. A maintainer might ask you to ensure the branch is up-to-date prior to merging your pull request (especially if there have been CI changes on the base branch), and will also ask you to fix any conflicts.\n\nAll pull requests, unless otherwise instructed, need to be first accepted into the main branch. Maintainers will generally decide if any backports to other branches are required, and carry them out as needed.\n\nIssue triage\nIf you have an issue that hasn’t had any attention, you can ping us @python-poetry/triage on the issue. Please give us reasonable time to get to your issue first, and avoid pinging any individuals directly, especially if they are not part of the Poetry team.\n\nIf you are helping with the triage of reported issues, this section provides some useful information to assist you in your contribution.\n\nTriage steps\nDetermine what area and versions of Poetry the issue is related to, and set the appropriate labels (e.g. version/x.x.x, area/docs, area/venv), and remove the status/triage label.\nIf requested information (such as debug logs, pyproject.toml, etc.) is not provided and is relevant, request it from the author.\nSet the status/waiting-on-response label while waiting to hear back from the author.\nAttempt to reproduce the issue with the reported Poetry version or request further clarification from the author.\nEnsure the issue is not already resolved. Try reproducing it on the latest stable release, the latest prerelease (if present), and the development branch.\nIf the issue cannot be reproduced,\nrequest more reproduction steps and clarification from the issue’s author,\nset the status/needs-reproduction label,\nclose the issue if there is no reproduction forthcoming.\nIf the issue can be reproduced,\ncomment on the issue confirming so,\nset the status/confirmed label,\nif possible, identify the root cause of the issue,\nif interested, attempt to fix it via a pull request.\nMultiple versions\n\nWhen trying to reproduce issues, you often want to use multiple versions of Poetry at the same time. pipx makes this easy to do:\n\npipx install --suffix @1.2.1 'poetry==1.2.1'\npipx install --suffix @1.3.0rc1 'poetry==1.3.0rc1'\npipx install --suffix @main 'poetry @ git+https://github.com/python-poetry/poetry'\npipx install --suffix @local '/path/to/local/clone/of/poetry'\n\n# now you can use any of the chosen versions of Poetry with their configured suffix, e.g.\npoetry@main --version\n\nDo not forget to pipx upgrade poetry@main before using it, to make sure you have the latest changes.\n\nThis mechanism can also be used to test pull requests by using GitHub’s pull request remote refs:\n\npipx install --suffix @pr1234 git+https://github.com/python-poetry/poetry.git@refs/pull/1234/head\n\nFooter\n\nPython packaging and dependency management made easy.\n\nGitHub\nDiscord\nDOCUMENTATION\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\n GITHUB\nProject\nIssues\nDiscussions\nOTHER PROJECTS\npoetry-core\ninstall.python-poetry.org\nBundle plugin\nExport plugin\n\nCopyright © 2018-2024. All Rights Reserved.\nPowered by"
  },
  {
    "title": "The pyproject.toml file | Documentation | Poetry - Python dependency management and packaging made easy",
    "url": "https://python-poetry.org/docs/pyproject/",
    "html": "Home\nSearch\n1.8\nUse dark mode\nDOCUMENTATION\nBLOG\nHISTORY\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\npackage-mode\nname\nversion\ndescription\nlicense\nauthors\nmaintainers\nreadme\nhomepage\nrepository\ndocumentation\nkeywords\nclassifiers\npackages\ninclude and exclude\ndependencies and dependency groups\nscripts\nextras\nplugins\nurls\nPoetry and PEP-517\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\nThe pyproject.toml file\n\nThe tool.poetry section of the pyproject.toml file is composed of multiple sections.\n\npackage-mode\n\nWhether Poetry operates in package mode (default) or not. Optional\n\nSee basic usage for more information.\n\npackage-mode = false\n\nname\n\nThe name of the package. Required in package mode\n\nThis should be a valid name as defined by PEP 508.\n\nname = \"my-package\"\n\nversion\n\nThe version of the package. Required in package mode\n\nThis should be a valid PEP 440 string.\n\nversion = \"0.1.0\"\n\nIf you would like to use semantic versioning for your project, please see here.\ndescription\n\nA short description of the package. Required in package mode\n\ndescription = \"A short description of the package.\"\n\nlicense\n\nThe license of the package.\n\nThe recommended notation for the most common licenses is (alphabetical):\n\nApache-2.0\nBSD-2-Clause\nBSD-3-Clause\nBSD-4-Clause\nGPL-2.0-only\nGPL-2.0-or-later\nGPL-3.0-only\nGPL-3.0-or-later\nLGPL-2.1-only\nLGPL-2.1-or-later\nLGPL-3.0-only\nLGPL-3.0-or-later\nMIT\n\nOptional, but it is highly recommended to supply this. More identifiers are listed at the SPDX Open Source License Registry.\n\nlicense = \"MIT\"\n\nIf your project is proprietary and does not use a specific licence, you can set this value as Proprietary.\nauthors\n\nThe authors of the package. Required in package mode\n\nThis is a list of authors and should contain at least one author. Authors must be in the form name <email>.\n\nauthors = [\n    \"Sébastien Eustace <sebastien@eustace.io>\",\n]\n\nmaintainers\n\nThe maintainers of the package. Optional\n\nThis is a list of maintainers and should be distinct from authors. Maintainers may contain an email and be in the form name <email>.\n\nmaintainers = [\n    \"John Smith <johnsmith@example.org>\",\n    \"Jane Smith <janesmith@example.org>\",\n]\n\nreadme\n\nA path, or list of paths corresponding to the README file(s) of the package. Optional\n\nThe file(s) can be of any format, but if you intend to publish to PyPI keep the recommendations for a PyPI-friendly README in mind. README paths are implicitly relative to pyproject.toml.\n\nWhether paths are case-sensitive follows platform defaults, but it is recommended to keep cases.\n\nTo be specific, you can set readme = \"rEaDmE.mD\" for README.md on macOS and Windows, but Linux users can’t poetry install after cloning your repo. This is because macOS and Windows are case-insensitive and case-preserving.\n\nThe contents of the README file(s) are used to populate the Description field of your distribution’s metadata (similar to long_description in setuptools). When multiple files are specified they are concatenated with newlines.\n\n[tool.poetry]\n# ...\nreadme = \"README.md\"\n\n[tool.poetry]\n# ...\nreadme = [\"docs/README1.md\", \"docs/README2.md\"]\n\nhomepage\n\nAn URL to the website of the project. Optional\n\nhomepage = \"https://python-poetry.org/\"\n\nrepository\n\nAn URL to the repository of the project. Optional\n\nrepository = \"https://github.com/python-poetry/poetry\"\n\ndocumentation\n\nAn URL to the documentation of the project. Optional\n\ndocumentation = \"https://python-poetry.org/docs/\"\n\nkeywords\n\nA list of keywords that the package is related to. Optional\n\nkeywords = [\"packaging\", \"poetry\"]\n\nclassifiers\n\nA list of PyPI trove classifiers that describe the project. Optional\n\n[tool.poetry]\n# ...\nclassifiers = [\n    \"Topic :: Software Development :: Build Tools\",\n    \"Topic :: Software Development :: Libraries :: Python Modules\"\n]\n\n\nNote that Python classifiers are still automatically added for you and are determined by your python requirement.\n\nThe license property will also set the License classifier automatically.\n\npackages\n\nA list of packages and modules to include in the final distribution.\n\nIf your project structure differs from the standard one supported by poetry, you can specify the packages you want to include in the final distribution.\n\n[tool.poetry]\n# ...\npackages = [\n    { include = \"my_package\" },\n    { include = \"extra_package/**/*.py\" },\n]\n\n\nIf your package is stored inside a “lib” directory, you must specify it:\n\n[tool.poetry]\n# ...\npackages = [\n    { include = \"my_package\", from = \"lib\" },\n]\n\n\nThe to parameter is designed to specify the relative destination path where the package will be located upon installation. This allows for greater control over the organization of packages within your project’s structure.\n\n[tool.poetry]\n# ...\npackages = [\n    { include = \"my_package\", from = \"lib\", to = \"target_package\" },\n]\n\n\nIf you want to restrict a package to a specific build format you can specify it by using format:\n\n[tool.poetry]\n# ...\npackages = [\n    { include = \"my_package\" },\n    { include = \"my_other_package\", format = \"sdist\" },\n]\n\n\nFrom now on, only the sdist build archive will include the my_other_package package.\n\nUsing packages disables the package auto-detection feature meaning you have to explicitly specify the “default” package.\n\nFor instance, if you have a package named my_package and you want to also include another package named extra_package, you will need to specify my_package explicitly:\n\npackages = [\n    { include = \"my_package\" },\n    { include = \"extra_package\" },\n]\n\n\nPoetry is clever enough to detect Python subpackages.\n\nThus, you only have to specify the directory where your root package resides.\n\ninclude and exclude\n\nA list of patterns that will be included in the final package.\n\nYou can explicitly specify to Poetry that a set of globs should be ignored or included for the purposes of packaging. The globs specified in the exclude field identify a set of files that are not included when a package is built.\n\nIf a VCS is being used for a package, the exclude field will be seeded with the VCS’ ignore settings (.gitignore for git for example).\n\nExplicitly declaring entries in include will negate VCS' ignore settings.\n[tool.poetry]\n# ...\ninclude = [\"CHANGELOG.md\"]\n\n\nYou can also specify the formats for which these patterns have to be included, as shown here:\n\n[tool.poetry]\n# ...\ninclude = [\n    { path = \"tests\", format = \"sdist\" },\n    { path = \"for_wheel.txt\", format = [\"sdist\", \"wheel\"] }\n]\n\n\nIf no format is specified, include defaults to only sdist.\n\nIn contrast, exclude defaults to both sdist and wheel.\n\nexclude = [\"my_package/excluded.py\"]\n\ndependencies and dependency groups\n\nPoetry is configured to look for dependencies on PyPI by default. Only the name and a version string are required in this case.\n\n[tool.poetry.dependencies]\nrequests = \"^2.13.0\"\n\n\nIf you want to use a private repository, you can add it to your pyproject.toml file, like so:\n\n[[tool.poetry.source]]\nname = \"private\"\nurl = \"http://example.com/simple\"\n\n\nIf you have multiple repositories configured, you can explicitly tell poetry where to look for a specific package:\n\n[tool.poetry.dependencies]\nrequests = { version = \"^2.13.0\", source = \"private\" }\n\n\nBe aware that declaring the python version for which your package is compatible is mandatory:\n\n[tool.poetry.dependencies]\npython = \"^3.7\"\n\n\nYou can organize your dependencies in groups to manage them in a more granular way.\n\n[tool.poetry.group.test.dependencies]\npytest = \"*\"\n\n[tool.poetry.group.docs.dependencies]\nmkdocs = \"*\"\n\n\nSee Dependency groups for a more in-depth look at how to manage dependency groups and Dependency specification for more information on other keys and specifying version ranges.\n\nscripts\n\nThis section describes the scripts or executables that will be installed when installing the package\n\n[tool.poetry.scripts]\nmy_package_cli = 'my_package.console:run'\n\n\nHere, we will have the my_package_cli script installed which will execute the run function in the console module in the my_package package.\n\nWhen a script is added or updated, run poetry install to make them available in the project’s virtualenv.\nextras\n\nPoetry supports extras to allow expression of:\n\noptional dependencies, which enhance a package, but are not required; and\nclusters of optional dependencies.\n[tool.poetry]\nname = \"awesome\"\n\n[tool.poetry.dependencies]\n# These packages are mandatory and form the core of this package’s distribution.\nmandatory = \"^1.0\"\n\n# A list of all of the optional dependencies, some of which are included in the\n# below `extras`. They can be opted into by apps.\npsycopg2 = { version = \"^2.9\", optional = true }\nmysqlclient = { version = \"^1.3\", optional = true }\n\n[tool.poetry.extras]\nmysql = [\"mysqlclient\"]\npgsql = [\"psycopg2\"]\ndatabases = [\"mysqlclient\", \"psycopg2\"]\n\n\nWhen installing packages with Poetry, you can specify extras by using the -E|--extras option:\n\npoetry install --extras \"mysql pgsql\"\npoetry install -E mysql -E pgsql\n\n\nAny extras you don’t specify will be removed. Note this behavior is different from optional dependency groups not selected for install, e.g. those not specified via install --with.\n\nYou can install all extras with the --all-extras option:\n\npoetry install --all-extras\n\n\nNote that install --extras and the variations mentioned above (--all-extras, --extras foo, etc.) only work on dependencies defined in the current project. If you want to install extras defined by dependencies, you’ll have to express that in the dependency itself:\n\n[tool.poetry.dependencies]\npandas = {version=\"^2.2.1\", extras=[\"computation\", \"performance\"]}\n\n[tool.poetry.group.dev.dependencies]\nfastapi = {version=\"^0.92.0\", extras=[\"all\"]}\n\n\nWhen installing or specifying Poetry-built packages, the extras defined in this section can be activated as described in PEP 508.\n\nFor example, when installing the package using pip, the dependencies required by the databases extra can be installed as shown below.\n\npip install awesome[databases]\n\n\nThe dependencies specified for each extra must already be defined as project dependencies.\n\nDependencies listed in dependency groups cannot be specified as extras.\n\nplugins\n\nPoetry supports arbitrary plugins, which are exposed as the ecosystem-standard entry points and discoverable using importlib.metadata. This is similar to (and compatible with) the entry points feature of setuptools. The syntax for registering a plugin is:\n\n[tool.poetry.plugins] # Optional super table\n\n[tool.poetry.plugins.\"A\"]\nB = \"C:D\"\n\n\nWhich are:\n\nA - type of the plugin, for example poetry.plugin or flake8.extension\nB - name of the plugin\nC - python module import path\nD - the entry point of the plugin (a function or class)\n\nExample (from poetry-plugin-export):\n\n[tool.poetry.plugins.\"poetry.application.plugin\"]\nexport = \"poetry_plugin_export.plugins:ExportApplicationPlugin\"\n\nurls\n\nIn addition to the basic urls (homepage, repository and documentation), you can specify any custom url in the urls section.\n\n[tool.poetry.urls]\n\"Bug Tracker\" = \"https://github.com/python-poetry/poetry/issues\"\n\n\nIf you publish your package on PyPI, they will appear in the Project Links section.\n\nPoetry and PEP-517\n\nPEP-517 introduces a standard way to define alternative build systems to build a Python project.\n\nPoetry is compliant with PEP-517, by providing a lightweight core library, so if you use Poetry to manage your Python project you should reference it in the build-system section of the pyproject.toml file like so:\n\n[build-system]\nrequires = [\"poetry-core>=1.0.0\"]\nbuild-backend = \"poetry.core.masonry.api\"\n\nWhen using the new or init command this section will be automatically added.\nIf your pyproject.toml file still references poetry directly as a build backend, you should update it to reference poetry-core instead.\nFooter\n\nPython packaging and dependency management made easy.\n\nGitHub\nDiscord\nDOCUMENTATION\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\n GITHUB\nProject\nIssues\nDiscussions\nOTHER PROJECTS\npoetry-core\ninstall.python-poetry.org\nBundle plugin\nExport plugin\n\nCopyright © 2018-2024. All Rights Reserved.\nPowered by"
  },
  {
    "title": "Plugins | Documentation | Poetry - Python dependency management and packaging made easy",
    "url": "https://python-poetry.org/docs/plugins/",
    "html": "Home\nSearch\n1.8\nUse dark mode\nDOCUMENTATION\nBLOG\nHISTORY\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nCreating a plugin\nPlugin package\nGeneric plugins\nApplication plugins\nEvent handler\nUsing plugins\nWith pipx inject\nWith pip\nThe self add command\nMaintaining a plugin\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\nPlugins\n\nPoetry supports using and building plugins if you wish to alter or expand Poetry’s functionality with your own.\n\nFor example if your environment poses special requirements on the behaviour of Poetry which do not apply to the majority of its users or if you wish to accomplish something with Poetry in a way that is not desired by most users.\n\nIn these cases you could consider creating a plugin to handle your specific logic.\n\nCreating a plugin\n\nA plugin is a regular Python package which ships its code as part of the package and may also depend on further packages.\n\nPlugin package\n\nThe plugin package must depend on Poetry and declare a proper plugin in the pyproject.toml file.\n\n[tool.poetry]\nname = \"my-poetry-plugin\"\nversion = \"1.0.0\"\n\n# ...\n[tool.poetry.dependencies]\npython = \"^3.7\"\npoetry = \"^1.2\"\n\n[tool.poetry.plugins.\"poetry.plugin\"]\ndemo = \"poetry_demo_plugin.plugin:MyPlugin\"\n\nGeneric plugins\n\nEvery plugin has to supply a class which implements the poetry.plugins.Plugin interface.\n\nThe activate() method of the plugin is called after the plugin is loaded and receives an instance of Poetry as well as an instance of cleo.io.io.IO.\n\nUsing these two objects all configuration can be read and all public internal objects and state can be manipulated as desired.\n\nExample:\n\nfrom cleo.io.io import IO\n\nfrom poetry.plugins.plugin import Plugin\nfrom poetry.poetry import Poetry\n\n\nclass MyPlugin(Plugin):\n\n    def activate(self, poetry: Poetry, io: IO):\n        io.write_line(\"Setting readme\")\n        poetry.package.readme = \"README.md\"\n        ...\n\nApplication plugins\n\nIf you want to add commands or options to the poetry script you need to create an application plugin which implements the poetry.plugins.ApplicationPlugin interface.\n\nThe activate() method of the application plugin is called after the plugin is loaded and receives an instance of poetry.console.Application.\n\nfrom cleo.commands.command import Command\nfrom poetry.plugins.application_plugin import ApplicationPlugin\n\n\nclass CustomCommand(Command):\n\n    name = \"my-command\"\n\n    def handle(self) -> int:\n        self.line(\"My command\")\n\n        return 0\n\n\ndef factory():\n    return CustomCommand()\n\n\nclass MyApplicationPlugin(ApplicationPlugin):\n    def activate(self, application):\n        application.command_loader.register_factory(\"my-command\", factory)\n\n\nIt’s possible to do the following to register the command:\n\napplication.add(MyCommand())\n\n\nHowever, it is strongly recommended to register a new factory in the command loader to defer the loading of the command when it’s actually called.\n\nThis will help keep the performances of Poetry good.\n\nThe plugin also must be declared in the pyproject.toml file of the plugin package as a poetry.application.plugin plugin:\n\n[tool.poetry.plugins.\"poetry.application.plugin\"]\nfoo-command = \"poetry_demo_plugin.plugin:MyApplicationPlugin\"\n\nA plugin must not remove or modify in any way the core commands of Poetry.\nEvent handler\n\nPlugins can also listen to specific events and act on them if necessary.\n\nThese events are fired by Cleo and are accessible from the cleo.events.console_events module.\n\nCOMMAND: this event allows attaching listeners before any command is executed.\nSIGNAL: this event allows some actions to be performed after the command execution is interrupted.\nTERMINATE: this event allows listeners to be attached after the command.\nERROR: this event occurs when an uncaught exception is raised.\n\nLet’s see how to implement an application event handler. For this example we will see how to load environment variables from a .env file before executing a command.\n\nfrom cleo.events.console_events import COMMAND\nfrom cleo.events.console_command_event import ConsoleCommandEvent\nfrom cleo.events.event_dispatcher import EventDispatcher\nfrom dotenv import load_dotenv\nfrom poetry.console.application import Application\nfrom poetry.console.commands.env_command import EnvCommand\nfrom poetry.plugins.application_plugin import ApplicationPlugin\n\n\nclass MyApplicationPlugin(ApplicationPlugin):\n    def activate(self, application: Application):\n        application.event_dispatcher.add_listener(\n            COMMAND, self.load_dotenv\n        )\n\n    def load_dotenv(\n        self,\n        event: ConsoleCommandEvent,\n        event_name: str,\n        dispatcher: EventDispatcher\n    ) -> None:\n        command = event.command\n        if not isinstance(command, EnvCommand):\n            return\n\n        io = event.io\n\n        if io.is_debug():\n            io.write_line(\n                \"<debug>Loading environment variables.</debug>\"\n            )\n\n        load_dotenv()\n\nUsing plugins\n\nInstalled plugin packages are automatically loaded when Poetry starts up.\n\nYou have multiple ways to install plugins for Poetry\n\nWith pipx inject\n\nIf you used pipx to install Poetry you can add the plugin packages via the pipx inject command.\n\npipx inject poetry poetry-plugin\n\n\nIf you want to uninstall a plugin, you can run:\n\npipx uninject poetry poetry-plugin          # For pipx versions >= 1.2.0\n\npipx runpip poetry uninstall poetry-plugin  # For pipx versions  < 1.2.0\n\nWith pip\n\nThe pip binary in Poetry’s virtual environment can also be used to install and remove plugins. The environment variable $POETRY_HOME here is used to represent the path to the virtual environment. The installation instructions can be referenced if you are not sure where Poetry has been installed.\n\nTo add a plugin, you can use pip install:\n\n$POETRY_HOME/bin/pip install --user poetry-plugin\n\n\nIf you want to uninstall a plugin, you can run:\n\n$POETRY_HOME/bin/pip uninstall poetry-plugin\n\nThe self add command\nEspecially on Windows, self add and self remove may be problematic so that other methods should be preferred.\npoetry self add poetry-plugin\n\n\nThe self add command will ensure that the plugin is compatible with the current version of Poetry and install the needed packages for the plugin to work.\n\nThe package specification formats supported by the self add command are the same as the ones supported by the add command.\n\nIf you no longer need a plugin and want to uninstall it, you can use the self remove command.\n\npoetry self remove poetry-plugin\n\n\nYou can also list all currently installed plugins by running:\n\npoetry self show plugins\n\nMaintaining a plugin\n\nWhen writing a plugin, you will probably access internals of Poetry, since there is no stable public API. Although we try our best to deprecate methods first, before removing them, sometimes the signature of an internal method has to be changed.\n\nAs the author of a plugin, you are probably testing your plugin against the latest release of Poetry. Additionally, you should consider testing against the latest release branch and the main branch of Poetry and schedule a CI job that runs regularly even if you did not make any changes to your plugin. This way, you will notice internal changes that break your plugin immediately and can prepare for the next Poetry release.\n\nFooter\n\nPython packaging and dependency management made easy.\n\nGitHub\nDiscord\nDOCUMENTATION\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\n GITHUB\nProject\nIssues\nDiscussions\nOTHER PROJECTS\npoetry-core\ninstall.python-poetry.org\nBundle plugin\nExport plugin\n\nCopyright © 2018-2024. All Rights Reserved.\nPowered by"
  },
  {
    "title": "Dependency specification | Documentation | Poetry - Python dependency management and packaging made easy",
    "url": "https://python-poetry.org/docs/dependency-specification/",
    "html": "Home\nSearch\n1.8\nUse dark mode\nDOCUMENTATION\nBLOG\nHISTORY\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nVersion constraints\nCaret requirements\nTilde requirements\nWildcard requirements\nInequality requirements\nExact requirements\nUsing the @ operator\ngit dependencies\npath dependencies\nurl dependencies\nDependency extras\nsource dependencies\nPython restricted dependencies\nUsing environment markers\nMultiple constraints dependencies\nCombining git / url / path dependencies with source repositories\nExpanded dependency specification syntax\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\nDependency specification\n\nDependencies for a project can be specified in various forms, which depend on the type of the dependency and on the optional constraints that might be needed for it to be installed.\n\nVersion constraints\nCaret requirements\n\nCaret requirements allow SemVer compatible updates to a specified version. An update is allowed if the new version number does not modify the left-most non-zero digit in the major, minor, patch grouping. For instance, if we previously ran poetry add requests@^2.13.0 and wanted to update the library and ran poetry update requests, poetry would update us to version 2.14.0 if it was available, but would not update us to 3.0.0. If instead we had specified the version string as ^0.1.13, poetry would update to 0.1.14 but not 0.2.0. 0.0.x is not considered compatible with any other version.\n\nHere are some more examples of caret requirements and the versions that would be allowed with them:\n\nREQUIREMENT\tVERSIONS ALLOWED\n^1.2.3\t>=1.2.3 <2.0.0\n^1.2\t>=1.2.0 <2.0.0\n^1\t>=1.0.0 <2.0.0\n^0.2.3\t>=0.2.3 <0.3.0\n^0.0.3\t>=0.0.3 <0.0.4\n^0.0\t>=0.0.0 <0.1.0\n^0\t>=0.0.0 <1.0.0\nTilde requirements\n\nTilde requirements specify a minimal version with some ability to update. If you specify a major, minor, and patch version or only a major and minor version, only patch-level changes are allowed. If you only specify a major version, then minor- and patch-level changes are allowed.\n\n~1.2.3 is an example of a tilde requirement.\n\nREQUIREMENT\tVERSIONS ALLOWED\n~1.2.3\t>=1.2.3 <1.3.0\n~1.2\t>=1.2.0 <1.3.0\n~1\t>=1.0.0 <2.0.0\nWildcard requirements\n\nWildcard requirements allow for the latest (dependency dependent) version where the wildcard is positioned.\n\n*, 1.* and 1.2.* are examples of wildcard requirements.\n\nREQUIREMENT\tVERSIONS ALLOWED\n*\t>=0.0.0\n1.*\t>=1.0.0 <2.0.0\n1.2.*\t>=1.2.0 <1.3.0\nInequality requirements\n\nInequality requirements allow manually specifying a version range or an exact version to depend on.\n\nHere are some examples of inequality requirements:\n\n>= 1.2.0\n> 1\n< 2\n!= 1.2.3\n\nMultiple requirements\n\nMultiple version requirements can also be separated with a comma, e.g. >= 1.2, < 1.5.\n\nExact requirements\n\nYou can specify the exact version of a package.\n\n1.2.3 is an example of an exact version specification.\n\nThis will tell Poetry to install this version and this version only. If other dependencies require a different version, the solver will ultimately fail and abort any install or update procedures.\n\nExact versions can also be specified with == according to PEP 440.\n\n==1.2.3 is an example of this.\n\nUsing the @ operator\n\nWhen adding dependencies via poetry add, you can use the @ operator. This is understood similarly to the == syntax, but also allows prefixing any specifiers that are valid in pyproject.toml. For example:\n\npoetry add django@^4.0.0\n\n\nThe above would translate to the following entry in pyproject.toml:\n\nDjango = \"^4.0.0\"\n\n\nThe special keyword latest is also understood by the @ operator:\n\npoetry add django@latest\n\n\nThe above would translate to the following entry in pyproject.toml, assuming the latest release of django is 4.0.5:\n\nDjango = \"^4.0.5\"\n\nExtras\n\nExtras and @ can be combined as one might expect (package[extra]@version):\n\npoetry add django[bcrypt]@^4.0.0\n\ngit dependencies\n\nTo depend on a library located in a git repository, the minimum information you need to specify is the location of the repository with the git key:\n\n[tool.poetry.dependencies]\nrequests = { git = \"https://github.com/requests/requests.git\" }\n\n\nSince we haven’t specified any other information, Poetry assumes that we intend to use the latest commit on the main branch to build our project.\n\nYou can combine the git key with the branch key to use another branch. Alternatively, use rev or tag to pin a dependency to a specific commit hash or tagged ref, respectively. For example:\n\n[tool.poetry.dependencies]\n# Get the latest revision on the branch named \"next\"\nrequests = { git = \"https://github.com/kennethreitz/requests.git\", branch = \"next\" }\n# Get a revision by its commit hash\nflask = { git = \"https://github.com/pallets/flask.git\", rev = \"38eb5d3b\" }\n# Get a revision by its tag\nnumpy = { git = \"https://github.com/numpy/numpy.git\", tag = \"v0.13.2\" }\n\n\nIn cases where the package you want to install is located in a subdirectory of the VCS repository, you can use the subdirectory option, similarly to what pip provides:\n\n[tool.poetry.dependencies]\n# Install a package named `subdir_package` from a folder called `subdir` within the repository\nsubdir_package = { git = \"https://github.com/myorg/mypackage_with_subdirs.git\", subdirectory = \"subdir\" }\n\n\nwith the corresponding add call:\n\npoetry add \"git+https://github.com/myorg/mypackage_with_subdirs.git#subdirectory=subdir\"\n\n\nTo use an SSH connection, for example in the case of private repositories, use the following example syntax:\n\n[tool.poetry.dependencies]\nrequests = { git = \"git@github.com:requests/requests.git\" }\n\n\nTo use HTTP basic authentication with your git repositories, you can configure credentials similar to how repository credentials are configured.\n\npoetry config repositories.git-org-project https://github.com/org/project.git\npoetry config http-basic.git-org-project username token\npoetry add git+https://github.com/org/project.git\n\n\nWith Poetry 1.2 releases, the default git client used is Dulwich.\n\nWe fall back to legacy system git client implementation in cases where gitcredentials is used. This fallback will be removed in a future release where gitcredentials helpers can be better supported natively.\n\nIn cases where you encounter issues with the default implementation that used to work prior to Poetry 1.2, you may wish to explicitly configure the use of the system git client via a shell subprocess call.\n\npoetry config experimental.system-git-client true\n\n\nKeep in mind however, that doing so will surface bugs that existed in versions prior to 1.2 which were caused due to the use of the system git client.\n\npath dependencies\n\nTo depend on a library located in a local directory or file, you can use the path property:\n\n[tool.poetry.dependencies]\n# directory\nmy-package = { path = \"../my-package/\", develop = false }\n\n# file\nmy-package = { path = \"../my-package/dist/my-package-0.1.0.tar.gz\" }\n\nBefore poetry 1.1 directory path dependencies were installed in editable mode by default. You should set the develop attribute explicitly, to make sure the behavior is the same for all poetry versions.\nurl dependencies\n\nTo depend on a library located on a remote archive, you can use the url property:\n\n[tool.poetry.dependencies]\n# directory\nmy-package = { url = \"https://example.com/my-package-0.1.0.tar.gz\" }\n\n\nwith the corresponding add call:\n\npoetry add https://example.com/my-package-0.1.0.tar.gz\n\nDependency extras\n\nYou can specify PEP-508 Extras for a dependency as shown here.\n\n[tool.poetry.dependencies]\ngunicorn = { version = \"^20.1\", extras = [\"gevent\"] }\n\nThese activate extra defined for the dependency, to configure an optional dependency for extras in your project refer to extras.\nsource dependencies\n\nTo depend on a package from an alternate repository, you can use the source property:\n\n[[tool.poetry.source]]\nname = \"foo\"\nurl = \"https://foo.bar/simple/\"\npriority = \"supplemental\"\n\n[tool.poetry.dependencies]\nmy-cool-package = { version = \"*\", source = \"foo\" }\n\n\nwith the corresponding add call:\n\npoetry add my-cool-package --source foo\n\nIn this example, we expect foo to be configured correctly. See using a private repository for further information.\nPython restricted dependencies\n\nYou can also specify that a dependency should be installed only for specific Python versions:\n\n[tool.poetry.dependencies]\ntomli = { version = \"^2.0.1\", python = \"<3.11\" }\n\n[tool.poetry.dependencies]\npathlib2 = { version = \"^2.2\", python = \"^3.2\" }\n\nUsing environment markers\n\nIf you need more complex install conditions for your dependencies, Poetry supports environment markers via the markers property:\n\n[tool.poetry.dependencies]\npathlib2 = { version = \"^2.2\", markers = \"python_version <= '3.4' or sys_platform == 'win32'\" }\n\nMultiple constraints dependencies\n\nSometimes, one of your dependency may have different version ranges depending on the target Python versions.\n\nLet’s say you have a dependency on the package foo which is only compatible with Python 3.6-3.7 up to version 1.9, and compatible with Python 3.8+ from version 2.0: you would declare it like so:\n\n[tool.poetry.dependencies]\nfoo = [\n    {version = \"<=1.9\", python = \">=3.6,<3.8\"},\n    {version = \"^2.0\", python = \">=3.8\"}\n]\n\nThe constraints must have different requirements (like python) otherwise it will cause an error when resolving dependencies.\nCombining git / url / path dependencies with source repositories\n\nDirect origin (git/ url/ path) dependencies can satisfy the requirement of a dependency that doesn’t explicitly specify a source, even when mutually exclusive markers are used. For instance in the following example the url package will also be a valid solution for the second requirement:\n\nfoo = [\n    { platform = \"darwin\", url = \"https://example.com/example-1.0-py3-none-any.whl\" },\n    { platform = \"linux\", version = \"^1.0\" },\n]\n\n\nSometimes you may instead want to use a direct origin dependency for specific conditions (i.e. a compiled package that is not available on PyPI for a certain platform/architecture) while falling back on source repositories in other cases. In this case you should explicitly ask for your dependency to be satisfied by another source. For example:\n\nfoo = [\n    { platform = \"darwin\", url = \"https://example.com/foo-1.0.0-py3-none-macosx_11_0_arm64.whl\" },\n    { platform = \"linux\", version = \"^1.0\", source = \"pypi\" },\n]\n\nExpanded dependency specification syntax\n\nIn the case of more complex dependency specifications, you may find that you end up with lines which are very long and difficult to read. In these cases, you can shift from using “inline table” syntax, to the “standard table” syntax.\n\nAn example where this might be useful is the following:\n\n[tool.poetry.group.dev.dependencies]\nblack = {version = \"19.10b0\", allow-prereleases = true, python = \"^3.7\", markers = \"platform_python_implementation == 'CPython'\"}\n\n\nAs a single line, this is a lot to digest. To make this a bit easier to work with, you can do the following:\n\n[tool.poetry.group.dev.dependencies.black]\nversion = \"19.10b0\"\nallow-prereleases = true\npython = \"^3.7\"\nmarkers = \"platform_python_implementation == 'CPython'\"\n\n\nThe same information is still present, and ends up providing the exact same specification. It’s simply split into multiple, slightly more readable, lines.\n\nFooter\n\nPython packaging and dependency management made easy.\n\nGitHub\nDiscord\nDOCUMENTATION\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\n GITHUB\nProject\nIssues\nDiscussions\nOTHER PROJECTS\npoetry-core\ninstall.python-poetry.org\nBundle plugin\nExport plugin\n\nCopyright © 2018-2024. All Rights Reserved.\nPowered by"
  },
  {
    "title": "Managing environments | Documentation | Poetry - Python dependency management and packaging made easy",
    "url": "https://python-poetry.org/docs/managing-environments/",
    "html": "Home\nSearch\n1.8\nUse dark mode\nDOCUMENTATION\nBLOG\nHISTORY\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nSwitching between environments\nDisplaying the environment information\nListing the environments associated with the project\nDeleting the environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\nManaging environments\n\nPoetry makes project environment isolation one of its core features.\n\nWhat this means is that it will always work isolated from your global Python installation. To achieve this, it will first check if it’s currently running inside a virtual environment. If it is, it will use it directly without creating a new one. But if it’s not, it will use one that it has already created or create a brand new one for you.\n\nBy default, Poetry will try to use the Python version used during Poetry’s installation to create the virtual environment for the current project.\n\nHowever, for various reasons, this Python version might not be compatible with the python range supported by the project. In this case, Poetry will try to find one that is and use it. If it’s unable to do so then you will be prompted to activate one explicitly, see Switching environments.\n\nIf you use a tool like pyenv to manage different Python versions, you can set the experimental virtualenvs.prefer-active-python option to true. Poetry will then try to find the current python of your shell.\n\nFor instance, if your project requires a newer Python than is available with your system, a standard workflow would be:\n\npyenv install 3.9.8\npyenv local 3.9.8  # Activate Python 3.9 for the current project\npoetry install\n\nSince version 1.2, Poetry no longer supports managing environments for Python 2.7.\nSwitching between environments\n\nSometimes this might not be feasible for your system, especially Windows where pyenv is not available, or you simply prefer to have a more explicit control over your environment. For this specific purpose, you can use the env use command to tell Poetry which Python version to use for the current project.\n\npoetry env use /full/path/to/python\n\n\nIf you have the python executable in your PATH you can use it:\n\npoetry env use python3.7\n\n\nYou can even just use the minor Python version in this case:\n\npoetry env use 3.7\n\n\nIf you want to disable the explicitly activated virtual environment, you can use the special system Python version to retrieve the default behavior:\n\npoetry env use system\n\nDisplaying the environment information\n\nIf you want to get basic information about the currently activated virtual environment, you can use the env info command:\n\npoetry env info\n\n\nwill output something similar to this:\n\nVirtualenv\nPython:         3.7.1\nImplementation: CPython\nPath:           /path/to/poetry/cache/virtualenvs/test-O3eWbxRl-py3.7\nValid:          True\n\nBase\nPlatform: darwin\nOS:       posix\nPython:   /path/to/main/python\n\n\nIf you only want to know the path to the virtual environment, you can pass the --path option to env info:\n\npoetry env info --path\n\n\nIf you only want to know the path to the python executable (useful for running mypy from a global environment without installing it in the virtual environment), you can pass the --executable option to env info:\n\npoetry env info --executable\n\nListing the environments associated with the project\n\nYou can also list all the virtual environments associated with the current project with the env list command:\n\npoetry env list\n\n\nwill output something like the following:\n\ntest-O3eWbxRl-py3.6\ntest-O3eWbxRl-py3.7 (Activated)\n\n\nYou can pass the option --full-path to display the full path to the environments:\n\npoetry env list --full-path\n\nDeleting the environments\n\nFinally, you can delete existing virtual environments by using env remove:\n\npoetry env remove /full/path/to/python\npoetry env remove python3.7\npoetry env remove 3.7\npoetry env remove test-O3eWbxRl-py3.7\n\n\nYou can delete more than one environment at a time.\n\npoetry env remove python3.6 python3.7 python3.8\n\n\nUse the --all option to delete all virtual environments at once.\n\npoetry env remove --all\n\n\nIf you remove the currently activated virtual environment, it will be automatically deactivated.\n\nFooter\n\nPython packaging and dependency management made easy.\n\nGitHub\nDiscord\nDOCUMENTATION\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\n GITHUB\nProject\nIssues\nDiscussions\nOTHER PROJECTS\npoetry-core\ninstall.python-poetry.org\nBundle plugin\nExport plugin\n\nCopyright © 2018-2024. All Rights Reserved.\nPowered by"
  },
  {
    "title": "Repositories | Documentation | Poetry - Python dependency management and packaging made easy",
    "url": "https://python-poetry.org/docs/repositories/",
    "html": "Home\nSearch\n1.8\nUse dark mode\nDOCUMENTATION\nBLOG\nHISTORY\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nPrivate Repository Example\nPackage Sources\nProject Configuration\nSupported Package Sources\nPublishable Repositories\nConfiguring Credentials\nCertificates\nCustom certificate authority and mutual TLS authentication\nCaches\nDebugging Issues\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\nRepositories\n\nPoetry supports the use of PyPI and private repositories for discovery of packages as well as for publishing your projects.\n\nBy default, Poetry is configured to use the PyPI repository, for package installation and publishing.\n\nSo, when you add dependencies to your project, Poetry will assume they are available on PyPI.\n\nThis represents most cases and will likely be enough for most users.\n\nPrivate Repository Example\nInstalling from private package sources\n\nBy default, Poetry discovers and installs packages from PyPI. But, you want to install a dependency to your project for a simple API repository? Let’s do it.\n\nFirst, configure the package source as a supplemental (or explicit) package source to your project.\n\npoetry source add --priority=supplemental foo https://pypi.example.org/simple/\n\n\nThen, assuming the repository requires authentication, configure credentials for it.\n\npoetry config http-basic.foo <username> <password>\n\nDepending on your system configuration, credentials might be saved in your command line history. Many shells do not save commands to history when they are prefixed by a space character. For more information, please refer to your shell’s documentation.\n\nIf you would like to provide the password interactively, you can simply omit <password> in your command. And Poetry will prompt you to enter the credential manually.\n\npoetry config http-basic.foo <username>\n\n\nOnce this is done, you can add dependencies to your project from this source.\n\npoetry add --source foo private-package\n\nPublishing to a private repository\n\nGreat, now all that is left is to publish your package. Assuming you’d want to share it privately with your team, you can configure the Upload API endpoint for your publishable repository.\n\npoetry config repositories.foo https://pypi.example.org/legacy/\n\n\nIf you need to use a different credential for your package source, then it is recommended to use a different name for your publishing repository.\n\npoetry config repositories.foo-pub https://pypi.example.org/legacy/\npoetry config http-basic.foo-pub <username> <password>\n\n\nWhen configuring a repository using environment variables, note that correct suffixes need to be used.\n\nexport POETRY_REPOSITORIES_FOO_URL=https://pypi.example.org/legacy/\nexport POETRY_HTTP_BASIC_FOO_USERNAME=<username>\nexport POETRY_HTTP_BASIC_FOO_PASSWORD=<password>\n\n\nNow, all the is left is to build and publish your project using the publish.\n\npoetry publish --build --repository foo-pub\n\nPackage Sources\n\nBy default, Poetry is configured to use the Python ecosystem’s canonical package index PyPI.\n\nWith the exception of the implicitly configured source for PyPI named pypi, package sources are local to a project and must be configured within the project’s pyproject.toml file. This is not the same configuration used when publishing a package.\nProject Configuration\n\nThese package sources may be managed using the source command for your project.\n\npoetry source add foo https://foo.bar/simple/\n\nIf your package source requires credentials or certificates, please refer to the relevant sections below.\n\nThis will generate the following configuration snippet in your pyproject.toml file.\n\n[[tool.poetry.source]]\nname = \"foo\"\nurl = \"https://foo.bar/simple/\"\npriority = \"primary\"\n\n\nIf priority is undefined, the source is considered a primary source that takes precedence over PyPI, secondary, supplemental and explicit sources.\n\nPackage sources are considered in the following order:\n\ndefault source (DEPRECATED),\nprimary sources,\nimplicit PyPI (unless disabled by another primary source, default source or configured explicitly),\nsecondary sources (DEPRECATED),\nsupplemental sources.\n\nExplicit sources are considered only for packages that explicitly indicate their source.\n\nWithin each priority class, package sources are considered in order of appearance in pyproject.toml.\n\nIf you want to change the priority of PyPI, you can set it explicitly, e.g.\n\npoetry source add --priority=primary PyPI\n\n\nIf you prefer to disable PyPI completely, just add a primary source or configure PyPI as explicit source.\n\nDefault Package Source (DEPRECATED)\n\nDeprecated in 1.8.0\n\nConfiguring a default package source is deprecated because it is the same as the topmost primary source. Just configure a primary package source and put it first in the list of package sources.\n\nBy default, if you have not configured any primary source, Poetry will configure PyPI as the package source for your project. You can alter this behaviour and exclusively look up packages only from the configured package sources by adding at least one primary source (recommended) or a single source with priority = \"default\" (deprecated).\n\npoetry source add --priority=default foo https://foo.bar/simple/\n\nPrimary Package Sources\n\nAll primary package sources are searched for each dependency without a source constraint. If you configure at least one primary source, the implicit PyPI source is disabled.\n\npoetry source add --priority=primary foo https://foo.bar/simple/\n\n\nSources without a priority are considered primary sources, too.\n\npoetry source add foo https://foo.bar/simple/\n\n\nThe implicit PyPI source is disabled automatically if at least one primary source is configured. If you want to use PyPI in addition to a primary source, configure it explicitly with a certain priority, e.g.\n\npoetry source add --priority=primary PyPI\n\n\nThis way, the priority of PyPI can be set in a fine-granular way.\n\nThe equivalent specification in pyproject.toml is:\n\n[[tool.poetry.source]]\nname = \"pypi\"\npriority = \"primary\"\n\n\nOmit the url when specifying PyPI explicitly. Because PyPI is internally configured with Poetry, the PyPI repository cannot be configured with a given URL. Remember, you can always use poetry check to ensure the validity of the pyproject.toml file.\n\nSecondary Package Sources (DEPRECATED)\n\nDeprecated in 1.5.0\n\nIf package sources are configured as secondary, all it means is that these will be given a lower priority when selecting compatible package distribution that also exists in your default and primary package sources. If the package source should instead be searched only if higher-priority repositories did not return results, please consider a supplemental source instead.\n\nYou can configure a package source as a secondary source with priority = \"secondary\" in your package source configuration.\n\npoetry source add --priority=secondary foo https://foo.bar/simple/\n\n\nThere can be more than one secondary package source.\n\nSecondary package sources are deprecated in favor of supplemental package sources.\nSupplemental Package Sources\n\nIntroduced in 1.5.0\n\nPackage sources configured as supplemental are only searched if no other (higher-priority) source yields a compatible package distribution. This is particularly convenient if the response time of the source is high and relatively few package distributions are to be fetched from this source.\n\nYou can configure a package source as a supplemental source with priority = \"supplemental\" in your package source configuration.\n\npoetry source add --priority=supplemental foo https://foo.bar/simple/\n\n\nThere can be more than one supplemental package source.\n\nTake into account that someone could publish a new package to a primary source which matches a package in your supplemental source. They could coincidentally or intentionally replace your dependency with something you did not expect.\nExplicit Package Sources\n\nIntroduced in 1.5.0\n\nIf package sources are configured as explicit, these sources are only searched when a package configuration explicitly indicates that it should be found on this package source.\n\nYou can configure a package source as an explicit source with priority = \"explicit\" in your package source configuration.\n\npoetry source add --priority=explicit foo https://foo.bar/simple/\n\n\nThere can be more than one explicit package source.\n\nA real-world example where an explicit package source is useful, is for PyTorch GPU packages.\n\npoetry source add --priority=explicit pytorch-gpu-src https://download.pytorch.org/whl/cu118\npoetry add --source pytorch-gpu-src torch torchvision torchaudio\n\nPackage Source Constraint\n\nAll package sources (including secondary and possibly supplemental sources) will be searched during the package lookup process. These network requests will occur for all sources, regardless of if the package is found at one or more sources.\n\nIn order to limit the search for a specific package to a particular package repository, you can specify the source explicitly.\n\npoetry add --source internal-pypi httpx\n\n\nThis results in the following configuration in pyproject.toml:\n\n[tool.poetry.dependencies]\n...\nhttpx = { version = \"^0.22\", source = \"internal-pypi\" }\n\n[[tool.poetry.source]]\nname = \"internal-pypi\"\nurl = ...\npriority = ...\n\nA repository that is configured to be the only source for retrieving a certain package can itself have any priority. In particular, it does not need to have priority \"explicit\". If a repository is configured to be the source of a package, it will be the only source that is considered for that package and the repository priority will have no effect on the resolution.\n\nPackage source keys are not inherited by their dependencies. In particular, if package-A is configured to be found in source = internal-pypi, and package-A depends on package-B that is also to be found on internal-pypi, then package-B needs to be configured as such in pyproject.toml. The easiest way to achieve this is to add package-B with a wildcard constraint:\n\npoetry add --source internal-pypi package-B@*\n\n\nThis will ensure that package-B is searched only in the internal-pypi package source. The version constraints on package-B are derived from package-A (and other client packages), as usual.\n\nIf you want to avoid additional main dependencies, you can add package-B to a dedicated dependency group:\n\npoetry add --group explicit --source internal-pypi package-B@*\n\nPackage source constraints are strongly suggested for all packages that are expected to be provided only by one specific source to avoid dependency confusion attacks.\nSupported Package Sources\nPython Package Index (PyPI)\n\nPoetry interacts with PyPI via its JSON API. This is used to retrieve a requested package’s versions, metadata, files, etc.\n\nIf the the package’s published metadata is invalid, Poetry will download the available bdist/sdist to inspect it locally to identify the relevant metadata.\n\nIf you want to explicitly select a package from PyPI you can use the --source option with the add command, like shown below.\n\npoetry add --source pypi httpx@^0.22.0\n\n\nThis will generate the following configuration snippet in your pyproject.toml file.\n\nhttpx = {version = \"^0.22.0\", source = \"pypi\"}\n\nIf any source within a project is configured with priority = \"default\", The implicit pypi source will be disabled and not used for any packages.\nSimple API Repository\n\nPoetry can fetch and install package dependencies from public or private custom repositories that implement the simple repository API as described in PEP 503.\n\nWhen using sources that distributes large wheels without providing file checksum in file URLs, Poetry will download each candidate wheel at least once in order to generate the checksum. This can manifest as long dependency resolution times when adding packages from this source.\n\nThese package sources may be configured via the following command in your project.\n\npoetry source add testpypi https://test.pypi.org/simple/\n\nNote the trailing /simple/. This is important when configuring PEP 503 compliant package sources.\n\nIn addition to PEP 503, Poetry can also handle simple API repositories that implement PEP 658 (Introduced in 1.2.0). This is helpful in reducing dependency resolution time for packages from these sources as Poetry can avoid having to download each candidate distribution, in order to determine associated metadata.\n\nWhy does Poetry insist on downloading all candidate distributions for all platforms when metadata is not available?\n\nThe need for this stems from the fact that Poetry’s lock file is platform-agnostic. This means, in order to resolve dependencies for a project, Poetry needs metadata for all platform specific distributions. And when this metadata is not readily available, downloading the distribution and inspecting it locally is the only remaining option.\n\nSingle Page Link Source\n\nIntroduced in 1.2.0\n\nSome projects choose to release their binary distributions via a single page link source that partially follows the structure of a package page in PEP 503.\n\nThese package sources may be configured via the following command in your project.\n\npoetry source add jax https://storage.googleapis.com/jax-releases/jax_releases.html\n\nAll caveats regarding slower resolution times described for simple API repositories do apply here as well.\nPublishable Repositories\n\nPoetry treats repositories to which you publish packages as user specific and not project specific configuration unlike package sources. Poetry, today, only supports the Legacy Upload API when publishing your project.\n\nThese are configured using the config command, under the repositories key.\n\npoetry config repositories.testpypi https://test.pypi.org/legacy/\n\nLegacy Upload API URLs are typically different to the same one provided by the repository for the simple API. You’ll note that in the example of Test PyPI, both the host (test.pypi.org) as well as the path (/legacy) are different to its simple API (https://test.pypi.org/simple).\nConfiguring Credentials\n\nIf you want to store your credentials for a specific repository, you can do so easily:\n\npoetry config http-basic.foo <username> <password>\n\n\nIf you do not specify the password you will be prompted to write it.\n\nTo publish to PyPI, you can set your credentials for the repository named pypi.\n\nNote that it is recommended to use API tokens when uploading packages to PyPI. Once you have created a new token, you can tell Poetry to use it:\n\npoetry config pypi-token.pypi <my-token>\n\n\nIf you have configured testpypi as a Publishable Repository, the token can be set using\n\npoetry config pypi-token.testpypi <your-token>\n\n\nIf you still want to use your username and password, you can do so with the following call to config.\n\npoetry config http-basic.pypi <username> <password>\n\n\nYou can also specify the username and password when using the publish command with the --username and --password options.\n\nIf a system keyring is available and supported, the password is stored to and retrieved from the keyring. In the above example, the credential will be stored using the name poetry-repository-pypi. If access to keyring fails or is unsupported, this will fall back to writing the password to the auth.toml file along with the username.\n\nKeyring support is enabled using the keyring library. For more information on supported backends refer to the library documentation.\n\nIf you do not want to use the keyring, you can tell Poetry to disable it and store the credentials in plaintext config files:\n\npoetry config keyring.enabled false\n\nPoetry will fallback to Pip style use of keyring so that backends like Microsoft’s artifacts-keyring get a chance to retrieve valid credentials. It will need to be properly installed into Poetry’s virtualenv, preferably by installing a plugin.\n\nAlternatively, you can use environment variables to provide the credentials:\n\nexport POETRY_PYPI_TOKEN_FOO=my-token\nexport POETRY_HTTP_BASIC_FOO_USERNAME=<username>\nexport POETRY_HTTP_BASIC_FOO_PASSWORD=<password>\n\n\nwhere FOO is the name of the repository in uppercase (e.g. PYPI). See Using environment variables for more information on how to configure Poetry with environment variables.\n\nIf your password starts with a dash (e.g. randomly generated tokens in a CI environment), it will be parsed as a command line option instead of a password. You can prevent this by adding double dashes to prevent any following argument from being parsed as an option.\n\npoetry config -- http-basic.pypi myUsername -myPasswordStartingWithDash\n\nCertificates\nCustom certificate authority and mutual TLS authentication\n\nPoetry supports repositories that are secured by a custom certificate authority as well as those that require certificate-based client authentication. The following will configure the “foo” repository to validate the repository’s certificate using a custom certificate authority and use a client certificate (note that these config variables do not both need to be set):\n\npoetry config certificates.foo.cert /path/to/ca.pem\npoetry config certificates.foo.client-cert /path/to/client.pem\n\n\nThe value of certificates.<repository>.cert can be set to false if certificate verification is required to be skipped. This is useful for cases where a package source with self-signed certificates are used.\n\npoetry config certificates.foo.cert false\n\nDisabling certificate verification is not recommended as it is does not conform to security best practices.\nCaches\n\nPoetry employs multiple caches for package sources in order to improve user experience and avoid duplicate network requests.\n\nThe first level cache is a Cache-Control header based cache for almost all HTTP requests.\n\nFurther, every HTTP backed package source caches metadata associated with a package once it is fetched or generated. Additionally, downloaded files (package distributions) are also cached.\n\nDebugging Issues\n\nIf you encounter issues with package sources, one of the simplest steps you might take to debug an issue is rerunning your command with the --no-cache flag.\n\npoetry --no-cache add pycowsay\n\n\nIf this solves your issue, you can consider clearing your cache using the cache command.\n\nAlternatively, you could also consider enabling very verbose logging -vvv along with the --no-cache to see network requests being made in the logs.\n\nFooter\n\nPython packaging and dependency management made easy.\n\nGitHub\nDiscord\nDOCUMENTATION\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\n GITHUB\nProject\nIssues\nDiscussions\nOTHER PROJECTS\npoetry-core\ninstall.python-poetry.org\nBundle plugin\nExport plugin\n\nCopyright © 2018-2024. All Rights Reserved.\nPowered by"
  },
  {
    "title": "Configuration | Documentation | Poetry - Python dependency management and packaging made easy",
    "url": "https://python-poetry.org/docs/configuration/",
    "html": "Home\nSearch\n1.8\nUse dark mode\nDOCUMENTATION\nBLOG\nHISTORY\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nLocal configuration\nListing the current configuration\nDisplaying a single configuration setting\nAdding or updating a configuration setting\nRemoving a specific setting\nUsing environment variables\nDefault Directories\nConfig Directory\nData Directory\nCache Directory\nAvailable settings\ncache-dir\nexperimental.system-git-client\ninstaller.max-workers\ninstaller.modern-installation\ninstaller.no-binary\ninstaller.parallel\nsolver.lazy-wheel\nvirtualenvs.create\nvirtualenvs.in-project\nvirtualenvs.options.always-copy\nvirtualenvs.options.no-pip\nvirtualenvs.options.no-setuptools\nvirtualenvs.options.system-site-packages\nvirtualenvs.path\nvirtualenvs.prefer-active-python (experimental)\nvirtualenvs.prompt\nrepositories.<name>.url\nhttp-basic.<name>.[username|password]:\npypi-token.<name>:\ncertificates.<name>.cert:\ncertificates.<name>.client-cert:\nkeyring.enabled:\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\nConfiguration\n\nPoetry can be configured via the config command (see more about its usage here) or directly in the config.toml file that will be automatically created when you first run that command. This file can typically be found in one of the following directories:\n\nmacOS: ~/Library/Application Support/pypoetry\nWindows: %APPDATA%\\pypoetry\n\nFor Unix, we follow the XDG spec and support $XDG_CONFIG_HOME. That means, by default ~/.config/pypoetry.\n\nLocal configuration\n\nPoetry also provides the ability to have settings that are specific to a project by passing the --local option to the config command.\n\npoetry config virtualenvs.create false --local\n\nYour local configuration of Poetry application is stored in the poetry.toml file, which is separate from pyproject.toml.\nBe mindful about checking in this file into your repository since it may contain user-specific or sensitive information.\nListing the current configuration\n\nTo list the current configuration you can use the --list option of the config command:\n\npoetry config --list\n\n\nwhich will give you something similar to this:\n\ncache-dir = \"/path/to/cache/directory\"\nvirtualenvs.create = true\nvirtualenvs.in-project = null\nvirtualenvs.options.always-copy = true\nvirtualenvs.options.no-pip = false\nvirtualenvs.options.no-setuptools = false\nvirtualenvs.options.system-site-packages = false\nvirtualenvs.path = \"{cache-dir}/virtualenvs\"  # /path/to/cache/directory/virtualenvs\nvirtualenvs.prefer-active-python = false\nvirtualenvs.prompt = \"{project_name}-py{python_version}\"\n\nDisplaying a single configuration setting\n\nIf you want to see the value of a specific setting, you can give its name to the config command\n\npoetry config virtualenvs.path\n\n\nFor a full list of the supported settings see Available settings.\n\nAdding or updating a configuration setting\n\nTo change or otherwise add a new configuration setting, you can pass a value after the setting’s name:\n\npoetry config virtualenvs.path /path/to/cache/directory/virtualenvs\n\n\nFor a full list of the supported settings see Available settings.\n\nRemoving a specific setting\n\nIf you want to remove a previously set setting, you can use the --unset option:\n\npoetry config virtualenvs.path --unset\n\n\nThe setting will then retrieve its default value.\n\nUsing environment variables\n\nSometimes, in particular when using Poetry with CI tools, it’s easier to use environment variables and not have to execute configuration commands.\n\nPoetry supports this and any setting can be set by using environment variables.\n\nThe environment variables must be prefixed by POETRY_ and are comprised of the uppercase name of the setting and with dots and dashes replaced by underscore, here is an example:\n\nexport POETRY_VIRTUALENVS_PATH=/path/to/virtualenvs/directory\n\n\nThis also works for secret settings, like credentials:\n\nexport POETRY_HTTP_BASIC_MY_REPOSITORY_PASSWORD=secret\n\nDefault Directories\n\nPoetry uses the following default directories:\n\nConfig Directory\nLinux: $XDG_CONFIG_HOME/pypoetry or ~/.config/pypoetry\nWindows: %APPDATA%\\pypoetry\nMacOS: ~/Library/Application Support/pypoetry\n\nYou can override the Config directory by setting the POETRY_CONFIG_DIR environment variable.\n\nData Directory\nLinux: $XDG_DATA_HOME/pypoetry or ~/.local/share/pypoetry\nWindows: %APPDATA%\\pypoetry\nMacOS: ~/Library/Application Support/pypoetry\n\nYou can override the Data directory by setting the POETRY_DATA_DIR or POETRY_HOME environment variables. If POETRY_HOME is set, it will be given higher priority.\n\nCache Directory\nLinux: $XDG_CACHE_HOME/pypoetry or ~/.cache/pypoetry\nWindows: %LOCALAPPDATA%\\pypoetry\nMacOS: ~/Library/Caches/pypoetry\n\nYou can override the Cache directory by setting the POETRY_CACHE_DIR environment variable.\n\nAvailable settings\ncache-dir\n\nType: string\n\nEnvironment Variable: POETRY_CACHE_DIR\n\nThe path to the cache directory used by Poetry.\n\nDefaults to one of the following directories:\n\nmacOS: ~/Library/Caches/pypoetry\nWindows: C:\\Users\\<username>\\AppData\\Local\\pypoetry\\Cache\nUnix: ~/.cache/pypoetry\nexperimental.system-git-client\n\nType: boolean\n\nDefault: false\n\nEnvironment Variable: POETRY_EXPERIMENTAL_SYSTEM_GIT_CLIENT\n\nIntroduced in 1.2.0\n\nUse system git client backend for git related tasks.\n\nPoetry uses dulwich by default for git related tasks to not rely on the availability of a git client.\n\nIf you encounter any problems with it, set to true to use the system git backend.\n\ninstaller.max-workers\n\nType: int\n\nDefault: number_of_cores + 4\n\nEnvironment Variable: POETRY_INSTALLER_MAX_WORKERS\n\nIntroduced in 1.2.0\n\nSet the maximum number of workers while using the parallel installer. The number_of_cores is determined by os.cpu_count(). If this raises a NotImplementedError exception, number_of_cores is assumed to be 1.\n\nIf this configuration parameter is set to a value greater than number_of_cores + 4, the number of maximum workers is still limited at number_of_cores + 4.\n\nThis configuration is ignored when installer.parallel is set to false.\ninstaller.modern-installation\n\nType: boolean\n\nDefault: true\n\nEnvironment Variable: POETRY_INSTALLER_MODERN_INSTALLATION\n\nIntroduced in 1.4.0\n\nUse a more modern and faster method for package installation.\n\nIf this causes issues, you can disable it by setting it to false and report the problems you encounter on the issue tracker.\n\ninstaller.no-binary\n\nType: string | boolean\n\nDefault: false\n\nEnvironment Variable: POETRY_INSTALLER_NO_BINARY\n\nIntroduced in 1.2.0\n\nWhen set this configuration allows users to configure package distribution format policy for all or specific packages.\n\nCONFIGURATION\tDESCRIPTION\n:all: or true\tDisallow binary distributions for all packages.\n:none: or false\tAllow binary distributions for all packages.\npackage[,package,..]\tDisallow binary distributions for specified packages only.\nAs with all configurations described here, this is a user specific configuration. This means that this is not taken into consideration when a lockfile is generated or dependencies are resolved. This is applied only when selecting which distribution for dependency should be installed into a Poetry managed environment.\n\nFor project specific usage, it is recommended that this be configured with the --local.\n\npoetry config --local installer.no-binary :all:\n\n\nFor CI or container environments using environment variable to configure this might be useful.\n\nexport POETRY_INSTALLER_NO_BINARY=:all:\n\nUnless this is required system-wide, if configured globally, you could encounter slower install times across all your projects if incorrectly set.\ninstaller.parallel\n\nType: boolean\n\nDefault: true\n\nEnvironment Variable: POETRY_INSTALLER_PARALLEL\n\nIntroduced in 1.1.4\n\nUse parallel execution when using the new (>=1.1.0) installer.\n\nsolver.lazy-wheel\n\nType: boolean\n\nDefault: true\n\nEnvironment Variable: POETRY_SOLVER_LAZY_WHEEL\n\nIntroduced in 1.8.0\n\nDo not download entire wheels to extract metadata but use HTTP range requests to only download the METADATA files of wheels. Especially with slow network connections this setting can speed up dependency resolution significantly. If the cache has already been filled or the server does not support HTTP range requests, this setting makes no difference.\n\nvirtualenvs.create\n\nType: boolean\n\nDefault: true\n\nEnvironment Variable: POETRY_VIRTUALENVS_CREATE\n\nCreate a new virtual environment if one doesn’t already exist.\n\nIf set to false, Poetry will not create a new virtual environment. If it detects an already enabled virtual environment or an existing one in {cache-dir}/virtualenvs or {project-dir}/.venv it will install dependencies into them, otherwise it will install dependencies into the systems python environment.\n\nIf Poetry detects it’s running within an activated virtual environment, it will never create a new virtual environment, regardless of the value set for virtualenvs.create.\n\nBe aware that installing dependencies into the system environment likely upgrade or uninstall existing packages and thus break other applications. Installing additional Python packages after installing the project might break the Poetry project in return.\n\nThis is why it is recommended to always create a virtual environment. This is also true in Docker containers, as they might contain additional Python packages as well.\n\nvirtualenvs.in-project\n\nType: boolean\n\nDefault: None\n\nEnvironment Variable: POETRY_VIRTUALENVS_IN_PROJECT\n\nCreate the virtualenv inside the project’s root directory.\n\nIf not set explicitly, poetry by default will create a virtual environment under {cache-dir}/virtualenvs or use the {project-dir}/.venv directory if one already exists.\n\nIf set to true, the virtualenv will be created and expected in a folder named .venv within the root directory of the project.\n\nIf a virtual environment has already been created for the project under {cache-dir}/virtualenvs, setting this variable to true will not cause poetry to create or use a local virtual environment.\n\nIn order for this setting to take effect for a project already in that state, you must delete the virtual environment folder located in {cache-dir}/virtualenvs.\n\nYou can find out where the current project’s virtual environment (if there is one) is stored with the command poetry env info --path.\n\nIf set to false, poetry will ignore any existing .venv directory.\n\nvirtualenvs.options.always-copy\n\nType: boolean\n\nDefault: false\n\nEnvironment Variable: POETRY_VIRTUALENVS_OPTIONS_ALWAYS_COPY\n\nIntroduced in 1.2.0\n\nIf set to true the --always-copy parameter is passed to virtualenv on creation of the virtual environment, so that all needed files are copied into it instead of symlinked.\n\nvirtualenvs.options.no-pip\n\nType: boolean\n\nDefault: false\n\nEnvironment Variable: POETRY_VIRTUALENVS_OPTIONS_NO_PIP\n\nIntroduced in 1.2.0\n\nIf set to true the --no-pip parameter is passed to virtualenv on creation of the virtual environment. This means when a new virtual environment is created, pip will not be installed in the environment.\n\nPoetry, for its internal operations, uses the pip wheel embedded in the virtualenv package installed as a dependency in Poetry’s runtime environment. If a user runs poetry run pip when this option is set to true, the pip the embedded instance of pip is used.\n\nYou can safely set this, along with no-setuptools, to true, if you desire a virtual environment with no additional packages. This is desirable for production environments.\n\nvirtualenvs.options.no-setuptools\n\nType: boolean\n\nDefault: false\n\nEnvironment Variable: POETRY_VIRTUALENVS_OPTIONS_NO_SETUPTOOLS\n\nIntroduced in 1.2.0\n\nIf set to true the --no-setuptools parameter is passed to virtualenv on creation of the virtual environment. This means when a new virtual environment is created, setuptools will not be installed in the environment. Poetry, for its internal operations, does not require setuptools and this can safely be set to true.\n\nFor environments using python 3.12 or later, virtualenv defaults to not installing setuptools when creating a virtual environment. In such environments this poetry configuration option therefore has no effect: setuptools is not installed either way. If your project relies on setuptools, you should declare it as a dependency.\n\nSome development tools like IDEs, make an assumption that setuptools (and other) packages are always present and available within a virtual environment. This can cause some features in these tools to not work as expected.\nvirtualenvs.options.system-site-packages\n\nType: boolean\n\nDefault: false\n\nEnvironment Variable: POETRY_VIRTUALENVS_OPTIONS_SYSTEM_SITE_PACKAGES\n\nGive the virtual environment access to the system site-packages directory. Applies on virtualenv creation.\n\nvirtualenvs.path\n\nType: string\n\nDefault: {cache-dir}/virtualenvs\n\nEnvironment Variable: POETRY_VIRTUALENVS_PATH\n\nDirectory where virtual environments will be created.\n\nThis setting controls the global virtual environment storage path. It most likely will not be useful at the local level. To store virtual environments in the project root, see virtualenvs.in-project.\nvirtualenvs.prefer-active-python (experimental)\n\nType: boolean\n\nDefault: false\n\nEnvironment Variable: POETRY_VIRTUALENVS_PREFER_ACTIVE_PYTHON\n\nIntroduced in 1.2.0\n\nUse currently activated Python version to create a new virtual environment. If set to false, Python version used during Poetry installation is used.\n\nvirtualenvs.prompt\n\nType: string\n\nDefault: {project_name}-py{python_version}\n\nEnvironment Variable: POETRY_VIRTUALENVS_PROMPT\n\nIntroduced in 1.2.0\n\nFormat string defining the prompt to be displayed when the virtual environment is activated. The variables project_name and python_version are available for formatting.\n\nrepositories.<name>.url\n\nType: string\n\nEnvironment Variable: POETRY_REPOSITORIES_<NAME>_URL\n\nSet the repository URL for <name>.\n\nSee Publishable Repositories for more information.\n\nhttp-basic.<name>.[username|password]:\n\nType: string\n\nEnvironment Variables: POETRY_HTTP_BASIC_<NAME>_USERNAME, POETRY_HTTP_BASIC_<NAME>_PASSWORD\n\nSet repository credentials (username and password) for <name>. See Repositories - Configuring credentials for more information.\n\npypi-token.<name>:\n\nType: string\n\nEnvironment Variable: POETRY_PYPI_TOKEN_<NAME>\n\nSet repository credentials (using an API token) for <name>. See Repositories - Configuring credentials for more information.\n\ncertificates.<name>.cert:\n\nType: string | boolean\n\nEnvironment Variable: POETRY_CERTIFICATES_<NAME>_CERT\n\nSet custom certificate authority for repository <name>. See Repositories - Configuring credentials - Custom certificate authority for more information.\n\nThis configuration can be set to false, if TLS certificate verification should be skipped for this repository.\n\ncertificates.<name>.client-cert:\n\nType: string\n\nEnvironment Variable: POETRY_CERTIFICATES_<NAME>_CLIENT_CERT\n\nSet client certificate for repository <name>. See Repositories - Configuring credentials - Custom certificate authority for more information.\n\nkeyring.enabled:\n\nType: boolean\n\nDefault: true\n\nEnvironment Variable: POETRY_KEYRING_ENABLED\n\nEnable the system keyring for storing credentials. See Repositories - Configuring credentials for more information.\n\nFooter\n\nPython packaging and dependency management made easy.\n\nGitHub\nDiscord\nDOCUMENTATION\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\n GITHUB\nProject\nIssues\nDiscussions\nOTHER PROJECTS\npoetry-core\ninstall.python-poetry.org\nBundle plugin\nExport plugin\n\nCopyright © 2018-2024. All Rights Reserved.\nPowered by"
  },
  {
    "title": "Commands | Documentation | Poetry - Python dependency management and packaging made easy",
    "url": "https://python-poetry.org/docs/cli/",
    "html": "Home\nSearch\n1.8\nUse dark mode\nDOCUMENTATION\nBLOG\nHISTORY\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nGlobal options\nnew\nOptions\ninit\nOptions\ninstall\nOptions\nupdate\nOptions\nadd\nOptions\nremove\nOptions\nshow\nOptions\nbuild\nOptions\npublish\nOptions\nconfig\nUsage\nOptions\nrun\nshell\ncheck\nOptions\nsearch\nlock\nOptions\nversion\nOptions\nexport\nOptions\nenv\ncache\ncache list\ncache clear\nsource\nsource add\nsource show\nsource remove\nabout\nhelp\nlist\nself\nself add\nself update\nself lock\nself show\nself show plugins\nself remove\nself install\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\nCommands\n\nYou’ve already learned how to use the command-line interface to do some things. This chapter documents all the available commands.\n\nTo get help from the command-line, simply call poetry to see the complete list of commands, then --help combined with any of those can give you more information.\n\nGlobal options\n--verbose (-v|vv|vvv): Increase the verbosity of messages: “-v” for normal output, “-vv” for more verbose output and “-vvv” for debug.\n--help (-h) : Display help information.\n--quiet (-q) : Do not output any message.\n--ansi: Force ANSI output.\n--no-ansi: Disable ANSI output.\n--version (-V): Display this application version.\n--no-interaction (-n): Do not ask any interactive question.\n--no-plugins: Disables plugins.\n--no-cache: Disables Poetry source caches.\n--directory=DIRECTORY (-C): The working directory for the Poetry command (defaults to the current working directory).\nnew\n\nThis command will help you kickstart your new Python project by creating a directory structure suitable for most projects.\n\npoetry new my-package\n\n\nwill create a folder as follows:\n\nmy-package\n├── pyproject.toml\n├── README.md\n├── my_package\n│   └── __init__.py\n└── tests\n    └── __init__.py\n\n\nIf you want to name your project differently than the folder, you can pass the --name option:\n\npoetry new my-folder --name my-package\n\n\nIf you want to use a src folder, you can use the --src option:\n\npoetry new --src my-package\n\n\nThat will create a folder structure as follows:\n\nmy-package\n├── pyproject.toml\n├── README.md\n├── src\n│   └── my_package\n│       └── __init__.py\n└── tests\n    └── __init__.py\n\n\nThe --name option is smart enough to detect namespace packages and create the required structure for you.\n\npoetry new --src --name my.package my-package\n\n\nwill create the following structure:\n\nmy-package\n├── pyproject.toml\n├── README.md\n├── src\n│   └── my\n│       └── package\n│           └── __init__.py\n└── tests\n    └── __init__.py\n\nOptions\n--name: Set the resulting package name.\n--src: Use the src layout for the project.\n--readme: Specify the readme file extension. Default is md. If you intend to publish to PyPI keep the recommendations for a PyPI-friendly README in mind.\ninit\n\nThis command will help you create a pyproject.toml file interactively by prompting you to provide basic information about your package.\n\nIt will interactively ask you to fill in the fields, while using some smart defaults.\n\npoetry init\n\nOptions\n--name: Name of the package.\n--description: Description of the package.\n--author: Author of the package.\n--python Compatible Python versions.\n--dependency: Package to require with a version constraint. Should be in format foo:1.0.0.\n--dev-dependency: Development requirements, see --dependency.\ninstall\n\nThe install command reads the pyproject.toml file from the current project, resolves the dependencies, and installs them.\n\npoetry install\n\n\nIf there is a poetry.lock file in the current directory, it will use the exact versions from there instead of resolving them. This ensures that everyone using the library will get the same versions of the dependencies.\n\nIf there is no poetry.lock file, Poetry will create one after dependency resolution.\n\nIf you want to exclude one or more dependency groups for the installation, you can use the --without option.\n\npoetry install --without test,docs\n\nThe --no-dev option is now deprecated. You should use the --only main or --without dev notation instead.\n\nYou can also select optional dependency groups with the --with option.\n\npoetry install --with test,docs\n\n\nIt’s also possible to only install specific dependency groups by using the only option.\n\npoetry install --only test,docs\n\n\nTo only install the project itself with no dependencies, use the --only-root flag.\n\npoetry install --only-root\n\n\nSee Dependency groups for more information about dependency groups.\n\nIf you want to synchronize your environment – and ensure it matches the lock file – use the --sync option.\n\npoetry install --sync\n\n\nThe --sync can be combined with group-related options:\n\npoetry install --without dev --sync\npoetry install --with docs --sync\npoetry install --only dev --sync\n\n\nYou can also specify the extras you want installed by passing the -E|--extras option (See Extras for more info). Pass --all-extras to install all defined extras for a project.\n\npoetry install --extras \"mysql pgsql\"\npoetry install -E mysql -E pgsql\npoetry install --all-extras\n\n\nExtras are not sensitive to --sync. Any extras not specified will always be removed.\n\npoetry install --extras \"A B\"  # C is removed\n\n\nBy default poetry will install your project’s package every time you run install:\n\n$ poetry install\nInstalling dependencies from lock file\n\nNo dependencies to install or update\n\n  - Installing <your-package-name> (x.x.x)\n\n\nIf you want to skip this installation, use the --no-root option.\n\npoetry install --no-root\n\n\nSimilar to --no-root you can use --no-directory to skip directory path dependencies:\n\npoetry install --no-directory\n\n\nThis is mainly useful for caching in CI or when building Docker images. See the FAQ entry for more information on this option.\n\nBy default poetry does not compile Python source files to bytecode during installation. This speeds up the installation process, but the first execution may take a little more time because Python then compiles source files to bytecode automatically. If you want to compile source files to bytecode during installation, you can use the --compile option:\n\npoetry install --compile\n\nThe --compile option has no effect if installer.modern-installation is set to false because the old installer always compiles source files to bytecode.\nOptions\n--without: The dependency groups to ignore.\n--with: The optional dependency groups to include.\n--only: The only dependency groups to include.\n--only-root: Install only the root project, exclude all dependencies.\n--sync: Synchronize the environment with the locked packages and the specified groups.\n--no-root: Do not install the root package (your project).\n--no-directory: Skip all directory path dependencies (including transitive ones).\n--dry-run: Output the operations but do not execute anything (implicitly enables –verbose).\n--extras (-E): Features to install (multiple values allowed).\n--all-extras: Install all extra features (conflicts with –extras).\n--compile: Compile Python source files to bytecode.\n--no-dev: Do not install dev dependencies. (Deprecated, use --only main or --without dev instead)\n--remove-untracked: Remove dependencies not presented in the lock file. (Deprecated, use --sync instead)\nWhen --only is specified, --with and --without options are ignored.\nupdate\n\nIn order to get the latest versions of the dependencies and to update the poetry.lock file, you should use the update command.\n\npoetry update\n\n\nThis will resolve all dependencies of the project and write the exact versions into poetry.lock.\n\nIf you just want to update a few packages and not all, you can list them as such:\n\npoetry update requests toml\n\n\nNote that this will not update versions for dependencies outside their version constraints specified in the pyproject.toml file. In other terms, poetry update foo will be a no-op if the version constraint specified for foo is ~2.3 or 2.3 and 2.4 is available. In order for foo to be updated, you must update the constraint, for example ^2.3. You can do this using the add command.\n\nOptions\n--without: The dependency groups to ignore.\n--with: The optional dependency groups to include.\n--only: The only dependency groups to include.\n--dry-run : Outputs the operations but will not execute anything (implicitly enables –verbose).\n--no-dev : Do not update the development dependencies. (Deprecated, use --only main or --without dev instead)\n--lock : Do not perform install (only update the lockfile).\n--sync: Synchronize the environment with the locked packages and the specified groups.\nWhen --only is specified, --with and --without options are ignored.\nadd\n\nThe add command adds required packages to your pyproject.toml and installs them.\n\nIf you do not specify a version constraint, poetry will choose a suitable one based on the available package versions.\n\npoetry add requests pendulum\n\n\nA package is looked up, by default, only from the Default Package Source. You can modify the default source (PyPI); or add and use Supplemental Package Sources or Explicit Package Sources.\n\nFor more information, refer to the Package Sources documentation.\n\nYou can also specify a constraint when adding a package:\n\n# Allow >=2.0.5, <3.0.0 versions\npoetry add pendulum@^2.0.5\n\n# Allow >=2.0.5, <2.1.0 versions\npoetry add pendulum@~2.0.5\n\n# Allow >=2.0.5 versions, without upper bound\npoetry add \"pendulum>=2.0.5\"\n\n# Allow only 2.0.5 version\npoetry add pendulum==2.0.5\n\nSee the Dependency specification page for more information about the @ operator.\n\nIf you try to add a package that is already present, you will get an error. However, if you specify a constraint, like above, the dependency will be updated by using the specified constraint.\n\nIf you want to get the latest version of an already present dependency, you can use the special latest constraint:\n\npoetry add pendulum@latest\n\nSee the Dependency specification for more information on setting the version constraints for a package.\n\nYou can also add git dependencies:\n\npoetry add git+https://github.com/sdispater/pendulum.git\n\n\nor use ssh instead of https:\n\npoetry add git+ssh://git@github.com/sdispater/pendulum.git\n\n# or alternatively:\npoetry add git+ssh://git@github.com:sdispater/pendulum.git\n\n\nIf you need to checkout a specific branch, tag or revision, you can specify it when using add:\n\npoetry add git+https://github.com/sdispater/pendulum.git#develop\npoetry add git+https://github.com/sdispater/pendulum.git#2.0.5\n\n# or using SSH instead:\npoetry add git+ssh://git@github.com:sdispater/pendulum.git#develop\npoetry add git+ssh://git@github.com:sdispater/pendulum.git#2.0.5\n\n\nor reference a subdirectory:\n\npoetry add git+https://github.com/myorg/mypackage_with_subdirs.git@main#subdirectory=subdir\n\n\nYou can also add a local directory or file:\n\npoetry add ./my-package/\npoetry add ../my-package/dist/my-package-0.1.0.tar.gz\npoetry add ../my-package/dist/my_package-0.1.0.whl\n\n\nIf you want the dependency to be installed in editable mode you can use the --editable option.\n\npoetry add --editable ./my-package/\npoetry add --editable git+ssh://github.com/sdispater/pendulum.git#develop\n\n\nAlternatively, you can specify it in the pyproject.toml file. It means that changes in the local directory will be reflected directly in environment.\n\n[tool.poetry.dependencies]\nmy-package = {path = \"../my/path\", develop = true}\n\nBefore poetry 1.1 path dependencies were installed in editable mode by default. You should always set the develop attribute explicitly, to make sure the behavior is the same for all poetry versions.\nThe develop attribute is a Poetry-specific feature, so it is not included in the package distribution metadata. In other words, it is only considered when using Poetry to install the project.\n\nIf the package(s) you want to install provide extras, you can specify them when adding the package:\n\npoetry add \"requests[security,socks]\"\npoetry add \"requests[security,socks]~=2.22.0\"\npoetry add \"git+https://github.com/pallets/flask.git@1.1.1[dotenv,dev]\"\n\nSome shells may treat square braces ([ and ]) as special characters. It is suggested to always quote arguments containing these characters to prevent unexpected shell expansion.\n\nIf you want to add a package to a specific group of dependencies, you can use the --group (-G) option:\n\npoetry add mkdocs --group docs\n\n\nSee Dependency groups for more information about dependency groups.\n\nOptions\n--group (-G): The group to add the dependency to.\n--dev (-D): Add package as development dependency. (Deprecated, use -G dev instead)\n--editable (-e): Add vcs/path dependencies as editable.\n--extras (-E): Extras to activate for the dependency. (multiple values allowed)\n--optional: Add as an optional dependency.\n--python: Python version for which the dependency must be installed.\n--platform: Platforms for which the dependency must be installed.\n--source: Name of the source to use to install the package.\n--allow-prereleases: Accept prereleases.\n--dry-run: Output the operations but do not execute anything (implicitly enables –verbose).\n--lock: Do not perform install (only update the lockfile).\nremove\n\nThe remove command removes a package from the current list of installed packages.\n\npoetry remove pendulum\n\n\nIf you want to remove a package from a specific group of dependencies, you can use the --group (-G) option:\n\npoetry remove mkdocs --group docs\n\n\nSee Dependency groups for more information about dependency groups.\n\nOptions\n--group (-G): The group to remove the dependency from.\n--dev (-D): Removes a package from the development dependencies. (Deprecated, use -G dev instead)\n--dry-run : Outputs the operations but will not execute anything (implicitly enables –verbose).\n--lock: Do not perform operations (only update the lockfile).\nshow\n\nTo list all the available packages, you can use the show command.\n\npoetry show\n\n\nIf you want to see the details of a certain package, you can pass the package name.\n\npoetry show pendulum\n\nname        : pendulum\nversion     : 1.4.2\ndescription : Python datetimes made easy\n\ndependencies\n - python-dateutil >=2.6.1\n - tzlocal >=1.4\n - pytzdata >=2017.2.2\n\nrequired by\n - calendar >=1.4.0\n\nOptions\n--without: The dependency groups to ignore.\n--why: When showing the full list, or a --tree for a single package, display whether they are a direct dependency or required by other packages.\n--with: The optional dependency groups to include.\n--only: The only dependency groups to include.\n--no-dev: Do not list the dev dependencies. (Deprecated, use --only main or --without dev instead)\n--tree: List the dependencies as a tree.\n--latest (-l): Show the latest version.\n--outdated (-o): Show the latest version but only for packages that are outdated.\n--all (-a): Show all packages (even those not compatible with current system).\n--top-level (-T): Only show explicitly defined packages.\nWhen --only is specified, --with and --without options are ignored.\nbuild\n\nThe build command builds the source and wheels archives.\n\npoetry build\n\n\nNote that, at the moment, only pure python wheels are supported.\n\nOptions\n--format (-f): Limit the format to either wheel or sdist.\n--output (-o): Set output directory for build artifacts. Default is dist.\npublish\n\nThis command publishes the package, previously built with the build command, to the remote repository.\n\nIt will automatically register the package before uploading if this is the first time it is submitted.\n\npoetry publish\n\n\nIt can also build the package if you pass it the --build option.\n\nSee Publishable Repositories for more information on how to configure and use publishable repositories.\nOptions\n--repository (-r): The repository to register the package to (default: pypi). Should match a repository name set by the config command.\n--username (-u): The username to access the repository.\n--password (-p): The password to access the repository.\n--cert: Certificate authority to access the repository.\n--client-cert: Client certificate to access the repository.\n--dist-dir: Dist directory where built artifact are stored. Default is dist.\n--build: Build the package before publishing.\n--dry-run: Perform all actions except upload the package.\n--skip-existing: Ignore errors from files already existing in the repository.\nSee Configuring Credentials for more information on how to configure credentials.\nconfig\n\nThe config command allows you to edit poetry config settings and repositories.\n\npoetry config --list\n\nUsage\npoetry config [options] [setting-key] [setting-value1] ... [setting-valueN]\n\n\nsetting-key is a configuration option name and setting-value1 is a configuration value. See Configuration for all available settings.\n\nUse -- to terminate option parsing if your values may start with a hyphen (-), e.g.\n\npoetry config http-basic.custom-repo gitlab-ci-token -- ${GITLAB_JOB_TOKEN}\n\n\nWithout -- this command will fail if ${GITLAB_JOB_TOKEN} starts with a hyphen.\n\nOptions\n--unset: Remove the configuration element named by setting-key.\n--list: Show the list of current config variables.\n--local: Set/Get settings that are specific to a project (in the local configuration file poetry.toml).\nrun\n\nThe run command executes the given command inside the project’s virtualenv.\n\npoetry run python -V\n\n\nIt can also execute one of the scripts defined in pyproject.toml.\n\nSo, if you have a script defined like this:\n\n[tool.poetry.scripts]\nmy-script = \"my_module:main\"\n\n\nYou can execute it like so:\n\npoetry run my-script\n\n\nNote that this command has no option.\n\nshell\n\nThe shell command spawns a shell within the project’s virtual environment.\n\nBy default, the current active shell is detected and used. Failing that, the shell defined via the environment variable SHELL (on *nix) or COMSPEC (on Windows) is used.\n\nIf a virtual environment does not exist, it will be created.\n\npoetry shell\n\n\nNote that this command starts a new shell and activates the virtual environment.\n\nAs such, exit should be used to properly exit the shell and the virtual environment instead of deactivate.\n\nPoetry internally uses the Shellingham project to detect current active shell.\ncheck\n\nThe check command validates the content of the pyproject.toml file and its consistency with the poetry.lock file. It returns a detailed report if there are any errors.\n\nThis command is also available as a pre-commit hook. See pre-commit hooks for more information.\npoetry check\n\nOptions\n--lock: Verifies that poetry.lock exists for the current pyproject.toml.\nsearch\n\nThis command searches for packages on a remote index.\n\npoetry search requests pendulum\n\nlock\n\nThis command locks (without installing) the dependencies specified in pyproject.toml.\n\nBy default, this will lock all dependencies to the latest available compatible versions. To only refresh the lock file, use the --no-update option. This command is also available as a pre-commit hook. See pre-commit hooks for more information.\npoetry lock\n\nOptions\n--check: Verify that poetry.lock is consistent with pyproject.toml. (Deprecated) Use poetry check --lock instead.\n--no-update: Do not update locked versions, only refresh lock file.\nversion\n\nThis command shows the current version of the project or bumps the version of the project and writes the new version back to pyproject.toml if a valid bump rule is provided.\n\nThe new version should be a valid PEP 440 string or a valid bump rule: patch, minor, major, prepatch, preminor, premajor, prerelease.\n\nIf you would like to use semantic versioning for your project, please see here.\n\nThe table below illustrates the effect of these rules with concrete examples.\n\nRULE\tBEFORE\tAFTER\nmajor\t1.3.0\t2.0.0\nminor\t2.1.4\t2.2.0\npatch\t4.1.1\t4.1.2\npremajor\t1.0.2\t2.0.0a0\npreminor\t1.0.2\t1.1.0a0\nprepatch\t1.0.2\t1.0.3a0\nprerelease\t1.0.2\t1.0.3a0\nprerelease\t1.0.3a0\t1.0.3a1\nprerelease\t1.0.3b0\t1.0.3b1\n\nThe option --next-phase allows the increment of prerelease phase versions.\n\nRULE\tBEFORE\tAFTER\nprerelease –next-phase\t1.0.3a0\t1.0.3b0\nprerelease –next-phase\t1.0.3b0\t1.0.3rc0\nprerelease –next-phase\t1.0.3rc0\t1.0.3\nOptions\n--next-phase: Increment the phase of the current version.\n--short (-s): Output the version number only.\n--dry-run: Do not update pyproject.toml file.\nexport\n\nThis command exports the lock file to other formats.\n\npoetry export -f requirements.txt --output requirements.txt\n\nThis command is provided by the Export Poetry Plugin. In a future version of Poetry this plugin will not be installed by default anymore. In order to avoid a breaking change and make your automation forward-compatible, please install poetry-plugin-export explicitly. See Using plugins for details on how to install a plugin.\nThis command is also available as a pre-commit hook. See pre-commit hooks for more information.\nUnlike the install command, this command only includes the project’s dependencies defined in the implicit main group defined in tool.poetry.dependencies when used without specifying any options.\nOptions\n--format (-f): The format to export to (default: requirements.txt). Currently, only constraints.txt and requirements.txt are supported.\n--output (-o): The name of the output file. If omitted, print to standard output.\n--dev: Include development dependencies. (Deprecated, use --with dev instead)\n--extras (-E): Extra sets of dependencies to include.\n--without: The dependency groups to ignore.\n--with: The optional dependency groups to include.\n--only: The only dependency groups to include.\n--without-hashes: Exclude hashes from the exported file.\n--without-urls: Exclude source repository urls from the exported file.\n--with-credentials: Include credentials for extra indices.\nenv\n\nThe env command regroups sub commands to interact with the virtualenvs associated with a specific project.\n\nSee Managing environments for more information about these commands.\n\ncache\n\nThe cache command regroups sub commands to interact with Poetry’s cache.\n\ncache list\n\nThe cache list command lists Poetry’s available caches.\n\npoetry cache list\n\ncache clear\n\nThe cache clear command removes packages from a cached repository.\n\nFor example, to clear the whole cache of packages from the pypi repository, run:\n\npoetry cache clear pypi --all\n\n\nTo only remove a specific package from a cache, you have to specify the cache entry in the following form cache:package:version:\n\npoetry cache clear pypi:requests:2.24.0\n\nsource\n\nThe source namespace regroups sub commands to manage repository sources for a Poetry project.\n\nsource add\n\nThe source add command adds source configuration to the project.\n\nFor example, to add the pypi-test source, you can run:\n\npoetry source add pypi-test https://test.pypi.org/simple/\n\n\nYou cannot use the name pypi for a custom repository as it is reserved for use by the default PyPI source. However, you can set the priority of PyPI:\n\npoetry source add --priority=explicit pypi\n\nOptions\n--default: Set this source as the default (disable PyPI). Deprecated in favor of --priority.\n--secondary: Set this source as a secondary source. Deprecated in favor of --priority.\n--priority: Set the priority of this source. Accepted values are: default, secondary, supplemental, and explicit. Refer to the dedicated sections in Repositories for more information.\nAt most one of the options above can be provided. See package sources for more information.\nsource show\n\nThe source show command displays information on all configured sources for the project.\n\npoetry source show\n\n\nOptionally, you can show information of one or more sources by specifying their names.\n\npoetry source show pypi-test\n\nThis command will only show sources configured via the pyproject.toml and does not include the implicit default PyPI.\nsource remove\n\nThe source remove command removes a configured source from your pyproject.toml.\n\npoetry source remove pypi-test\n\nabout\n\nThe about command displays global information about Poetry, including the current version and version of poetry-core.\n\npoetry about\n\nhelp\n\nThe help command displays global help, or help for a specific command.\n\nTo display global help:\n\npoetry help\n\n\nTo display help for a specific command, for instance show:\n\npoetry help show\n\n\nThe --help option can also be passed to any command to get help for a specific command.\n\nFor instance:\n\npoetry show --help\n\nlist\n\nThe list command displays all the available Poetry commands.\n\npoetry list\n\nself\n\nThe self namespace regroups sub commands to manage the Poetry installation itself.\n\nUse of these commands will create the required pyproject.toml and poetry.lock files in your configuration directory.\nEspecially on Windows, self commands that update or remove packages may be problematic so that other methods for installing plugins and updating Poetry are recommended. See Using plugins and Installing Poetry for more information.\nself add\n\nThe self add command installs Poetry plugins and make them available at runtime. Additionally, it can also be used to upgrade Poetry’s own dependencies or inject additional packages into the runtime environment\n\nThe self add command works exactly like the add command. However, is different in that the packages managed are for Poetry’s runtime environment.\n\nThe package specification formats supported by the self add command are the same as the ones supported by the add command.\n\nFor example, to install the poetry-plugin-export plugin, you can run:\n\npoetry self add poetry-plugin-export\n\n\nTo update to the latest poetry-core version, you can run:\n\npoetry self add poetry-core@latest\n\n\nTo add a keyring provider artifacts-keyring, you can run:\n\npoetry self add artifacts-keyring\n\nOptions\n--editable (-e): Add vcs/path dependencies as editable.\n--extras (-E): Extras to activate for the dependency. (multiple values allowed)\n--allow-prereleases: Accept prereleases.\n--source: Name of the source to use to install the package.\n--dry-run: Output the operations but do not execute anything (implicitly enables –verbose).\nself update\n\nThe self update command updates Poetry version in its current runtime environment.\n\nThe self update command works exactly like the update command. However, is different in that the packages managed are for Poetry’s runtime environment.\npoetry self update\n\nOptions\n--preview: Allow the installation of pre-release versions.\n--dry-run: Output the operations but do not execute anything (implicitly enables –verbose).\nself lock\n\nThe self lock command reads this Poetry installation’s system pyproject.toml file. The system dependencies are locked in the corresponding poetry.lock file.\n\npoetry self lock\n\nOptions\n--check: Verify that poetry.lock is consistent with pyproject.toml. (Deprecated)\n--no-update: Do not update locked versions, only refresh lock file.\nself show\n\nThe self show command behaves similar to the show command, but working within Poetry’s runtime environment. This lists all packages installed within the Poetry install environment.\n\nTo show only additional packages that have been added via self add and their dependencies use self show --addons.\n\npoetry self show\n\nOptions\n--addons: List only add-on packages installed.\n--tree: List the dependencies as a tree.\n--latest (-l): Show the latest version.\n--outdated (-o): Show the latest version but only for packages that are outdated.\nself show plugins\n\nThe self show plugins command lists all the currently installed plugins.\n\npoetry self show plugins\n\nself remove\n\nThe self remove command removes an installed addon package.\n\npoetry self remove poetry-plugin-export\n\nOptions\n--dry-run: Outputs the operations but will not execute anything (implicitly enables –verbose).\nself install\n\nThe self install command ensures all additional packages specified are installed in the current runtime environment.\n\nThe self install command works similar to the install command. However, is different in that the packages managed are for Poetry’s runtime environment.\npoetry self install --sync\n\nOptions\n--sync: Synchronize the environment with the locked packages and the specified groups.\n--dry-run: Output the operations but do not execute anything (implicitly enables –verbose).\nFooter\n\nPython packaging and dependency management made easy.\n\nGitHub\nDiscord\nDOCUMENTATION\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\n GITHUB\nProject\nIssues\nDiscussions\nOTHER PROJECTS\npoetry-core\ninstall.python-poetry.org\nBundle plugin\nExport plugin\n\nCopyright © 2018-2024. All Rights Reserved.\nPowered by"
  },
  {
    "title": "Libraries | Documentation | Poetry - Python dependency management and packaging made easy",
    "url": "https://python-poetry.org/docs/libraries/",
    "html": "Home\nSearch\n1.8\nUse dark mode\nDOCUMENTATION\nBLOG\nHISTORY\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nVersioning\nLock file\nPackaging\nPublishing to PyPI\nPublishing to a private repository\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\nLibraries\n\nThis chapter will tell you how to make your library installable through Poetry.\n\nVersioning\n\nPoetry requires PEP 440-compliant versions for all projects.\n\nWhile Poetry does not enforce any release convention, it used to encourage the use of semantic versioning within the scope of PEP 440 and supports version constraints that are especially suitable for semver.\n\nAs an example, 1.0.0-hotfix.1 is not compatible with PEP 440. You can instead choose to use 1.0.0-post1 or 1.0.0.post1.\nLock file\n\nFor your library, you may commit the poetry.lock file if you want to. This can help your team to always test against the same dependency versions. However, this lock file will not have any effect on other projects that depend on it. It only has an effect on the main project.\n\nIf you do not want to commit the lock file and you are using git, add it to the .gitignore.\n\nPackaging\n\nBefore you can actually publish your library, you will need to package it.\n\npoetry build\n\n\nThis command will package your library in two different formats: sdist which is the source format, and wheel which is a compiled package.\n\nPoetry will automatically include some metadata files when building a package. When building a wheel, the following files are included in the .dist-info directory:\n\nLICENSE\nLICENSE.*\nCOPYING\nCOPYING.*\nLICENSES/**\n\nWhen building an sdist, the following files will be included in the root folder:\n\nLICENSE*\n\nOnce building is done you are ready to publish your library.\n\nPublishing to PyPI\n\nAlright, so now you can publish packages.\n\nPoetry will publish to PyPI by default. Anything that is published to PyPI is available automatically through Poetry. Since pendulum is on PyPI we can depend on it without having to specify any additional repositories.\n\nIf we wanted to share poetry-demo with the Python community, we would publish on PyPI as well. Doing so is really easy.\n\npoetry publish\n\n\nThis will package and publish the library to PyPI, at the condition that you are a registered user and you have configured your credentials properly.\n\nThe publish command does not execute build by default.\n\nIf you want to build and publish your packages together, just pass the --build option.\n\nOnce this is done, your library will be available to anyone.\n\nPublishing to a private repository\n\nSometimes, you may want to keep your library private but also being accessible to your team.\n\nIn this case, you will need to use a private repository.\n\nIn order to publish to a private repository, you will need to add it to your global list of repositories. See Adding a repository for more information.\n\nOnce this is done, you can actually publish to it like so:\n\npoetry publish -r my-repository\n\nFooter\n\nPython packaging and dependency management made easy.\n\nGitHub\nDiscord\nDOCUMENTATION\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\n GITHUB\nProject\nIssues\nDiscussions\nOTHER PROJECTS\npoetry-core\ninstall.python-poetry.org\nBundle plugin\nExport plugin\n\nCopyright © 2018-2024. All Rights Reserved.\nPowered by"
  },
  {
    "title": "Managing dependencies | Documentation | Poetry - Python dependency management and packaging made easy",
    "url": "https://python-poetry.org/docs/managing-dependencies/",
    "html": "Home\nSearch\n1.8\nUse dark mode\nDOCUMENTATION\nBLOG\nHISTORY\nIntroduction\nBasic usage\nManaging dependencies\nDependency groups\nOptional groups\nAdding a dependency to a group\nInstalling group dependencies\nRemoving dependencies from a group\nSynchronizing dependencies\nLayering optional groups\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\nManaging dependencies\nDependency groups\n\nPoetry provides a way to organize your dependencies by groups. For instance, you might have dependencies that are only needed to test your project or to build the documentation.\n\nTo declare a new dependency group, use a tool.poetry.group.<group> section where <group> is the name of your dependency group (for instance, test):\n\n[tool.poetry.group.test]  # This part can be left out\n\n[tool.poetry.group.test.dependencies]\npytest = \"^6.0.0\"\npytest-mock = \"*\"\n\n\nAll dependencies must be compatible with each other across groups since they will be resolved regardless of whether they are required for installation or not (see Installing group dependencies).\n\nThink of dependency groups as labels associated with your dependencies: they don’t have any bearings on whether their dependencies will be resolved and installed by default, they are simply a way to organize the dependencies logically.\n\nThe dependencies declared in tool.poetry.dependencies are part of an implicit main group.\n\n[tool.poetry.dependencies]  # main dependency group\nhttpx = \"*\"\npendulum = \"*\"\n\n\n[tool.poetry.group.test.dependencies]\npytest = \"^6.0.0\"\npytest-mock = \"*\"\n\n\nDependency groups, other than the implicit main group, must only contain dependencies you need in your development process. Installing them is only possible by using Poetry.\n\nTo declare a set of dependencies, which add additional functionality to the project during runtime, use extras instead. Extras can be installed by the end user using pip.\n\nA note about defining a dev dependencies group\n\nThe proper way to define a dev dependencies group since Poetry 1.2.0 is the following:\n\n[tool.poetry.group.dev.dependencies]\npytest = \"^6.0.0\"\npytest-mock = \"*\"\n\n\nThis group notation is preferred since Poetry 1.2.0 and not usable in earlier versions. For backwards compatibility with older versions of Poetry, any dependency declared in the dev-dependencies section will automatically be added to the dev group. So the above and following notations are equivalent:\n\n# Poetry pre-1.2.x style, understood by Poetry 1.0–1.2\n[tool.poetry.dev-dependencies]\npytest = \"^6.0.0\"\npytest-mock = \"*\"\n\n\nPoetry will slowly transition away from the dev-dependencies notation which will soon be deprecated, so it’s advised to migrate your existing development dependencies to the new group notation.\n\nOptional groups\n\nA dependency group can be declared as optional. This makes sense when you have a group of dependencies that are only required in a particular environment or for a specific purpose.\n\n[tool.poetry.group.docs]\noptional = true\n\n[tool.poetry.group.docs.dependencies]\nmkdocs = \"*\"\n\n\nOptional groups can be installed in addition to the default dependencies by using the --with option of the install command.\n\npoetry install --with docs\n\nOptional group dependencies will still be resolved alongside other dependencies, so special care should be taken to ensure they are compatible with each other.\nAdding a dependency to a group\n\nThe add command is the preferred way to add dependencies to a group. This is done by using the --group (-G) option.\n\npoetry add pytest --group test\n\n\nIf the group does not already exist, it will be created automatically.\n\nInstalling group dependencies\n\nBy default, dependencies across all non-optional groups will be installed when executing poetry install.\n\nThe default set of dependencies for a project includes the implicit main group defined in tool.poetry.dependencies as well as all groups that are not explicitly marked as an optional group.\n\nYou can exclude one or more groups with the --without option:\n\npoetry install --without test,docs\n\n\nYou can also opt in optional groups by using the --with option:\n\npoetry install --with docs\n\n\nWhen used together, --without takes precedence over --with. For example, the following command will only install the dependencies specified in the optional test group.\n\npoetry install --with test,docs --without docs\n\n\nFinally, in some case you might want to install only specific groups of dependencies without installing the default set of dependencies. For that purpose, you can use the --only option.\n\npoetry install --only docs\n\n\nIf you only want to install the project’s runtime dependencies, you can do so with the --only main notation:\n\npoetry install --only main\n\n\nIf you want to install the project root, and no other dependencies, you can use the --only-root option.\n\npoetry install --only-root\n\nRemoving dependencies from a group\n\nThe remove command supports a --group option to remove packages from a specific group:\n\npoetry remove mkdocs --group docs\n\nSynchronizing dependencies\n\nPoetry supports what’s called dependency synchronization. Dependency synchronization ensures that the locked dependencies in the poetry.lock file are the only ones present in the environment, removing anything that’s not necessary.\n\nThis is done by using the --sync option of the install command:\n\npoetry install --sync\n\n\nThe --sync option can be combined with any dependency groups related options to synchronize the environment with specific groups. Note that extras are separate. Any extras not selected for install are always removed, regardless of --sync.\n\npoetry install --without dev --sync\npoetry install --with docs --sync\npoetry install --only dev\n\nThe --sync option replaces the --remove-untracked option which is now deprecated.\nLayering optional groups\n\nWhen you omit the --sync option, you can install any subset of optional groups without removing those that are already installed. This is very useful, for example, in multi-stage Docker builds, where you run poetry install multiple times in different build stages.\n\nFooter\n\nPython packaging and dependency management made easy.\n\nGitHub\nDiscord\nDOCUMENTATION\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\n GITHUB\nProject\nIssues\nDiscussions\nOTHER PROJECTS\npoetry-core\ninstall.python-poetry.org\nBundle plugin\nExport plugin\n\nCopyright © 2018-2024. All Rights Reserved.\nPowered by"
  },
  {
    "title": "Basic usage | Documentation | Poetry - Python dependency management and packaging made easy",
    "url": "https://python-poetry.org/docs/basic-usage/",
    "html": "Home\nSearch\n1.8\nUse dark mode\nDOCUMENTATION\nBLOG\nHISTORY\nIntroduction\nBasic usage\nProject setup\nSetting a Python Version\nInitialising a pre-existing project\nOperating modes\nSpecifying dependencies\nUsing your virtual environment\nUsing poetry run\nActivating the virtual environment\nVersion constraints\nInstalling dependencies\nInstalling without poetry.lock\nInstalling with poetry.lock\nCommitting your poetry.lock file to version control\nInstalling dependencies only\nUpdating dependencies to their latest versions\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\nBasic usage\n\nFor the basic usage introduction we will be installing pendulum, a datetime library. If you have not yet installed Poetry, refer to the Introduction chapter.\n\nProject setup\n\nFirst, let’s create our new project, let’s call it poetry-demo:\n\npoetry new poetry-demo\n\n\nThis will create the poetry-demo directory with the following content:\n\npoetry-demo\n├── pyproject.toml\n├── README.md\n├── poetry_demo\n│   └── __init__.py\n└── tests\n    └── __init__.py\n\n\nThe pyproject.toml file is what is the most important here. This will orchestrate your project and its dependencies. For now, it looks like this:\n\n[tool.poetry]\nname = \"poetry-demo\"\nversion = \"0.1.0\"\ndescription = \"\"\nauthors = [\"Sébastien Eustace <sebastien@eustace.io>\"]\nreadme = \"README.md\"\npackages = [{include = \"poetry_demo\"}]\n\n[tool.poetry.dependencies]\npython = \"^3.7\"\n\n\n[build-system]\nrequires = [\"poetry-core\"]\nbuild-backend = \"poetry.core.masonry.api\"\n\n\nPoetry assumes your package contains a package with the same name as tool.poetry.name located in the root of your project. If this is not the case, populate tool.poetry.packages to specify your packages and their locations.\n\nSimilarly, the traditional MANIFEST.in file is replaced by the tool.poetry.readme, tool.poetry.include, and tool.poetry.exclude sections. tool.poetry.exclude is additionally implicitly populated by your .gitignore. For full documentation on the project format, see the pyproject section of the documentation.\n\nSetting a Python Version\nUnlike with other packages, Poetry will not automatically install a python interpreter for you. If you want to run Python files in your package like a script or application, you must bring your own python interpreter to run them.\n\nPoetry will require you to explicitly specify what versions of Python you intend to support, and its universal locking will guarantee that your project is installable (and all dependencies claim support for) all supported Python versions. Again, it’s important to remember that – unlike other dependencies – setting a Python version is merely specifying which versions of Python you intend to support.\n\nFor example, in this pyproject.toml file:\n\n[tool.poetry.dependencies]\npython = \"^3.7.0\"\n\n\nwe are allowing any version of Python 3 that is greater than 3.7.0.\n\nWhen you run poetry install, you must have access to some version of a Python inrepreter that satisfies this constraint available on your system. Poetry will not install a Python interpreter for you. If you use a tool like pyenv, you can use the experimental configuration value virtualenvs.prefer-active-python.\n\nInitialising a pre-existing project\n\nInstead of creating a new project, Poetry can be used to ‘initialise’ a pre-populated directory. To interactively create a pyproject.toml file in directory pre-existing-project:\n\ncd pre-existing-project\npoetry init\n\nOperating modes\n\nPoetry can be operated in two different modes. The default mode is the package mode, which is the right mode if you want to package your project into an sdist or a wheel and perhaps publish it to a package index. In this mode, some metadata such as name and version, which are required for packaging, are mandatory. Further, the project itself will be installed in editable mode when running poetry install.\n\nIf you want to use Poetry only for dependency management but not for packaging, you can use the non-package mode:\n\n[tool.poetry]\npackage-mode = false\n\n\nIn this mode, metadata such as name and version are optional. Therefore, it is not possible to build a distribution or publish the project to a package index. Further, when running poetry install, Poetry does not try to install the project itself, but only its dependencies (same as poetry install --no-root).\n\nIn the pyproject section you can see which fields are required in package mode.\nSpecifying dependencies\n\nIf you want to add dependencies to your project, you can specify them in the tool.poetry.dependencies section.\n\n[tool.poetry.dependencies]\npendulum = \"^2.1\"\n\n\nAs you can see, it takes a mapping of package names and version constraints.\n\nPoetry uses this information to search for the right set of files in package “repositories” that you register in the tool.poetry.source section, or on PyPI by default.\n\nAlso, instead of modifying the pyproject.toml file by hand, you can use the add command.\n\n$ poetry add pendulum\n\n\nIt will automatically find a suitable version constraint and install the package and sub-dependencies.\n\nPoetry supports a rich dependency specification syntax, including caret, tilde, wildcard, inequality and multiple constraints requirements.\n\nUsing your virtual environment\n\nBy default, Poetry creates a virtual environment in {cache-dir}/virtualenvs. You can change the cache-dir value by editing the Poetry configuration. Additionally, you can use the virtualenvs.in-project configuration variable to create virtual environments within your project directory.\n\nThere are several ways to run commands within this virtual environment.\n\nExternal virtual environment management\n\nPoetry will detect and respect an existing virtual environment that has been externally activated. This is a powerful mechanism that is intended to be an alternative to Poetry’s built-in, simplified environment management.\n\nTo take advantage of this, simply activate a virtual environment using your preferred method or tooling, before running any Poetry commands that expect to manipulate an environment.\n\nUsing poetry run\n\nTo run your script simply use poetry run python your_script.py. Likewise if you have command line tools such as pytest or black you can run them using poetry run pytest.\n\nIf managing your own virtual environment externally, you do not need to use poetry run or poetry shell since you will, presumably, already have activated that virtual environment and made available the correct python instance. For example, these commands should output the same python path:\n\nconda activate your_env_name\nwhich python\npoetry run which python\npoetry shell\nwhich python\n\nActivating the virtual environment\n\nThe easiest way to activate the virtual environment is to create a nested shell with poetry shell.\n\nTo deactivate the virtual environment and exit this new shell type exit. To deactivate the virtual environment without leaving the shell use deactivate.\n\nWhy a nested shell?\n\nChild processes inherit their environment from their parents, but do not share them. As such, any modifications made by a child process is not persisted after the child process exits. A Python application (Poetry), being a child process, cannot modify the environment of the shell that it has been called from such that an activated virtual environment remains active after the Poetry command has completed execution.\n\nTherefore, Poetry has to create a sub-shell with the virtual environment activated in order for the subsequent commands to run from within the virtual environment.\n\nIf you’d like to prevent poetry shell from modifying your shell prompt on virtual environment activation, you should set VIRTUAL_ENV_DISABLE_PROMPT=1 as an environment variable before running the command.\n\nAlternatively, to avoid creating a new shell, you can manually activate the virtual environment by running source {path_to_venv}/bin/activate ({path_to_venv}\\Scripts\\activate.ps1 in PowerShell). To get the path to your virtual environment run poetry env info --path. You can also combine these into a one-liner, such as source $(poetry env info --path)/bin/activate (& ((poetry env info --path) + \"\\Scripts\\activate.ps1\") in Powershell).\n\nTo deactivate this virtual environment simply use deactivate.\n\n\tPOSIX SHELL\tWINDOWS (POWERSHELL)\tEXIT/DEACTIVATE\nSub-shell\tpoetry shell\tpoetry shell\texit\nManual Activation\tsource {path_to_venv}/bin/activate\t{path_to_venv}\\Scripts\\activate.ps1\tdeactivate\nOne-liner\tsource $(poetry env info --path)/bin/activate\t& ((poetry env info --path) + \"\\Scripts\\activate.ps1\")\tdeactivate\nVersion constraints\n\nIn our example, we are requesting the pendulum package with the version constraint ^2.1. This means any version greater or equal to 2.1.0 and less than 3.0.0 (>=2.1.0 <3.0.0).\n\nPlease read Dependency specification for more in-depth information on versions, how versions relate to each other, and on the different ways you can specify dependencies.\n\nHow does Poetry download the right files?\n\nWhen you specify a dependency in pyproject.toml, Poetry first takes the name of the package that you have requested and searches for it in any repository you have registered using the repositories key. If you have not registered any extra repositories, or it does not find a package with that name in the repositories you have specified, it falls back to PyPI.\n\nWhen Poetry finds the right package, it then attempts to find the best match for the version constraint you have specified.\n\nInstalling dependencies\n\nTo install the defined dependencies for your project, just run the install command.\n\npoetry install\n\n\nWhen you run this command, one of two things may happen:\n\nInstalling without poetry.lock\n\nIf you have never run the command before and there is also no poetry.lock file present, Poetry simply resolves all dependencies listed in your pyproject.toml file and downloads the latest version of their files.\n\nWhen Poetry has finished installing, it writes all the packages and their exact versions that it downloaded to the poetry.lock file, locking the project to those specific versions. You should commit the poetry.lock file to your project repo so that all people working on the project are locked to the same versions of dependencies (more below).\n\nInstalling with poetry.lock\n\nThis brings us to the second scenario. If there is already a poetry.lock file as well as a pyproject.toml file when you run poetry install, it means either you ran the install command before, or someone else on the project ran the install command and committed the poetry.lock file to the project (which is good).\n\nEither way, running install when a poetry.lock file is present resolves and installs all dependencies that you listed in pyproject.toml, but Poetry uses the exact versions listed in poetry.lock to ensure that the package versions are consistent for everyone working on your project. As a result you will have all dependencies requested by your pyproject.toml file, but they may not all be at the very latest available versions (some dependencies listed in the poetry.lock file may have released newer versions since the file was created). This is by design, it ensures that your project does not break because of unexpected changes in dependencies.\n\nCommitting your poetry.lock file to version control\nAs an application developer\n\nApplication developers commit poetry.lock to get more reproducible builds.\n\nCommitting this file to VC is important because it will cause anyone who sets up the project to use the exact same versions of the dependencies that you are using. Your CI server, production machines, other developers in your team, everything and everyone runs on the same dependencies, which mitigates the potential for bugs affecting only some parts of the deployments. Even if you develop alone, in six months when reinstalling the project you can feel confident the dependencies installed are still working even if your dependencies released many new versions since then. (See note below about using the update command.)\n\nIf you have added the recommended [build-system] section to your project’s pyproject.toml then you can successfully install your project and its dependencies into a virtual environment using a command like pip install -e .. However, pip will not use the lock file to determine dependency versions as the poetry-core build system is intended for library developers (see next section).\nAs a library developer\n\nLibrary developers have more to consider. Your users are application developers, and your library will run in a Python environment you don’t control.\n\nThe application ignores your library’s lock file. It can use whatever dependency version meets the constraints in your pyproject.toml. The application will probably use the latest compatible dependency version. If your library’s poetry.lock falls behind some new dependency version that breaks things for your users, you’re likely to be the last to find out about it.\n\nA simple way to avoid such a scenario is to omit the poetry.lock file. However, by doing so, you sacrifice reproducibility and performance to a certain extent. Without a lockfile, it can be difficult to find the reason for failing tests, because in addition to obvious code changes an unnoticed library update might be the culprit. Further, Poetry will have to lock before installing a dependency if poetry.lock has been omitted. Depending on the number of dependencies, locking may take a significant amount of time.\n\nIf you do not want to give up the reproducibility and performance benefits, consider a regular refresh of poetry.lock to stay up-to-date and reduce the risk of sudden breakage for users.\n\nInstalling dependencies only\n\nThe current project is installed in editable mode by default.\n\nIf you want to install the dependencies only, run the install command with the --no-root flag:\n\npoetry install --no-root\n\nUpdating dependencies to their latest versions\n\nAs mentioned above, the poetry.lock file prevents you from automatically getting the latest versions of your dependencies. To update to the latest versions, use the update command. This will fetch the latest matching versions (according to your pyproject.toml file) and update the lock file with the new versions. (This is equivalent to deleting the poetry.lock file and running install again.)\n\nPoetry will display a Warning when executing an install command if poetry.lock and pyproject.toml are not synchronized.\nFooter\n\nPython packaging and dependency management made easy.\n\nGitHub\nDiscord\nDOCUMENTATION\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\n GITHUB\nProject\nIssues\nDiscussions\nOTHER PROJECTS\npoetry-core\ninstall.python-poetry.org\nBundle plugin\nExport plugin\n\nCopyright © 2018-2024. All Rights Reserved.\nPowered by"
  },
  {
    "title": "Introduction | 1.7 | Documentation | Poetry - Python dependency management and packaging made easy",
    "url": "https://python-poetry.org/docs/1.7/",
    "html": "Home\nSearch\n1.7\nUse dark mode\nDOCUMENTATION\nBLOG\nHISTORY\nIntroduction\nSystem requirements\nInstallation\nEnable tab completion for Bash, Fish, or Zsh\nBash\nFish\nZsh\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\nIntroduction\n\nPoetry is a tool for dependency management and packaging in Python. It allows you to declare the libraries your project depends on and it will manage (install/update) them for you. Poetry offers a lockfile to ensure repeatable installs, and can build your project for distribution.\n\nSystem requirements\n\nPoetry requires Python 3.8+. It is multi-platform and the goal is to make it work equally well on Linux, macOS and Windows.\n\nInstallation\nPoetry should always be installed in a dedicated virtual environment to isolate it from the rest of your system. In no case, it should be installed in the environment of the project that is to be managed by Poetry. This ensures that Poetry’s own dependencies will not be accidentally upgraded or uninstalled. (Each of the following installation methods ensures that Poetry is installed into an isolated environment.)\nIf you are viewing documentation for the development branch, you may wish to install a preview or development version of Poetry. See the advanced installation instructions to use a preview or alternate version of Poetry.\nWith pipx\nWith the official installer\nManually (advanced)\nCI recommendations\n\npipx is used to install Python CLI applications globally while still isolating them in virtual environments. pipx will manage upgrades and uninstalls when used to install Poetry.\n\nInstall Poetry\n\npipx install poetry\n\n\nInstall Poetry (advanced)\n\npipx can install different versions of Poetry, using the same syntax as pip:\n\npipx install poetry==1.2.0\n\n\npipx can also install versions of Poetry in parallel, which allows for easy testing of alternate or prerelease versions. Each version is given a unique, user-specified suffix, which will be used to create a unique binary name:\n\npipx install --suffix=@1.2.0 poetry==1.2.0\npoetry@1.2.0 --version\n\npipx install --suffix=@preview --pip-args=--pre poetry\npoetry@preview --version\n\n\nFinally, pipx can install any valid pip requirement spec, which allows for installations of the development version from git, or even for local testing of pull requests:\n\npipx install --suffix @master git+https://github.com/python-poetry/poetry.git@master\npipx install --suffix @pr1234 git+https://github.com/python-poetry/poetry.git@refs/pull/1234/head\n\n\nUpdate Poetry\n\npipx upgrade poetry\n\n\nUninstall Poetry\n\npipx uninstall poetry\n\nEnable tab completion for Bash, Fish, or Zsh\n\npoetry supports generating completion scripts for Bash, Fish, and Zsh. See poetry help completions for full details, but the gist is as simple as using one of the following:\n\nBash\nAuto-loaded (recommended)\npoetry completions bash >> ~/.bash_completion\n\nLazy-loaded\npoetry completions bash > ${XDG_DATA_HOME:-~/.local/share}/bash-completion/completions/poetry\n\nFish\npoetry completions fish > ~/.config/fish/completions/poetry.fish\n\nZsh\npoetry completions zsh > ~/.zfunc/_poetry\n\n\nYou must then add the following lines in your ~/.zshrc, if they do not already exist:\n\nfpath+=~/.zfunc\nautoload -Uz compinit && compinit\n\nOh My Zsh\nmkdir $ZSH_CUSTOM/plugins/poetry\npoetry completions zsh > $ZSH_CUSTOM/plugins/poetry/_poetry\n\n\nYou must then add poetry to your plugins array in ~/.zshrc:\n\nplugins(\n\tpoetry\n\t...\n\t)\n\nprezto\npoetry completions zsh > ~/.zprezto/modules/completion/external/src/_poetry\n\nYou may need to restart your shell in order for these changes to take effect.\nFooter\n\nPython packaging and dependency management made easy.\n\nGitHub\nDiscord\nDOCUMENTATION\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\n GITHUB\nProject\nIssues\nDiscussions\nOTHER PROJECTS\npoetry-core\ninstall.python-poetry.org\nBundle plugin\nExport plugin\n\nCopyright © 2018-2024. All Rights Reserved.\nPowered by"
  },
  {
    "title": "Introduction | main | Documentation | Poetry - Python dependency management and packaging made easy",
    "url": "https://python-poetry.org/docs/main/",
    "html": "Home\nSearch\nmain\nUse dark mode\nDOCUMENTATION\nBLOG\nHISTORY\nIntroduction\nSystem requirements\nInstallation\nEnable tab completion for Bash, Fish, or Zsh\nBash\nFish\nZsh\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\nIntroduction\n\nPoetry is a tool for dependency management and packaging in Python. It allows you to declare the libraries your project depends on and it will manage (install/update) them for you. Poetry offers a lockfile to ensure repeatable installs, and can build your project for distribution.\n\nSystem requirements\n\nPoetry requires Python 3.8+. It is multi-platform and the goal is to make it work equally well on Linux, macOS and Windows.\n\nInstallation\nPoetry should always be installed in a dedicated virtual environment to isolate it from the rest of your system. It should in no case be installed in the environment of the project that is to be managed by Poetry. This ensures that Poetry’s own dependencies will not be accidentally upgraded or uninstalled. (Each of the following installation methods ensures that Poetry is installed into an isolated environment.) In addition, the isolated virtual environment in which poetry is installed should not be activated for running poetry commands.\nIf you are viewing documentation for the development branch, you may wish to install a preview or development version of Poetry. See the advanced installation instructions to use a preview or alternate version of Poetry.\nWith pipx\nWith the official installer\nManually (advanced)\nCI recommendations\n\npipx is used to install Python CLI applications globally while still isolating them in virtual environments. pipx will manage upgrades and uninstalls when used to install Poetry.\n\nInstall pipx\n\nIf pipx is not already installed, you can follow any of the options in the official pipx installation instructions. Any non-ancient version of pipx will do.\n\nInstall Poetry\n\npipx install poetry\n\n\nInstall Poetry (advanced)\n\nYou can skip this step, if you simply want the latest version and already installed Poetry as described in the previous step. This step details advanced usages of this installation method. For example, installing Poetry from source, having multiple versions installed at the same time etc.\n\npipx can install different versions of Poetry, using the same syntax as pip:\n\npipx install poetry==1.2.0\n\n\npipx can also install versions of Poetry in parallel, which allows for easy testing of alternate or prerelease versions. Each version is given a unique, user-specified suffix, which will be used to create a unique binary name:\n\npipx install --suffix=@1.2.0 poetry==1.2.0\npoetry@1.2.0 --version\n\npipx install --suffix=@preview --pip-args=--pre poetry\npoetry@preview --version\n\n\nFinally, pipx can install any valid pip requirement spec, which allows for installations of the development version from git, or even for local testing of pull requests:\n\npipx install --suffix @main git+https://github.com/python-poetry/poetry.git@main\npipx install --suffix @pr1234 git+https://github.com/python-poetry/poetry.git@refs/pull/1234/head\n\n\nUpdate Poetry\n\npipx upgrade poetry\n\n\nUninstall Poetry\n\npipx uninstall poetry\n\nEnable tab completion for Bash, Fish, or Zsh\n\npoetry supports generating completion scripts for Bash, Fish, and Zsh. See poetry help completions for full details, but the gist is as simple as using one of the following:\n\nBash\nAuto-loaded (recommended)\npoetry completions bash >> ~/.bash_completion\n\nLazy-loaded\npoetry completions bash > ${XDG_DATA_HOME:-~/.local/share}/bash-completion/completions/poetry\n\nFish\npoetry completions fish > ~/.config/fish/completions/poetry.fish\n\nZsh\npoetry completions zsh > ~/.zfunc/_poetry\n\n\nYou must then add the following lines in your ~/.zshrc, if they do not already exist:\n\nfpath+=~/.zfunc\nautoload -Uz compinit && compinit\n\nOh My Zsh\nmkdir $ZSH_CUSTOM/plugins/poetry\npoetry completions zsh > $ZSH_CUSTOM/plugins/poetry/_poetry\n\n\nYou must then add poetry to your plugins array in ~/.zshrc:\n\nplugins(\n\tpoetry\n\t...\n\t)\n\nprezto\npoetry completions zsh > ~/.zprezto/modules/completion/external/src/_poetry\n\nYou may need to restart your shell in order for these changes to take effect.\nFooter\n\nPython packaging and dependency management made easy.\n\nGitHub\nDiscord\nDOCUMENTATION\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\n GITHUB\nProject\nIssues\nDiscussions\nOTHER PROJECTS\npoetry-core\ninstall.python-poetry.org\nBundle plugin\nExport plugin\n\nCopyright © 2018-2024. All Rights Reserved.\nPowered by"
  },
  {
    "title": "Introduction | Documentation | Poetry - Python dependency management and packaging made easy",
    "url": "https://python-poetry.org/docs/",
    "html": "Home\nSearch\n1.8\nUse dark mode\nDOCUMENTATION\nBLOG\nHISTORY\nIntroduction\nSystem requirements\nInstallation\nEnable tab completion for Bash, Fish, or Zsh\nBash\nFish\nZsh\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\nIntroduction\n\nPoetry is a tool for dependency management and packaging in Python. It allows you to declare the libraries your project depends on and it will manage (install/update) them for you. Poetry offers a lockfile to ensure repeatable installs, and can build your project for distribution.\n\nSystem requirements\n\nPoetry requires Python 3.8+. It is multi-platform and the goal is to make it work equally well on Linux, macOS and Windows.\n\nInstallation\nPoetry should always be installed in a dedicated virtual environment to isolate it from the rest of your system. It should in no case be installed in the environment of the project that is to be managed by Poetry. This ensures that Poetry’s own dependencies will not be accidentally upgraded or uninstalled. (Each of the following installation methods ensures that Poetry is installed into an isolated environment.) In addition, the isolated virtual environment in which poetry is installed should not be activated for running poetry commands.\nIf you are viewing documentation for the development branch, you may wish to install a preview or development version of Poetry. See the advanced installation instructions to use a preview or alternate version of Poetry.\nWith pipx\nWith the official installer\nManually (advanced)\nCI recommendations\n\npipx is used to install Python CLI applications globally while still isolating them in virtual environments. pipx will manage upgrades and uninstalls when used to install Poetry.\n\nInstall pipx\n\nIf pipx is not already installed, you can follow any of the options in the official pipx installation instructions. Any non-ancient version of pipx will do.\n\nInstall Poetry\n\npipx install poetry\n\n\nInstall Poetry (advanced)\n\nYou can skip this step, if you simply want the latest version and already installed Poetry as described in the previous step. This step details advanced usages of this installation method. For example, installing Poetry from source, having multiple versions installed at the same time etc.\n\npipx can install different versions of Poetry, using the same syntax as pip:\n\npipx install poetry==1.2.0\n\n\npipx can also install versions of Poetry in parallel, which allows for easy testing of alternate or prerelease versions. Each version is given a unique, user-specified suffix, which will be used to create a unique binary name:\n\npipx install --suffix=@1.2.0 poetry==1.2.0\npoetry@1.2.0 --version\n\npipx install --suffix=@preview --pip-args=--pre poetry\npoetry@preview --version\n\n\nFinally, pipx can install any valid pip requirement spec, which allows for installations of the development version from git, or even for local testing of pull requests:\n\npipx install --suffix @main git+https://github.com/python-poetry/poetry.git@main\npipx install --suffix @pr1234 git+https://github.com/python-poetry/poetry.git@refs/pull/1234/head\n\n\nUpdate Poetry\n\npipx upgrade poetry\n\n\nUninstall Poetry\n\npipx uninstall poetry\n\nEnable tab completion for Bash, Fish, or Zsh\n\npoetry supports generating completion scripts for Bash, Fish, and Zsh. See poetry help completions for full details, but the gist is as simple as using one of the following:\n\nBash\nAuto-loaded (recommended)\npoetry completions bash >> ~/.bash_completion\n\nLazy-loaded\npoetry completions bash > ${XDG_DATA_HOME:-~/.local/share}/bash-completion/completions/poetry\n\nFish\npoetry completions fish > ~/.config/fish/completions/poetry.fish\n\nZsh\npoetry completions zsh > ~/.zfunc/_poetry\n\n\nYou must then add the following lines in your ~/.zshrc, if they do not already exist:\n\nfpath+=~/.zfunc\nautoload -Uz compinit && compinit\n\nOh My Zsh\nmkdir $ZSH_CUSTOM/plugins/poetry\npoetry completions zsh > $ZSH_CUSTOM/plugins/poetry/_poetry\n\n\nYou must then add poetry to your plugins array in ~/.zshrc:\n\nplugins(\n\tpoetry\n\t...\n\t)\n\nprezto\npoetry completions zsh > ~/.zprezto/modules/completion/external/src/_poetry\n\nYou may need to restart your shell in order for these changes to take effect.\nFooter\n\nPython packaging and dependency management made easy.\n\nGitHub\nDiscord\nDOCUMENTATION\nIntroduction\nBasic usage\nManaging dependencies\nLibraries\nCommands\nConfiguration\nRepositories\nManaging environments\nDependency specification\nPlugins\nThe pyproject.toml file\nContributing to Poetry\nCommunity\nFAQ\npre-commit hooks\n GITHUB\nProject\nIssues\nDiscussions\nOTHER PROJECTS\npoetry-core\ninstall.python-poetry.org\nBundle plugin\nExport plugin\n\nCopyright © 2018-2024. All Rights Reserved.\nPowered by"
  }
]